<!doctype html><html class="theme-next mist use-motion" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="deep learning,machine learning,svm,"><link rel="alternate" href="/atom.xml" title="Abracadabra" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="Multiclass Support Vector Machine exerciseComplete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For mo"><meta property="og:type" content="article"><meta property="og:title" content="cs231n Assignment#1 svm"><meta property="og:url" content="http://yoursite.com/2017/03/03/cs231n-Assignment-1-svm/index.html"><meta property="og:site_name" content="Abracadabra"><meta property="og:description" content="Multiclass Support Vector Machine exerciseComplete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For mo"><meta property="og:image" content="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/sample.png"><meta property="og:image" content="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/mean.png"><meta property="og:image" content="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/learning_curve.png"><meta property="og:image" content="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/accuracy.png"><meta property="og:image" content="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/weight.png"><meta property="og:updated_time" content="2017-03-03T11:04:37.635Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="cs231n Assignment#1 svm"><meta name="twitter:description" content="Multiclass Support Vector Machine exerciseComplete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For mo"><meta name="twitter:image" content="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/sample.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2017/03/03/cs231n-Assignment-1-svm/"><title>cs231n Assignment#1 svm | Abracadabra</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?dc405a79ad500922134d14cdf288f646";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Abracadabra</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Do it yourself</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div><span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/03/cs231n-Assignment-1-svm/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline">cs231n Assignment#1 svm</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-03T18:55:44+08:00">2017-03-03 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/03/03/cs231n-Assignment-1-svm/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2017/03/03/cs231n-Assignment-1-svm/" itemprop="commentsCount"></span> </a></span><span id="/2017/03/03/cs231n-Assignment-1-svm/" class="leancloud_visitors" data-flag-title="cs231n Assignment#1 svm"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Multiclass-Support-Vector-Machine-exercise"><a href="#Multiclass-Support-Vector-Machine-exercise" class="headerlink" title="Multiclass Support Vector Machine exercise"></a>Multiclass Support Vector Machine exercise</h1><p><em>Complete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For more details see the <a href="http://vision.stanford.edu/teaching/cs231n/assignments.html" target="_blank" rel="external">assignments page</a> on the course website.</em></p><p>In this exercise you will:<br>​</p><ul><li>implement a fully-vectorized <strong>loss function</strong> for the SVM</li><li>implement the fully-vectorized expression for its <strong>analytic gradient</strong></li><li><strong>check your implementation</strong> using numerical gradient</li><li>use a validation set to <strong>tune the learning rate and regularization</strong> strength</li><li><strong>optimize</strong> the loss function with <strong>SGD</strong></li><li><strong>visualize</strong> the final learned weights</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Run some setup code for this notebook.</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> cs231n.data_utils <span class="keyword">import</span> load_CIFAR10</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># This is a bit of magic to make matplotlib figures appear inline in the</span></div><div class="line"><span class="comment"># notebook rather than in a new window.</span></div><div class="line">%matplotlib inline</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line"><span class="comment"># Some more magic so that the notebook will reload external python modules;</span></div><div class="line"><span class="comment"># see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython</span></div><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div></pre></td></tr></table></figure><h2 id="CIFAR-10-Data-Loading-and-Preprocessing"><a href="#CIFAR-10-Data-Loading-and-Preprocessing" class="headerlink" title="CIFAR-10 Data Loading and Preprocessing"></a>CIFAR-10 Data Loading and Preprocessing</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Load the raw CIFAR-10 data.</span></div><div class="line">cifar10_dir = <span class="string">'cs231n/datasets/cifar-10-batches-py'</span></div><div class="line">X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)</div><div class="line"></div><div class="line"><span class="comment"># As a sanity check, we print out the size of the training and test data.</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Training data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Training labels shape: '</span>, y_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test labels shape: '</span>, y_test.shape</div></pre></td></tr></table></figure><pre><code>Training data shape:  (50000L, 32L, 32L, 3L)
Training labels shape:  (50000L,)
Test data shape:  (10000L, 32L, 32L, 3L)
Test labels shape:  (10000L,)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize some examples from the dataset.</span></div><div class="line"><span class="comment"># We show a few examples of training images from each class.</span></div><div class="line">classes = [<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>, <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>]</div><div class="line">num_classes = len(classes)</div><div class="line">samples_per_class = <span class="number">7</span></div><div class="line"><span class="keyword">for</span> y, cls <span class="keyword">in</span> enumerate(classes):</div><div class="line">    idxs = np.flatnonzero(y_train == y)</div><div class="line">    idxs = np.random.choice(idxs, samples_per_class, replace=<span class="keyword">False</span>)</div><div class="line">    <span class="keyword">for</span> i, idx <span class="keyword">in</span> enumerate(idxs):</div><div class="line">        plt_idx = i * num_classes + y + <span class="number">1</span></div><div class="line">        plt.subplot(samples_per_class, num_classes, plt_idx)</div><div class="line">        plt.imshow(X_train[idx].astype(<span class="string">'uint8'</span>))</div><div class="line">        plt.axis(<span class="string">'off'</span>)</div><div class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</div><div class="line">            plt.title(cls)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/sample.png" alt="sample"></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?np.random.choice</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Split the data into train, val, and test sets. In addition we will</span></div><div class="line"><span class="comment"># create a small development set as a subset of the training data;</span></div><div class="line"><span class="comment"># we can use this for development so our code runs faster.</span></div><div class="line">num_training = <span class="number">49000</span></div><div class="line">num_validation = <span class="number">1000</span></div><div class="line">num_test = <span class="number">1000</span></div><div class="line">num_dev = <span class="number">500</span></div><div class="line"></div><div class="line"><span class="comment"># Our validation set will be num_validation points from the original</span></div><div class="line"><span class="comment"># training set.</span></div><div class="line">mask = range(num_training, num_training + num_validation)</div><div class="line">X_val = X_train[mask]</div><div class="line">y_val = y_train[mask]</div><div class="line"></div><div class="line"><span class="comment"># Our training set will be the first num_train points from the original</span></div><div class="line"><span class="comment"># training set.</span></div><div class="line">mask = range(num_training)</div><div class="line">X_train = X_train[mask]</div><div class="line">y_train = y_train[mask]</div><div class="line"></div><div class="line"><span class="comment"># We will also make a development set, which is a small subset of</span></div><div class="line"><span class="comment"># the training set.</span></div><div class="line">mask = np.random.choice(num_training, num_dev, replace=<span class="keyword">False</span>)</div><div class="line">X_dev = X_train[mask]</div><div class="line">y_dev = y_train[mask]</div><div class="line"></div><div class="line"><span class="comment"># We use the first num_test points of the original test set as our</span></div><div class="line"><span class="comment"># test set.</span></div><div class="line">mask = range(num_test)</div><div class="line">X_test = X_test[mask]</div><div class="line">y_test = y_test[mask]</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'Train data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Train labels shape: '</span>, y_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation data shape: '</span>, X_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation labels shape: '</span>, y_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test labels shape: '</span>, y_test.shape</div></pre></td></tr></table></figure><pre><code>Train data shape:  (49000L, 32L, 32L, 3L)
Train labels shape:  (49000L,)
Validation data shape:  (1000L, 32L, 32L, 3L)
Validation labels shape:  (1000L,)
Test data shape:  (1000L, 32L, 32L, 3L)
Test labels shape:  (1000L,)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Preprocessing: reshape the image data into rows</span></div><div class="line">X_train = np.reshape(X_train, (X_train.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">X_val = np.reshape(X_val, (X_val.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">X_dev = np.reshape(X_dev, (X_dev.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line"></div><div class="line"><span class="comment"># As a sanity check, print out the shapes of the data</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Training data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation data shape: '</span>, X_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'dev data shape: '</span>, X_dev.shape</div></pre></td></tr></table></figure><pre><code>Training data shape:  (49000L, 3072L)
Validation data shape:  (1000L, 3072L)
Test data shape:  (1000L, 3072L)
dev data shape:  (500L, 3072L)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Preprocessing: subtract the mean image</span></div><div class="line"><span class="comment"># first: compute the image mean based on the training data</span></div><div class="line">mean_image = np.mean(X_train, axis=<span class="number">0</span>)</div><div class="line"><span class="keyword">print</span> mean_image[:<span class="number">10</span>] <span class="comment"># print a few of the elements</span></div><div class="line">plt.figure(figsize=(<span class="number">4</span>,<span class="number">4</span>))</div><div class="line">plt.imshow(mean_image.reshape((<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>)).astype(<span class="string">'uint8'</span>)) <span class="comment"># visualize the mean image</span></div><div class="line">plt.show()</div></pre></td></tr></table></figure><pre><code>[ 130.64189796  135.98173469  132.47391837  130.05569388  135.34804082
  131.75402041  130.96055102  136.14328571  132.47636735  131.48467347]
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/mean.png" alt="mean"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># second: subtract the mean image from train and test data</span></div><div class="line">X_train -= mean_image</div><div class="line">X_val -= mean_image</div><div class="line">X_test -= mean_image</div><div class="line">X_dev -= mean_image</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># third: append (at the last) the bias dimension of ones (i.e. bias trick) so that our SVM</span></div><div class="line"><span class="comment"># only has to worry about optimizing a single weight matrix W.</span></div><div class="line">X_train = np.hstack([X_train, np.ones((X_train.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">X_val = np.hstack([X_val, np.ones((X_val.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">X_test = np.hstack([X_test, np.ones((X_test.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">X_dev = np.hstack([X_dev, np.ones((X_dev.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line"></div><div class="line"><span class="keyword">print</span> X_train.shape, X_val.shape, X_test.shape, X_dev.shape</div></pre></td></tr></table></figure><pre><code>(49000L, 3073L) (1000L, 3073L) (1000L, 3073L) (500L, 3073L)
</code></pre><p>​</p><h2 id="SVM-Classifier"><a href="#SVM-Classifier" class="headerlink" title="SVM Classifier"></a>SVM Classifier</h2><p>Your code for this section will all be written inside <strong>cs231n/classifiers/linear_svm.py</strong>.</p><p>As you can see, we have prefilled the function <code>compute_loss_naive</code> which uses for loops to evaluate the multiclass SVM loss function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Evaluate the naive implementation of the loss we provided for you:</span></div><div class="line"><span class="keyword">from</span> cs231n.classifiers.linear_svm <span class="keyword">import</span> svm_loss_naive</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># generate a random SVM weight matrix of small numbers</span></div><div class="line">W = np.random.randn(<span class="number">3073</span>, <span class="number">10</span>) * <span class="number">0.0001</span> </div><div class="line"></div><div class="line">loss, grad = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'loss: %f'</span> % (loss, )</div></pre></td></tr></table></figure><pre><code>loss: 8.831645
</code></pre><p>​</p><p>The <code>grad</code> returned from the function above is right now all zero. Derive and implement the gradient for the SVM cost function and implement it inline inside the function <code>svm_loss_naive</code>. You will find it helpful to interleave your new code inside the existing function.</p><p>To check that you have correctly implemented the gradient correctly, you can numerically estimate the gradient of the loss function and compare the numeric estimate to the gradient that you computed. We have provided code that does this for you:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Once you've implemented the gradient, recompute it with the code below</span></div><div class="line"><span class="comment"># and gradient check it with the function we provided for you</span></div><div class="line"></div><div class="line"><span class="comment"># Compute the loss and its gradient at W.</span></div><div class="line">loss, grad = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.0</span>)</div><div class="line"></div><div class="line"><span class="comment"># Numerically compute the gradient along several randomly chosen dimensions, and</span></div><div class="line"><span class="comment"># compare them with your analytically computed gradient. The numbers should match</span></div><div class="line"><span class="comment"># almost exactly along all dimensions.</span></div><div class="line"><span class="keyword">from</span> cs231n.gradient_check <span class="keyword">import</span> grad_check_sparse</div><div class="line">f = <span class="keyword">lambda</span> w: svm_loss_naive(w, X_dev, y_dev, <span class="number">0.0</span>)[<span class="number">0</span>]</div><div class="line">grad_numerical = grad_check_sparse(f, W, grad)</div><div class="line"></div><div class="line"><span class="comment"># do the gradient check once again with regularization turned on</span></div><div class="line"><span class="comment"># you didn't forget the regularization gradient did you?</span></div><div class="line">loss, grad = svm_loss_naive(W, X_dev, y_dev, <span class="number">1e2</span>)</div><div class="line">f = <span class="keyword">lambda</span> w: svm_loss_naive(w, X_dev, y_dev, <span class="number">1e2</span>)[<span class="number">0</span>]</div><div class="line">grad_numerical = grad_check_sparse(f, W, grad)</div></pre></td></tr></table></figure><pre><code>numerical: -13.865929 analytic: -13.865929, relative error: 1.283977e-12
numerical: 7.842142 analytic: 7.735021, relative error: 6.876784e-03
numerical: 3.464393 analytic: 3.464393, relative error: 9.040092e-11
numerical: -23.034911 analytic: -23.034911, relative error: 6.876266e-12
numerical: -0.185311 analytic: -0.185311, relative error: 2.538774e-10
numerical: 25.825504 analytic: 25.825504, relative error: 1.336035e-11
numerical: 4.457836 analytic: 4.457836, relative error: 1.015819e-10
numerical: 3.184691 analytic: 3.184691, relative error: 8.849109e-11
numerical: 10.428446 analytic: 10.374317, relative error: 2.601982e-03
numerical: 12.479957 analytic: 12.479957, relative error: 6.825191e-12
numerical: 12.237949 analytic: 12.326308, relative error: 3.597051e-03
numerical: 4.377103 analytic: 4.377103, relative error: 3.904758e-11
numerical: -1.951930 analytic: -1.951930, relative error: 1.432276e-10
numerical: 33.752503 analytic: 33.752503, relative error: 4.254520e-12
numerical: 11.367149 analytic: 11.367149, relative error: 1.682727e-11
numerical: 16.461879 analytic: 16.461879, relative error: 4.766805e-12
numerical: 3.814562 analytic: 3.814562, relative error: 1.087469e-10
numerical: 13.931226 analytic: 13.931226, relative error: 9.578349e-12
numerical: -27.291095 analytic: -27.395406, relative error: 1.907445e-03
numerical: -7.610407 analytic: -7.610407, relative error: 1.015282e-12
</code></pre><h3 id="Inline-Question-1"><a href="#Inline-Question-1" class="headerlink" title="Inline Question 1:"></a>Inline Question 1:</h3><p>It is possible that once in a while a dimension in the gradcheck will not match exactly. What could such a discrepancy be caused by? Is it a reason for concern? What is a simple example in one dimension where a gradient check could fail? <em>Hint: the SVM loss function is not strictly speaking differentiable</em></p><p><strong>Your Answer:</strong> <em>Maybe the SVM loss function is not differentiable on that dimension</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?np.max</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.sum(np.maximum(<span class="number">0</span>, X_dev.dot(W) - X_dev.dot(W)[np.arange(len(y_dev)), [y_dev]].T + <span class="number">1</span>))</div></pre></td></tr></table></figure><pre><code>4915.822409730994
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Next implement the function svm_loss_vectorized; for now only compute the loss;</span></div><div class="line"><span class="comment"># we will implement the gradient in a moment.</span></div><div class="line">tic = time.time()</div><div class="line">loss_naive, grad_naive = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Naive loss: %e computed in %fs'</span> % (loss_naive, toc - tic)</div><div class="line"></div><div class="line"><span class="keyword">from</span> cs231n.classifiers.linear_svm <span class="keyword">import</span> svm_loss_vectorized</div><div class="line">tic = time.time()</div><div class="line">loss_vectorized, _ = svm_loss_vectorized(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Vectorized loss: %e computed in %fs'</span> % (loss_vectorized, toc - tic)</div><div class="line"></div><div class="line"><span class="comment"># The losses should match but your vectorized implementation should be much faster.</span></div><div class="line"><span class="keyword">print</span> <span class="string">'difference: %f'</span> % (loss_naive - loss_vectorized)</div></pre></td></tr></table></figure><pre><code>Naive loss: 8.831645e+00 computed in 0.071000s
Vectorized loss: 8.831645e+00 computed in 0.000000s
difference: 0.000000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Complete the implementation of svm_loss_vectorized, and compute the gradient</span></div><div class="line"><span class="comment"># of the loss function in a vectorized way.</span></div><div class="line"></div><div class="line"><span class="comment"># The naive implementation and the vectorized implementation should match, but</span></div><div class="line"><span class="comment"># the vectorized version should still be much faster.</span></div><div class="line">tic = time.time()</div><div class="line">_, grad_naive = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Naive loss and gradient: computed in %fs'</span> % (toc - tic)</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line">_, grad_vectorized = svm_loss_vectorized(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Vectorized loss and gradient: computed in %fs'</span> % (toc - tic)</div><div class="line"></div><div class="line"><span class="comment"># The loss is a single number, so it is easy to compare the values computed</span></div><div class="line"><span class="comment"># by the two implementations. The gradient on the other hand is a matrix, so</span></div><div class="line"><span class="comment"># we use the Frobenius norm to compare them.</span></div><div class="line">difference = np.linalg.norm(grad_naive - grad_vectorized, ord=<span class="string">'fro'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'difference: %f'</span> % difference</div></pre></td></tr></table></figure><pre><code>Naive loss and gradient: computed in 0.084000s
Vectorized loss and gradient: computed in 0.005000s
difference: 0.000000
</code></pre><h3 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h3><p>We now have vectorized and efficient expressions for the loss, the gradient and our gradient matches the numerical gradient. We are therefore ready to do SGD to minimize the loss.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># In the file linear_classifier.py, implement SGD in the function</span></div><div class="line"><span class="comment"># LinearClassifier.train() and then run it with the code below.</span></div><div class="line"><span class="keyword">from</span> cs231n.classifiers <span class="keyword">import</span> LinearSVM</div><div class="line">svm = LinearSVM()</div><div class="line">tic = time.time()</div><div class="line">loss_hist = svm.train(X_train, y_train, learning_rate=<span class="number">1e-7</span>, reg=<span class="number">5e4</span>,</div><div class="line">                      num_iters=<span class="number">1500</span>, verbose=<span class="keyword">True</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'That took %fs'</span> % (toc - tic)</div></pre></td></tr></table></figure><pre><code>iteration 0 / 1500: loss 791.772037
iteration 100 / 1500: loss 286.021346
iteration 200 / 1500: loss 107.673095
iteration 300 / 1500: loss 41.812791
iteration 400 / 1500: loss 18.665578
iteration 500 / 1500: loss 10.614984
iteration 600 / 1500: loss 6.664814
iteration 700 / 1500: loss 6.509693
iteration 800 / 1500: loss 5.792204
iteration 900 / 1500: loss 4.986855
iteration 1000 / 1500: loss 5.914691
iteration 1100 / 1500: loss 5.058078
iteration 1200 / 1500: loss 5.491475
iteration 1300 / 1500: loss 5.609450
iteration 1400 / 1500: loss 5.376595
That took 5.454000s
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A useful debugging strategy is to plot the loss as a function of</span></div><div class="line"><span class="comment"># iteration number:</span></div><div class="line">plt.plot(loss_hist)</div><div class="line">plt.xlabel(<span class="string">'Iteration number'</span>)</div><div class="line">plt.ylabel(<span class="string">'Loss value'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/learning_curve.png" alt="learning_curve"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Write the LinearSVM.predict function and evaluate the performance on both the</span></div><div class="line"><span class="comment"># training and validation set</span></div><div class="line">y_train_pred = svm.predict(X_train)</div><div class="line"><span class="keyword">print</span> <span class="string">'training accuracy: %f'</span> % (np.mean(y_train == y_train_pred), )</div><div class="line">y_val_pred = svm.predict(X_val)</div><div class="line"><span class="keyword">print</span> <span class="string">'validation accuracy: %f'</span> % (np.mean(y_val == y_val_pred), )</div></pre></td></tr></table></figure><pre><code>training accuracy: 0.364980
validation accuracy: 0.378000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use the validation set to tune hyperparameters (regularization strength and</span></div><div class="line"><span class="comment"># learning rate). You should experiment with different ranges for the learning</span></div><div class="line"><span class="comment"># rates and regularization strengths; if you are careful you should be able to</span></div><div class="line"><span class="comment"># get a classification accuracy of about 0.4 on the validation set.</span></div><div class="line">learning_rates = [<span class="number">1e-8</span>, <span class="number">1e-7</span>, <span class="number">2e-7</span>]</div><div class="line">regularization_strengths = [<span class="number">1e4</span>, <span class="number">2e4</span>, <span class="number">3e4</span>, <span class="number">4e4</span>, <span class="number">5e4</span>, <span class="number">6e4</span>, <span class="number">7e4</span>, <span class="number">8e4</span>, <span class="number">1e5</span>]</div><div class="line"></div><div class="line"><span class="comment"># results is dictionary mapping tuples of the form</span></div><div class="line"><span class="comment"># (learning_rate, regularization_strength) to tuples of the form</span></div><div class="line"><span class="comment"># (training_accuracy, validation_accuracy). The accuracy is simply the fraction</span></div><div class="line"><span class="comment"># of data points that are correctly classified.</span></div><div class="line">results = &#123;&#125;</div><div class="line">best_val = <span class="number">-1</span>   <span class="comment"># The highest validation accuracy that we have seen so far.</span></div><div class="line">best_svm = <span class="keyword">None</span> <span class="comment"># The LinearSVM object that achieved the highest validation rate.</span></div><div class="line"></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment"># <span class="doctag">TODO:</span>                                                                        #</span></div><div class="line"><span class="comment"># Write code that chooses the best hyperparameters by tuning on the validation #</span></div><div class="line"><span class="comment"># set. For each combination of hyperparameters, train a linear SVM on the      #</span></div><div class="line"><span class="comment"># training set, compute its accuracy on the training and validation sets, and  #</span></div><div class="line"><span class="comment"># store these numbers in the results dictionary. In addition, store the best   #</span></div><div class="line"><span class="comment"># validation accuracy in best_val and the LinearSVM object that achieves this  #</span></div><div class="line"><span class="comment"># accuracy in best_svm.                                                        #</span></div><div class="line"><span class="comment">#                                                                              #</span></div><div class="line"><span class="comment"># Hint: You should use a small value for num_iters as you develop your         #</span></div><div class="line"><span class="comment"># validation code so that the SVMs don't take much time to train; once you are #</span></div><div class="line"><span class="comment"># confident that your validation code works, you should rerun the validation   #</span></div><div class="line"><span class="comment"># code with a larger value for num_iters.                                      #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="keyword">for</span> learning_rate <span class="keyword">in</span> learning_rates:</div><div class="line">    <span class="keyword">for</span> regularization_strength <span class="keyword">in</span> regularization_strengths:</div><div class="line">        svm = LinearSVM()</div><div class="line">        loss_hist = svm.train(</div><div class="line">            X_train, y_train, learning_rate, \</div><div class="line">            regularization_strength, num_iters=<span class="number">1500</span>, batch_size=<span class="number">200</span>)</div><div class="line">        y_train_pred = svm.predict(X_train)</div><div class="line">        y_val_pred = svm.predict(X_val)</div><div class="line">        training_accuracy = np.mean(y_train == y_train_pred)</div><div class="line">        validation_accuracy = np.mean(y_val == y_val_pred)</div><div class="line">        results[(learning_rate, regularization_strength)] = \</div><div class="line">        (training_accuracy, validation_accuracy)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> validation_accuracy &gt; best_val:</div><div class="line">            best_val = validation_accuracy</div><div class="line">            best_svm = svm</div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment">#                              END OF YOUR CODE                                #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line">    </div><div class="line"><span class="comment"># Print out results.</span></div><div class="line"><span class="keyword">for</span> lr, reg <span class="keyword">in</span> sorted(results):</div><div class="line">    train_accuracy, val_accuracy = results[(lr, reg)]</div><div class="line">    <span class="keyword">print</span> <span class="string">'lr %e reg %e train accuracy: %f val accuracy: %f'</span> % (</div><div class="line">                lr, reg, train_accuracy, val_accuracy)</div><div class="line">    </div><div class="line"><span class="keyword">print</span> <span class="string">'best validation accuracy achieved during cross-validation: %f'</span> % best_val</div></pre></td></tr></table></figure><pre><code>lr 1.000000e-08 reg 1.000000e+04 train accuracy: 0.221898 val accuracy: 0.247000
lr 1.000000e-08 reg 2.000000e+04 train accuracy: 0.233653 val accuracy: 0.258000
lr 1.000000e-08 reg 3.000000e+04 train accuracy: 0.234694 val accuracy: 0.225000
lr 1.000000e-08 reg 4.000000e+04 train accuracy: 0.255959 val accuracy: 0.249000
lr 1.000000e-08 reg 5.000000e+04 train accuracy: 0.259755 val accuracy: 0.273000
lr 1.000000e-08 reg 6.000000e+04 train accuracy: 0.267408 val accuracy: 0.269000
lr 1.000000e-08 reg 7.000000e+04 train accuracy: 0.269102 val accuracy: 0.287000
lr 1.000000e-08 reg 8.000000e+04 train accuracy: 0.277102 val accuracy: 0.285000
lr 1.000000e-08 reg 1.000000e+05 train accuracy: 0.295306 val accuracy: 0.301000
lr 1.000000e-07 reg 1.000000e+04 train accuracy: 0.369388 val accuracy: 0.374000
lr 1.000000e-07 reg 2.000000e+04 train accuracy: 0.380265 val accuracy: 0.390000
lr 1.000000e-07 reg 3.000000e+04 train accuracy: 0.375490 val accuracy: 0.378000
lr 1.000000e-07 reg 4.000000e+04 train accuracy: 0.375633 val accuracy: 0.385000
lr 1.000000e-07 reg 5.000000e+04 train accuracy: 0.369694 val accuracy: 0.375000
lr 1.000000e-07 reg 6.000000e+04 train accuracy: 0.372469 val accuracy: 0.383000
lr 1.000000e-07 reg 7.000000e+04 train accuracy: 0.356000 val accuracy: 0.370000
lr 1.000000e-07 reg 8.000000e+04 train accuracy: 0.352816 val accuracy: 0.355000
lr 1.000000e-07 reg 1.000000e+05 train accuracy: 0.356796 val accuracy: 0.377000
lr 2.000000e-07 reg 1.000000e+04 train accuracy: 0.393510 val accuracy: 0.395000
lr 2.000000e-07 reg 2.000000e+04 train accuracy: 0.377020 val accuracy: 0.382000
lr 2.000000e-07 reg 3.000000e+04 train accuracy: 0.363857 val accuracy: 0.373000
lr 2.000000e-07 reg 4.000000e+04 train accuracy: 0.368714 val accuracy: 0.372000
lr 2.000000e-07 reg 5.000000e+04 train accuracy: 0.361531 val accuracy: 0.364000
lr 2.000000e-07 reg 6.000000e+04 train accuracy: 0.354714 val accuracy: 0.368000
lr 2.000000e-07 reg 7.000000e+04 train accuracy: 0.348306 val accuracy: 0.365000
lr 2.000000e-07 reg 8.000000e+04 train accuracy: 0.358082 val accuracy: 0.378000
lr 2.000000e-07 reg 1.000000e+05 train accuracy: 0.347898 val accuracy: 0.358000
best validation accuracy achieved during cross-validation: 0.395000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize the cross-validation results</span></div><div class="line"><span class="keyword">import</span> math</div><div class="line">x_scatter = [math.log10(x[<span class="number">0</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> results]</div><div class="line">y_scatter = [math.log10(x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> results]</div><div class="line"></div><div class="line"><span class="comment"># plot training accuracy</span></div><div class="line">marker_size = <span class="number">100</span></div><div class="line">colors = [results[x][<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> results]</div><div class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">plt.scatter(x_scatter, y_scatter, marker_size, c=colors)</div><div class="line">plt.colorbar()</div><div class="line">plt.xlabel(<span class="string">'log learning rate'</span>)</div><div class="line">plt.ylabel(<span class="string">'log regularization strength'</span>)</div><div class="line">plt.title(<span class="string">'CIFAR-10 training accuracy'</span>)</div><div class="line"></div><div class="line"><span class="comment"># plot validation accuracy</span></div><div class="line">colors = [results[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> results] <span class="comment"># default size of markers is 20</span></div><div class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>)</div><div class="line">plt.scatter(x_scatter, y_scatter, marker_size, c=colors)</div><div class="line">plt.colorbar()</div><div class="line">plt.xlabel(<span class="string">'log learning rate'</span>)</div><div class="line">plt.ylabel(<span class="string">'log regularization strength'</span>)</div><div class="line">plt.title(<span class="string">'CIFAR-10 validation accuracy'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/accuracy.png" alt="accuracy"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Evaluate the best svm on test set</span></div><div class="line">y_test_pred = best_svm.predict(X_test)</div><div class="line">test_accuracy = np.mean(y_test == y_test_pred)</div><div class="line"><span class="keyword">print</span> <span class="string">'linear SVM on raw pixels final test set accuracy: %f'</span> % test_accuracy</div></pre></td></tr></table></figure><pre><code>linear SVM on raw pixels final test set accuracy: 0.383000
</code></pre><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = np.array([[[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>]]])</div><div class="line">np.squeeze(x)</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize the learned weights for each class.</span></div><div class="line"><span class="comment"># Depending on your choice of learning rate and regularization strength, these may</span></div><div class="line"><span class="comment"># or may not be nice to look at.</span></div><div class="line">w = best_svm.W[:<span class="number">-1</span>,:] <span class="comment"># strip out the bias</span></div><div class="line">w = w.reshape(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">10</span>)</div><div class="line">w_min, w_max = np.min(w), np.max(w)</div><div class="line">classes = [<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>, <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</div><div class="line">  plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i + <span class="number">1</span>)</div><div class="line">    </div><div class="line">  <span class="comment"># Rescale the weights to be between 0 and 255</span></div><div class="line">  wimg = <span class="number">255.0</span> * (w[:, :, :, i].squeeze() - w_min) / (w_max - w_min)</div><div class="line">  plt.imshow(wimg.astype(<span class="string">'uint8'</span>))</div><div class="line">  plt.axis(<span class="string">'off'</span>)</div><div class="line">  plt.title(classes[i])</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/weight.png" alt="weight"></p><h3 id="Inline-question-2"><a href="#Inline-question-2" class="headerlink" title="Inline question 2:"></a>Inline question 2:</h3><p>Describe what your visualized SVM weights look like, and offer a brief explanation for why they look they way that they do.</p><p><strong>Your answer:</strong> <em>fill this in</em></p><h1 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h1><h2 id="linear-svm-py"><a href="#linear-svm-py" class="headerlink" title="linear_svm.py"></a>linear_svm.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_loss_naive</span><span class="params">(W, X, y, reg)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Structured SVM loss function, naive implementation (with loops).</div><div class="line"></div><div class="line">    Inputs have dimension D, there are C classes, and we operate on minibatches</div><div class="line">    of N examples.</div><div class="line"></div><div class="line">    Inputs:</div><div class="line">    - W: A numpy array of shape (D, C) containing weights.</div><div class="line">    - X: A numpy array of shape (N, D) containing a minibatch of data.</div><div class="line">    - y: A numpy array of shape (N,) containing training labels; y[i] = c means</div><div class="line">      that X[i] has label c, where 0 &lt;= c &lt; C.</div><div class="line">    - reg: (float) regularization strength</div><div class="line"></div><div class="line">    Returns a tuple of:</div><div class="line">    - loss as single float</div><div class="line">    - gradient with respect to weights W; an array of same shape as W</div><div class="line">    """</div><div class="line">    dW = np.zeros(W.shape)  <span class="comment"># initialize the gradient as zero</span></div><div class="line"></div><div class="line">    <span class="comment"># compute the loss and the gradient</span></div><div class="line">    num_classes = W.shape[<span class="number">1</span>]</div><div class="line">    num_train = X.shape[<span class="number">0</span>]</div><div class="line">    loss = <span class="number">0.0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_train):</div><div class="line">        scores = X[i].dot(W)</div><div class="line">        correct_class_score = scores[y[i]]</div><div class="line"></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(num_classes):</div><div class="line">            <span class="keyword">if</span> j == y[i]:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            margin = scores[j] - correct_class_score + <span class="number">1</span>  <span class="comment"># note delta = 1</span></div><div class="line">            <span class="keyword">if</span> margin &gt; <span class="number">0</span>:</div><div class="line">                dW[:, y[i]] -= X[i, :]</div><div class="line">                dW[:, j] += X[i, :]</div><div class="line">                loss += margin</div><div class="line"></div><div class="line">    <span class="comment"># Right now the loss is a sum over all training examples, but we want it</span></div><div class="line">    <span class="comment"># to be an average instead so we divide by num_train.</span></div><div class="line">    loss /= num_train</div><div class="line"></div><div class="line">    dW /= num_train</div><div class="line"></div><div class="line">    <span class="comment"># Add regularization to the loss.</span></div><div class="line">    loss += <span class="number">0.5</span> * reg * np.sum(W * W)</div><div class="line">    dW += reg * W</div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span>                                                                     #</span></div><div class="line">    <span class="comment"># Compute the gradient of the loss function and store it dW.                #</span></div><div class="line">    <span class="comment"># Rather that first computing the loss and then computing the derivative,     #</span></div><div class="line">    <span class="comment"># it may be simpler to compute the derivative at the same time that the     #</span></div><div class="line">    <span class="comment"># loss is being computed. As a result you may need to modify some of the    #</span></div><div class="line">    <span class="comment"># code above to compute the gradient.                                       #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> loss, dW</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_loss_vectorized</span><span class="params">(W, X, y, reg)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Structured SVM loss function, vectorized implementation.</div><div class="line"></div><div class="line">    Inputs and outputs are the same as svm_loss_naive.</div><div class="line">    """</div><div class="line">    loss = <span class="number">0.0</span></div><div class="line">    dW = np.zeros(W.shape)  <span class="comment"># initialize the gradient as zero</span></div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span>                                                                     #</span></div><div class="line">    <span class="comment"># Implement a vectorized version of the structured SVM loss, storing the    #</span></div><div class="line">    <span class="comment"># result in loss.                                                           #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    num_train = X.shape[<span class="number">0</span>]</div><div class="line">    delta = <span class="number">1.0</span></div><div class="line"></div><div class="line">    scores = X.dot(W)</div><div class="line">    correct_class_score = scores[np.arange(num_train), y]</div><div class="line"></div><div class="line">    margins = np.maximum(</div><div class="line">        <span class="number">0</span>, scores - correct_class_score[:, np.newaxis] + delta)</div><div class="line">    margins[np.arange(num_train), y] = <span class="number">0</span></div><div class="line"></div><div class="line">    loss = np.sum(margins)</div><div class="line"></div><div class="line">    loss /= num_train</div><div class="line"></div><div class="line">    loss += <span class="number">0.5</span> * reg * np.sum(W.T.dot(W))</div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment">#                             END OF YOUR CODE                              #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span>                                                                     #</span></div><div class="line">    <span class="comment"># Implement a vectorized version of the gradient for the structured SVM     #</span></div><div class="line">    <span class="comment"># loss, storing the result in dW.                                           #</span></div><div class="line">    <span class="comment">#                                                                           #</span></div><div class="line">    <span class="comment"># Hint: Instead of computing the gradient from scratch, it may be easier    #</span></div><div class="line">    <span class="comment"># to reuse some of the intermediate values that you used to compute the     #</span></div><div class="line">    <span class="comment"># loss.                                                                     #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    X_mask = np.zeros(margins.shape)</div><div class="line">    X_mask[margins &gt; <span class="number">0</span>] = <span class="number">1</span></div><div class="line"></div><div class="line">    count = np.sum(X_mask, axis=<span class="number">1</span>)</div><div class="line">    X_mask[np.arange(num_train), y] = -count</div><div class="line"></div><div class="line">    dW = X.T.dot(X_mask)</div><div class="line"></div><div class="line">    dW /= num_train</div><div class="line"></div><div class="line">    dW += np.multiply(W, reg)</div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment">#                             END OF YOUR CODE                              #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> loss, dW</div></pre></td></tr></table></figure><h2 id="linear-classifier"><a href="#linear-classifier" class="headerlink" title="linear_classifier"></a>linear_classifier</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> cs231n.classifiers.linear_svm <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> cs231n.classifiers.softmax <span class="keyword">import</span> *</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearClassifier</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.W = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y, learning_rate=<span class="number">1e-3</span>, reg=<span class="number">1e-5</span>, num_iters=<span class="number">100</span>,</span></span></div><div class="line">              batch_size=<span class="number">200</span>, verbose=False):</div><div class="line">        <span class="string">"""</span></div><div class="line">        Train this linear classifier using stochastic gradient descent.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: A numpy array of shape (N, D) containing training data; there are N</div><div class="line">          training samples each of dimension D.</div><div class="line">        - y: A numpy array of shape (N,) containing training labels; y[i] = c</div><div class="line">          means that X[i] has label 0 &lt;= c &lt; C for C classes.</div><div class="line">        - learning_rate: (float) learning rate for optimization.</div><div class="line">        - reg: (float) regularization strength.</div><div class="line">        - num_iters: (integer) number of steps to take when optimizing</div><div class="line">        - batch_size: (integer) number of training examples to use at each step.</div><div class="line">        - verbose: (boolean) If true, print progress during optimization.</div><div class="line"></div><div class="line">        Outputs:</div><div class="line">        A list containing the value of the loss function at each training iteration.</div><div class="line">        """</div><div class="line">        num_train, dim = X.shape</div><div class="line">        num_classes = np.max(y) + <span class="number">1</span>  <span class="comment"># assume y takes values 0...K-1 where K is number of classes</span></div><div class="line">        <span class="keyword">if</span> self.W <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="comment"># lazily initialize W</span></div><div class="line">            self.W = <span class="number">0.001</span> * np.random.randn(dim, num_classes)</div><div class="line"></div><div class="line">        <span class="comment"># Run stochastic gradient descent to optimize W</span></div><div class="line">        loss_history = []</div><div class="line">        <span class="keyword">for</span> it <span class="keyword">in</span> xrange(num_iters):</div><div class="line">            X_batch = <span class="keyword">None</span></div><div class="line">            y_batch = <span class="keyword">None</span></div><div class="line"></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></div><div class="line">            <span class="comment"># Sample batch_size elements from the training data and their           #</span></div><div class="line">            <span class="comment"># corresponding labels to use in this round of gradient descent.        #</span></div><div class="line">            <span class="comment"># Store the data in X_batch and their corresponding labels in           #</span></div><div class="line">            <span class="comment"># y_batch; after sampling X_batch should have shape (dim, batch_size)   #</span></div><div class="line">            <span class="comment"># and y_batch should have shape (batch_size,)                           #</span></div><div class="line">            <span class="comment">#                                                                       #</span></div><div class="line">            <span class="comment"># Hint: Use np.random.choice to generate indices. Sampling with         #</span></div><div class="line">            <span class="comment"># replacement is faster than sampling without replacement.              #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            mask = np.random.choice(num_train, batch_size, replace=<span class="keyword">True</span>)</div><div class="line">            X_batch = X[mask]</div><div class="line">            y_batch = y[mask]</div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment">#                       END OF YOUR CODE                                #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line"></div><div class="line">            <span class="comment"># evaluate loss and gradient</span></div><div class="line">            loss, grad = self.loss(X_batch, y_batch, reg)</div><div class="line">            loss_history.append(loss)</div><div class="line"></div><div class="line">            <span class="comment"># perform parameter update</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></div><div class="line">            <span class="comment"># Update the weights using the gradient and the learning rate.          #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            self.W = self.W - learning_rate * grad</div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment">#                       END OF YOUR CODE                                #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> it % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'iteration %d / %d: loss %f'</span> % (it, num_iters, loss)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> loss_history</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Use the trained weights of this linear classifier to predict labels for</div><div class="line">        data points.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: D x N array of training data. Each column is a D-dimensional point.</div><div class="line"></div><div class="line">        Returns:</div><div class="line">        - y_pred: Predicted labels for the data in X. y_pred is a 1-dimensional</div><div class="line">          array of length N, and each element is an integer giving the predicted</div><div class="line">          class.</div><div class="line">        """</div><div class="line">        X = X.T</div><div class="line">        y_pred = np.zeros(X.shape[<span class="number">1</span>])</div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span>                                                                   #</span></div><div class="line">        <span class="comment"># Implement this method. Store the predicted labels in y_pred.            #</span></div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        scores = X.T.dot(self.W)</div><div class="line">        y_pred = np.argsort(scores, axis=<span class="number">1</span>)[:, <span class="number">-1</span>]</div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="comment">#                           END OF YOUR CODE                              #</span></div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="keyword">return</span> y_pred</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X_batch, y_batch, reg)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Compute the loss function and its derivative.</div><div class="line">        Subclasses will override this.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X_batch: A numpy array of shape (N, D) containing a minibatch of N</div><div class="line">          data points; each point has dimension D.</div><div class="line">        - y_batch: A numpy array of shape (N,) containing labels for the minibatch.</div><div class="line">        - reg: (float) regularization strength.</div><div class="line"></div><div class="line">        Returns: A tuple containing:</div><div class="line">        - loss as a single float</div><div class="line">        - gradient with respect to self.W; an array of the same shape as W</div><div class="line">        """</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearSVM</span><span class="params">(LinearClassifier)</span>:</span></div><div class="line">    <span class="string">""" A subclass that uses the Multiclass SVM loss function """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X_batch, y_batch, reg)</span>:</span></div><div class="line">        <span class="keyword">return</span> svm_loss_vectorized(self.W, X_batch, y_batch, reg)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Softmax</span><span class="params">(LinearClassifier)</span>:</span></div><div class="line">    <span class="string">""" A subclass that uses the Softmax + Cross-entropy loss function """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X_batch, y_batch, reg)</span>:</span></div><div class="line">        <span class="keyword">return</span> softmax_loss_vectorized(self.W, X_batch, y_batch, reg)</div></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/deep-learning/" rel="tag"># deep learning</a> <a href="/tags/machine-learning/" rel="tag"># machine learning</a> <a href="/tags/svm/" rel="tag"># svm</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/03/02/cs231n-Assignment-1-kNN/" rel="next" title="cs231n Assignment#1 kNN"><i class="fa fa-chevron-left"></i> cs231n Assignment#1 kNN</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/03/05/cs231n-Assignment-1-softmax/" rel="prev" title="cs231n Assignment#1 softmax">cs231n Assignment#1 softmax <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f731508143741d" async></script></div></div></div></div><div class="comments" id="comments"><div id="hypercomments_widget"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview">Overview</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Ewan Li"><p class="site-author-name" itemprop="name">Ewan Li</p><p class="site-description motion-element" itemprop="description">Ewan's IT Blog</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">129</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">64</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ewanlee" target="_blank" title="Github"><i class="fa fa-fw fa-globe"></i> Github </a></span><span class="links-of-author-item"><a href="https://twitter.com/tomaxent" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Multiclass-Support-Vector-Machine-exercise"><span class="nav-number">1.</span> <span class="nav-text">Multiclass Support Vector Machine exercise</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CIFAR-10-Data-Loading-and-Preprocessing"><span class="nav-number">1.1.</span> <span class="nav-text">CIFAR-10 Data Loading and Preprocessing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SVM-Classifier"><span class="nav-number">1.2.</span> <span class="nav-text">SVM Classifier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Inline-Question-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">Inline Question 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stochastic-Gradient-Descent"><span class="nav-number">1.2.2.</span> <span class="nav-text">Stochastic Gradient Descent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inline-question-2"><span class="nav-number">1.2.3.</span> <span class="nav-text">Inline question 2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Codes"><span class="nav-number">2.</span> <span class="nav-text">Codes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linear-svm-py"><span class="nav-number">2.1.</span> <span class="nav-text">linear_svm.py</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linear-classifier"><span class="nav-number">2.2.</span> <span class="nav-text">linear_classifier</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Ewan Li</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">Theme - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user">本站访客数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次</span> <span class="site-pv"><i class="fa fa-eye">本站总访问量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">_hcwp=window._hcwp||[],_hcwp.push({widget:"Bloggerstream",widget_id:89825,selector:".hc-comment-count",label:"{%COUNT%}"}),_hcwp.push({widget:"Stream",widget_id:89825,xid:"2017/03/03/cs231n-Assignment-1-svm/"}),function(){if(!("HC_LOAD_INIT"in window)){HC_LOAD_INIT=!0;var t=(navigator.language||navigator.systemLanguage||navigator.userLanguage||"en").substr(0,2).toLowerCase(),e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src=("https:"==document.location.protocol?"https":"http")+"://w.hypercomments.com/widget/hc/89825/"+t+"/widget.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n.nextSibling)}}()</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),n=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,n=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=n&&a.forEach(function(e,t){i=n.indexOf(e),l=s.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+n+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),n.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("e27VKX5tTklQLCtF7iNMmhcA-gzGzoHsz","nnQn2znNgXXEdK7W2bVJ3bfK")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html>