<!doctype html><html class="theme-next mist use-motion" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="reinforcement learning,"><link rel="alternate" href="/atom.xml" title="Abracadabra" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="译者注：本篇文章翻译自 Dr. Weng 的博客。翻译行为已得到原作者授权，转载请注明原作者。摘要：在本文中，我们将深入探讨策略梯度算法的工作原理以及近年来提出的一些新的策略梯度算法：平凡策略梯度、演员评论家算法、离线策略演员评论家算法、A3C、A2C、DPG、DDPG、D4PG、MADDPG、TRPO、PPO、ACER、ACKTR、SAC以及TD3算法。什么是策略梯度策略梯度算法是一类解决强化学"><meta property="og:type" content="article"><meta property="og:title" content="策略梯度方法"><meta property="og:url" content="http://yoursite.com/2019/04/14/策略梯度方法/index.html"><meta property="og:site_name" content="Abracadabra"><meta property="og:description" content="译者注：本篇文章翻译自 Dr. Weng 的博客。翻译行为已得到原作者授权，转载请注明原作者。摘要：在本文中，我们将深入探讨策略梯度算法的工作原理以及近年来提出的一些新的策略梯度算法：平凡策略梯度、演员评论家算法、离线策略演员评论家算法、A3C、A2C、DPG、DDPG、D4PG、MADDPG、TRPO、PPO、ACER、ACKTR、SAC以及TD3算法。什么是策略梯度策略梯度算法是一类解决强化学"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-593dfedad43dfce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-936d61bf7c84165f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-c2801505c52ccbf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-73d004524ff39cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-6620a93556a2d0e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-88808043234e89e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-b6a8d9fdca4d146d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13653853-bb3945372d7d7578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="og:updated_time" content="2019-04-14T06:00:01.347Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="策略梯度方法"><meta name="twitter:description" content="译者注：本篇文章翻译自 Dr. Weng 的博客。翻译行为已得到原作者授权，转载请注明原作者。摘要：在本文中，我们将深入探讨策略梯度算法的工作原理以及近年来提出的一些新的策略梯度算法：平凡策略梯度、演员评论家算法、离线策略演员评论家算法、A3C、A2C、DPG、DDPG、D4PG、MADDPG、TRPO、PPO、ACER、ACKTR、SAC以及TD3算法。什么是策略梯度策略梯度算法是一类解决强化学"><meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/13653853-593dfedad43dfce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2019/04/14/策略梯度方法/"><title>策略梯度方法 | Abracadabra</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?dc405a79ad500922134d14cdf288f646";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Abracadabra</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Do it yourself</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div><span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/策略梯度方法/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline">策略梯度方法</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-14T13:59:17+08:00">2019-04-14 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/04/14/策略梯度方法/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/04/14/策略梯度方法/" itemprop="commentsCount"></span> </a></span><span id="/2019/04/14/策略梯度方法/" class="leancloud_visitors" data-flag-title="策略梯度方法"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><hr><p><strong>译者注：</strong></p><p><strong>本篇文章翻译自 <a href="https://lilianweng.github.io/lil-log/contact.html" target="_blank" rel="external">Dr. Weng</a> 的<a href="https://lilianweng.github.io/lil-log/2018/04/08/policy-gradient-algorithms.html#sac-with-automatically-adjusted-temperature" target="_blank" rel="external">博客</a>。</strong></p><p><strong>翻译行为已得到原作者授权，转载请注明原作者。</strong></p><hr><blockquote><p>摘要：在本文中，我们将深入探讨策略梯度算法的工作原理以及近年来提出的一些新的策略梯度算法：平凡策略梯度、演员评论家算法、离线策略演员评论家算法、A3C、A2C、DPG、DDPG、D4PG、MADDPG、TRPO、PPO、ACER、ACKTR、SAC以及TD3算法。</p></blockquote><h2 id="什么是策略梯度"><a href="#什么是策略梯度" class="headerlink" title="什么是策略梯度"></a>什么是策略梯度</h2><p>策略梯度算法是一类解决强化学习问题的方法。如果你对于强化学习领域还不熟悉，请首先阅读<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#key-concepts" target="_blank" rel="external">这篇博客</a>来对强化学习的问题定义以及核心概念进行初步了解。</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>下面是一个符号列表，可以帮助您更轻松地理解本文中的公式。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>$s \in \mathcal{S}$</td><td>状态。</td></tr><tr><td>$a \in \mathcal{A}$</td><td>动作。</td></tr><tr><td>$r \in \mathcal{R}$</td><td>回报。</td></tr><tr><td>$S_{t}, A_{t}, R_{t}$</td><td>一个轨迹中第$t$个时间步对应的状态、动作以及回报。我可能会偶尔使用$s_{t}, a_{t}, r_{t}$来代替。</td></tr><tr><td>$\gamma$</td><td>折扣因子；用于惩罚未来回报中的不确定性；$0&lt;\gamma \leq 1$。</td></tr><tr><td>$G_{t}$</td><td>累积回报；或者说累积折扣回报；$G_{t}=\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1}$。</td></tr><tr><td>$P\left(s^{\prime}, r\vert s, a\right)$</td><td>在当前状态$s$下采取动作$a$后转移到下一个状态$s^{\prime}$并得到回报$r$的概率。</td></tr><tr><td>$\pi(a\vert s)$</td><td>随机策略（智能体行为逻辑）；$\pi_{\theta}( .)$代表由$\theta$参数化的策略。</td></tr><tr><td>$\mu(s)$</td><td>确定性策略；虽然也可以把确定性策略记为$\pi(s)$，但是采用一个不同的字母可以让我们更容易分辨一个策略到底是确定性的还是随机的。$\pi$或者$\mu$都是强化学习算法要学习的目标。</td></tr><tr><td>$V(s)$</td><td>状态-值函数衡量状态$s$的期望累积回报；$V_{w}( .)$代表由$w$参数化的状态-值函数。</td></tr><tr><td>$V^{\pi}(s)$</td><td>当智能体遵循策略$\pi$时状态$s$的期望累积回报；$V^{\pi}(s)=\mathbb{E}_{a \sim \pi}\left[G_{t}\vert S_{t}=s\right]$。</td></tr><tr><td>$Q(s, a)$</td><td>动作-值函数，与状态-值函数类似，但是它衡量在状态$s$下采取动作$a$后的期望累积回报；$Q_{w}( .)$代表由$w$参数化的动作-值函数。</td></tr><tr><td>$Q^{\pi}(s, a)$</td><td>与$V^{\pi}(s)$类似，当智能体遵循策略$\pi$时，在状态$s$下采取动作$a$后的期望累积回报；$Q^{\pi}(s, a)=\mathbb{E}_{a \sim \pi}\left[G_{t}\vert S_{t}=s,A_{t}=a\right]$。</td></tr><tr><td>$A(s, a)$</td><td>优势函数，$A(s, a)=Q(s, a)-V(s)$；可以认为优势函数是加强版本的动作-值函数，但是由于它采用状态-值函数作为基准使得它具有更小的方差。</td></tr></tbody></table><h3 id="策略梯度"><a href="#策略梯度" class="headerlink" title="策略梯度"></a>策略梯度</h3><p>强化学习的目标是为智能体找到一个最优的行为策略从而获取最大的回报。<strong>策略梯度</strong>方法主要特点在于直接对策略进行建模并优化。策略通常被建模为由$\theta$参数化的函数$\pi_{\theta}(a | s)$。回报（目标）函数的值受到该策略的直接影响，因而可以采用很多算法来对$\theta$进行优化来最大化回报（目标）函数。</p><p>回报（目标）函数定义如下：<br>$$<br>J(\theta)=\sum_{s \in \mathcal{S}} d^{\pi}(s) V^{\pi}(s)=\sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} \pi_{\theta}(a | s) Q^{\pi}(s, a)<br>$$<br>其中$d^{\pi}(s)$代表由$\pi_{\theta}$引出的马尔科夫链的平稳分布（$\pi$下的在线策略状态分布）。</p><hr><p><strong>译者注</strong>：上述目标函数是在连续环境（没有固定的终止状态）下的目标函数（被称为<strong>平均值</strong>），在连续环境下还有一种性质更好的目标函数，叫做<strong>平均回报</strong>：<br>$$<br>\begin{aligned} J(\theta) \doteq r(\pi) &amp; \doteq \lim _{h \rightarrow \infty} \frac{1}{h} \sum_{t=1}^{h} \mathbb{E}\left[R_{t} | S_{0}, A_{0 : t-1} \sim \pi\right] \\ &amp;=\lim _{t \rightarrow \infty} \mathbb{E}\left[R_{t} | S_{0}, A_{0 : t-1} \sim \pi\right] \\ &amp;=\sum_{s} \mu(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}, r} p\left(s^{\prime}, r | s, a\right) r \end{aligned}<br>$$<br>在这种定义下，<strong>（差分）累积回报定义为回报与平均回报的差值的累加值</strong>：<br>$$<br>G_{t} \doteq R_{t+1}-r(\pi)+R_{t+2}-r(\pi)+R_{t+3}-r(\pi)+\cdots<br>$$<br>对应的还有差分状态-值函数以及差分-动作值函数：<br>$$<br>\begin{array}{l}<br>{V_{\pi}(s)=\sum_{a} \pi_{\theta}(a | s) \sum_{r, s^{\prime}} p\left(s^{\prime}, r | s, a\right)\left[r-r(\pi)+V_{\pi}\left(s^{\prime}\right)\right]} \\ {Q_{\pi}(s, a)=\sum_{r, s^{\prime}} p\left(s^{\prime}, r | s, a\right)\left[r-r(\pi)+\sum_{a^{\prime}} \pi_{\theta}\left(a^{\prime} | s^{\prime}\right) Q_{\pi}\left(s^{\prime}, a^{\prime}\right)\right]}\end{array}<br>$$<br>之所以说上述目标函数性质更好，是因为平均值目标函数其实只是它的另外一种形式，下面我们就来证明一下（<a href="http://incompleteideas.net/book/bookdraft2017nov5.pdf" target="_blank" rel="external">Sutton&amp;Barto,2017</a>; Sec 10.4）：<br>$$<br>\begin{aligned}<br>J(\theta)=&amp;\sum_{s \in \mathcal{S}} d^{\pi}(s) V^{\pi}(s) \\<br>=&amp; \sum_{s} d_{\pi}(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right)\left[r+\gamma V_{\pi}\left(s^{\prime}\right)\right] \\<br>=&amp;\;r(\pi) + \sum_{s} d_{\pi}(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right)\gamma V_{\pi}\left(s^{\prime}\right) \\<br>=&amp;\;r(\pi) + \gamma \sum_{s^{\prime}} V_{\pi}\left(s^{\prime}\right) \sum_{s} d_{\pi}(s) \sum_{a} \pi_{\theta}(a | s) p\left(s^{\prime} | s, a\right) \\<br>=&amp;\;r(\pi) + \gamma\sum_{s^{\prime}}V_{\pi}(s^{\prime})d_{\pi}(s^{\prime}) \\<br>=&amp;\;r(\pi) + \gamma J(\theta) \\<br>=&amp;\;r(\pi) + \gamma r(\pi) + \gamma^{2}J(\theta) \\<br>=&amp;\;r(\pi) + \gamma r(\pi) + \gamma^{2}r(\pi) + \gamma^{3}J(\theta) + \cdots \\<br>=&amp;\;\frac{1}{1-\gamma}r(\pi)<br>\end{aligned}<br>$$<br><strong>因而在下面进行策略梯度定理证明时，我们仅考虑平均回报形式的目标函数。</strong></p><p>另一方面，在周期环境下的目标函数（<strong>不包含折扣因子</strong>）如下：<br>$$<br>J(\theta)=V^{\pi}(s_{0})<br>$$<br>之所以不在连续环境下也使用上述目标函数，是因为在连续环境下上述目标函数的值为无穷大，优化一个无穷大值是没有意义的。</p><hr><p>为了简化符号，当策略作为其他函数的上标或者下标出现时$\pi_{\theta}$中的参数$\theta$将省略，例如：$d^{\pi}$以及$Q^{\pi}$的完整形式为$d^{\pi_{\theta}}$以及$Q^{\pi_{\theta}}$。想象一下你一直在马尔科夫链构成的状态序列中游荡，随着时间不断向前推进，你经过某个状态的概率将保持不变——这个概率就是$\pi_{\theta}$下的平稳概率。$d^{\pi}(s)=\lim _{t \rightarrow \infty} P\left(s_{t}=s | s_{0}, \pi_{\theta}\right)$就表示你从状态$s_0$开始，在策略$\pi_{\theta}$下经过$t$个时间步后到达状态$s$的概率。实际上，PageRank正是利用了马尔科夫链的平稳分布。你可以阅读<a href="https://jeremykun.com/2015/04/06/markov-chain-monte-carlo-without-all-the-bullshit/" target="_blank" rel="external">这篇文章</a>以获取更多细节。</p><p>我们可以很自然的预见到基于策略的方法能够很好地处理连续空间中的强化学习问题。因为在连续空间中存在无限多的动作及（或）状态因而基于值函数的算法由于需要去估计所有的动作及（或）状态的值导致其所需的算力变得无法接受。例如，在<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#policy-iteration" target="_blank" rel="external">一般的策略迭代</a>过程中，策略提升步骤$\arg \max _{a \in \mathcal{A}} Q^{\pi}(s, a)$需要去遍历整个动作空间，因而会遭受<a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_blank" rel="external">维度诅咒</a>。</p><p>使用<em>梯度上升</em>方法，我们可以将参数$\theta$往梯度$\nabla_{\theta} J(\theta)$给出的方向进行改变从而去找到最优的$\theta$使得其对应的策略$\pi_{\theta}$能够给智能体带来最大的期望累积回报。</p><h3 id="策略梯度定理"><a href="#策略梯度定理" class="headerlink" title="策略梯度定理"></a>策略梯度定理</h3><p>计算梯度$\nabla_{\theta} J(\theta)$可不是一件简单的事情。因为梯度值不仅依赖于动作的选择（由$\pi_{\theta}$直接决定），还依赖于由选择的动作而产生的状态的平稳分布（由$\pi_{\theta}$间接决定）。鉴于环境通常是未知的，很难去估计策略的更新对于状态分布造成的影响。</p><p>哇哦！这时候出现了策略梯度定理来拯救世界了！该定理对梯度的形式进行了变形使其不依赖于状态分布$d^{\pi}( .)$的导数，从而在很大程度上简化了梯度$\nabla_{\theta} J(\theta)$的计算：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;=\nabla_{\theta} \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s) \\<br>&amp;\propto \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a \vert s) \end{aligned}<br>$$</p><hr><p><strong>译者注：</strong>这里策略梯度定理的形式不够完全，只考虑了目标函数为连续环境下的平均值形式，上述定理还同时适用于连续环境下的平均回报形式目标函数以及周期环境下的目标函数，即：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;\stackrel{\text{def}}{=} \nabla_{\theta} \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s) &amp; \scriptstyle{\text{连续环境下的平均值形式目标函数}} \\<br>&amp;\stackrel{\text{def}}{=} \nabla_{\theta} \sum_{s\in\mathcal{S}} \mu(s) \sum_{a\in\mathcal{A}} \pi_{\theta}(a | s) \sum_{s^{\prime}\in\mathcal{S}, r} p\left(s^{\prime}, r | s, a\right) r &amp; \scriptstyle{\text{连续环境下的平均回报形式目标函数}}\\<br>&amp;\stackrel{\text{def}}{=} \nabla_{\theta} V^{\pi}(s_{0}) &amp; \scriptstyle{\text{周期环境下的目标函数}}\\<br>&amp; \propto \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a | s) &amp; \scriptstyle{}<br>\end{aligned}<br>$$</p><hr><h3 id="策略梯度定理的证明"><a href="#策略梯度定理的证明" class="headerlink" title="策略梯度定理的证明"></a>策略梯度定理的证明</h3><p>现在我们要深入上述定理的证明（<a href="http://incompleteideas.net/book/bookdraft2017nov5.pdf" target="_blank" rel="external">Sutton&amp;Barto,2017</a>; Sec 13.1（<strong>译者注：这里应该更改为Sec 13.2</strong>））从而理解为什么该定理的正确的，因而这部分会包含很多的数学公式。</p><p>我们首先从计算状态-值函数的梯度开始：<br>$$<br>\begin{aligned}<br>&amp; \nabla_\theta V^\pi(s) \\<br>=&amp; \nabla_\theta \Big(\sum_{a \in \mathcal{A}} \pi_\theta(a \vert s)Q^\pi(s, a) \Big) &amp; \\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\nabla_\theta Q^\pi(s, a)} \Big) &amp; \scriptstyle{\text{; 微分乘法法则}} \\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\nabla_\theta \sum_{s’, r} P(s’,r \vert s,a)(r + V^\pi(s’))} \Big) &amp; \scriptstyle{\text{; 扩展} Q^\pi} \\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\sum_{s’, r} P(s’,r \vert s,a) \nabla_\theta V^\pi(s’)} \Big) &amp; \scriptstyle{; P(s’,r \vert s,a) \text{或者} r \text{不是}\theta \text{的函数}}\\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\sum_{s’} P(s’ \vert s,a) \nabla_\theta V^\pi(s’)} \Big) &amp; \scriptstyle{\text{; 因为 } P(s’ \vert s, a) = \sum_r P(s’, r \vert s, a)}<br>\end{aligned}<br>$$</p><p>现在我们有：<br>$$<br>{\color{red}{\nabla_\theta V^\pi(s)}}<br>= \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \sum_{s’} P(s’ \vert s,a) \color{red}{\nabla_\theta V^\pi(s’)} \Big)<br>$$<br>上述等式拥有很好的递归特性（红色部分）因而未来状态的状态-值函数$V^{\pi}\left(s^{\prime}\right)$可以根据上式来递归地展开。让我们考虑一个下面这样的状态访问序列并将从状态$s$开始在策略$\pi_{\theta}$下经过$k$个时间步到达状态$x$的概率记为$\rho^{\pi}(s \rightarrow x, k)$：<br>$$<br>s \xrightarrow[]{a \sim \pi_\theta(.\vert s)} s’ \xrightarrow[]{a \sim \pi_\theta(.\vert s’)} s’’ \xrightarrow[]{a \sim \pi_\theta(.\vert s’’)} \dots<br>$$</p><p>对于不同的$k$值，$\rho^{\pi}(s \rightarrow x, k) $值包含以下几种情况：</p><ul><li>当$k=0$时：$\rho^{\pi}(s \rightarrow s, k=0)=1$。</li><li>当$k=1$时，我们遍历在状态$s$下所有可能的动作$a$然后将所有从元组$(s,a)$转移到目标状态的概率累加：$\rho^{\pi}\left(s \rightarrow s^{\prime}, k=1\right)=\sum_{a} \pi_{\theta}(a | s) P\left(s^{\prime} | s, a\right)$。</li><li>设想以下我们的目标是从状态$s$开始依照策略$\pi_{\theta} $经过$k+1$个时间步最终达到目标状态$x$。为了实现这个目标，我们可以先从状态$s$开始经过$k$个时间步后达到某个中间状态$s^{\prime} $（任何一个状态$s\in\mathcal{S}$均可成为中间状态）然后经过最后一个时间步到达目标状态$x$。这样的话，我们就可以递归地计算访问概率：$\rho^{\pi}(s \rightarrow x, k+1)=\sum_{s^{\prime}} \rho^{\pi}\left(s \rightarrow s^{\prime}, k\right) \rho^{\pi}\left(s^{\prime} \rightarrow x, 1\right)$。</li></ul><p>有了以上的相关基础，我们就可以递归地展开$\nabla_\theta V^\pi(s)$！首先为了简化符号我们进行以下符号上的替换：$\phi(s)=\sum_{a \in \mathcal{A}} \nabla_{\theta} \pi_{\theta}(a | s) Q^{\pi}(s, a)$。如果我们不停地展开$\nabla_{\theta} V^{\pi}(\cdot)$，那么可以发现通过这个展开过程我们可以从状态$s$开始经过任意时间步后到达任意的状态，并且将上述过程中的访问概率累加起来就可以得到$\nabla_\theta V^\pi(s)$！<br>$$<br>\begin{aligned}<br>&amp; \color{red}{\nabla_\theta V^\pi(s)} \\<br>=&amp; \phi(s) + \sum_a \pi_\theta(a \vert s) \sum_{s’} P(s’ \vert s,a) \color{red}{\nabla_\theta V^\pi(s’)} \\<br>=&amp; \phi(s) + \sum_{s’} \sum_a \pi_\theta(a \vert s) P(s’ \vert s,a) \color{red}{\nabla_\theta V^\pi(s’)} \\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \color{red}{\nabla_\theta V^\pi(s’)} \\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \color{red}{[ \phi(s’) + \sum_{s’’} \rho^\pi(s’ \to s’’, 1) \nabla_\theta V^\pi(s’’)]} \\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \phi(s’) + \sum_{s’’} \rho^\pi(s \to s’’, 2){\color{red}{\nabla_\theta V^\pi(s’’)}} \scriptstyle{\text{ ; 考虑将 }s’\text{ 作为 }s \to s’’}\text{的中间状态}\\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \phi(s’) + \sum_{s’’} \rho^\pi(s \to s’’, 2)\phi(s’’) + \sum_{s’’’} \rho^\pi(s \to s’’’, 3)\color{red}{\nabla_\theta V^\pi(s’’’)} \\<br>=&amp; \dots \scriptstyle{\text{; 递归展开 }\nabla_\theta V^\pi(.)} \\<br>=&amp; \sum_{x\in\mathcal{S}}\sum_{k=0}^\infty \rho^\pi(s \to x, k) \phi(x)<br>\end{aligned}上述<br>$$</p><p>上述变形使得我们无需计算Q-值函数的梯度$\nabla_\theta Q^\pi(s, a)$。将其带入目标函数$J(\theta)$中，可得：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;= \nabla_\theta V^\pi(s_0) &amp; \scriptstyle{\text{; 从一个随机状态 } s_0 \text{开始}} \\<br>&amp;= \sum_{s}\color{blue}{\sum_{k=0}^\infty \rho^\pi(s_0 \to s, k)} \phi(s) &amp;\scriptstyle{\text{; 令 }\color{blue}{\eta(s) = \sum_{k=0}^\infty \rho^\pi(s_0 \to s, k)}} \\<br>&amp;= \sum_{s}\eta(s) \phi(s) &amp; \\<br>&amp;= \Big( {\sum_s \eta(s)} \Big)\sum_{s}\frac{\eta(s)}{\sum_s \eta(s)} \phi(s) &amp; \scriptstyle{\text{; 正则化 } \eta(s), s\in\mathcal{S} \text{ 使其成为一个概率分布}}\\<br>&amp;\propto \sum_s \frac{\eta(s)}{\sum_s \eta(s)} \phi(s) &amp; \scriptstyle{\sum_s \eta(s)\text{ 是一个常数}} \\<br>&amp;= \sum_s d^\pi(s) \sum_a \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) &amp; \scriptstyle{d^\pi(s) = \frac{\eta(s)}{\sum_s \eta(s)}\text{ 即为平稳分布}}<br>\end{aligned}<br>$$</p><hr><p>译者注：上述证明过程仅仅涉及周期环境，连续环境下的证明如下：<br>$$<br>\begin{aligned}<br>&amp; \nabla_\theta V^\pi(s) \\<br>=&amp; \nabla_\theta \Big(\sum_{a \in \mathcal{A}} \pi_\theta(a \vert s)Q^\pi(s, a) \Big) &amp; \\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\nabla_\theta Q^\pi(s, a)}} \Big) &amp; \scriptstyle{\text{; 微分乘法法则}} \\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\nabla_\theta \sum_{s’, r} P(s’,r \vert s,a)(r - r(\pi) + V^\pi(s’))}}\Big) &amp; \scriptstyle{\text{; 扩展} Q^\pi} \\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s){\color{red}{\bigg[{\color{blue}{-\nabla_{\theta}r(\pi)}}+\sum_{s’, r} P(s’,r \vert s,a) \nabla_\theta V^\pi(s’)} \bigg]}\Big) &amp; \scriptstyle{; P(s’,r \vert s,a) \text{或者} r \text{不是}\theta \text{的函数}}\\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\bigg[{\color{blue}{-\nabla_{\theta}r(\pi)}}+\sum_{s’} P(s’ \vert s,a) \nabla_\theta V^\pi(s’)} \bigg]}\Big) &amp; \scriptstyle{\text{; 因为 } P(s’ \vert s, a) = \sum_r P(s’, r \vert s, a)} \\<br>=&amp; {\color{blue}{-\nabla_{\theta}r(\pi)}} + \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\sum_{s’} P(s’ \vert s,a) \nabla_\theta V^\pi(s’)}}\Big)<br>\end{aligned}<br>$$</p><p>经过移项可得：<br>$$<br>\color{blue} {\nabla_{\theta}r(\pi)} =\phi(s) + \sum_{a}\left[\pi_{\theta}(a | s) \color{red} {\sum_{s^{\prime}} p\left(s^{\prime} | s, a\right) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)} \right]-\nabla_{\theta} V^{\pi}(s)<br>$$<br>那么平均回报形式的目标函数的梯度有：<br>$$<br>\begin{aligned}<br>\nabla_{\theta}J(\theta) =&amp;\;\nabla_{\theta} r(\pi) \\<br>=&amp; \sum_{s} d^{\pi}(s)\left(\phi(s) + \sum_{a}\left[\pi_{\theta}(a | s) \sum_{s^{\prime}} p\left(s^{\prime} | s, a\right) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)\right]-\nabla_{\theta} V^{\pi}(s)\right) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) +\sum_{s} d^{\pi}(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}} p\left(s^{\prime} | s, a\right) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)-\sum_{s} d^{\pi}(s) \nabla_{\theta} V^{\pi}(s) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) + \sum_{s^{\prime}} \underbrace{\sum_{s} d^{\pi}(s) \sum_{a} \pi_{\theta}(a|s) p\left(s^{\prime}|s,a\right)}_{d^{\pi}\left(s^{\prime}\right)} \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)-\sum_{s} d^{\pi}(s) \nabla_{\theta} V^{\pi}(s) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) + \sum_{s^{\prime}} d^{\pi}(s^{\prime}) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)-\sum_{s} d^{\pi}(s) \nabla_{\theta} V^{\pi}(s) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) \\<br>=&amp; \sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta\pi_\theta(a \vert s) \\<br>\propto&amp; \sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta \pi_\theta(a \vert s)<br>\end{aligned}<br>$$<br>其中第二个等式成立是因为$\nabla_{\theta}r(\pi)$不依赖$s$且$\sum_{s}d^{\pi}(s)=1$。</p><p>另外，平均值形式的目标函数的梯度有：<br>$$<br>\begin{aligned}<br>\nabla_{\theta}J(\theta) =&amp;\;\nabla_{\theta}\sum_{s \in \mathcal{S}} d^{\pi}(s) V^{\pi}(s) \\<br>=&amp;\;\nabla_{\theta} \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s)\\<br>=&amp;\;\frac{1}{1-\gamma}\nabla_{\theta} r(\pi) \\<br>=&amp;\;\frac{1}{1-\gamma}\left(\sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta\pi_\theta(a \vert s)\right) \\<br>\propto&amp; \sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta \pi_\theta(a \vert s)<br>\end{aligned}<br>$$</p><hr><p>梯度还可以改写为如下形式：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;\propto \sum_{s \in \mathcal{S}} d^\pi(s) \sum_{a \in \mathcal{A}} Q^\pi(s, a) \nabla_\theta \pi_\theta(a \vert s) &amp;\\<br>&amp;= \sum_{s \in \mathcal{S}} d^\pi(s) \sum_{a \in \mathcal{A}} \pi_\theta(a \vert s) Q^\pi(s, a) \frac{\nabla_\theta \pi_\theta(a \vert s)}{\pi_\theta(a \vert s)} &amp;\\<br>&amp;= \mathbb{E}_\pi [Q^\pi(s, a) \nabla_\theta \ln \pi_\theta(a \vert s)] &amp; \scriptstyle{\text{; 因为 } (\ln x)’ = 1/x}<br>\end{aligned}<br>$$<br>$\mathbb{E}_{\pi}$代表$\mathbb{E}_{s \sim d_{\pi}, a \sim \pi_{\theta}}$，下标表示遵循策略$\pi_{\theta}$（在线策略）时状态以及动作的分布。</p><p>上述策略梯度定理是许多策略梯度算法的理论基础。平凡策略梯度算法由于直接使用采样得到的回报所以其估计的梯度不存在偏差（bias）但是有较大的方差（variance）（见下式）。因此后续的算法被相继提出用以在保持偏差有界的情况下减小方差。<br>$$<br>\nabla_{\theta} J(\theta)=\mathbb{E}_{\pi}\left[Q^{\pi}(s, a) \nabla_{\theta} \ln \pi_{\theta}(a | s)\right]<br>$$<br>这里有一个从GAE（泛化优势估计，genaral advantage estimate）论文 （<a href="https://arxiv.org/abs/1506.02438" target="_blank" rel="external">Schulman et al., 2016</a>）中引用的很好的策略梯度算法一般形式的归纳，并且<a href="https://danieltakeshi.github.io/2017/04/02/notes-on-the-generalized-advantage-estimation-paper/" target="_blank" rel="external">这篇博客</a>深入探讨了GAE的几大组成部分，值得一读。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-593dfedad43dfce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1. 策略梯度方法的一般形式。图片来源：[Schulman et al., 2016](https://arxiv.org/abs/1506.02438)"></p><h2 id="策略梯度算法"><a href="#策略梯度算法" class="headerlink" title="策略梯度算法"></a>策略梯度算法</h2><p>今年来强化学习领域内提出了大量的策略梯度算法，我不可能罗列出所有的算法。因此在这里我仅仅列举出一些我恰巧了解的算法。</p><h3 id="REINFORCE"><a href="#REINFORCE" class="headerlink" title="REINFORCE"></a>REINFORCE</h3><p>REINFORCE（蒙特卡洛策略梯度）依靠使用<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#monte-carlo-methods" target="_blank" rel="external">蒙特卡洛</a>方法从采样出的轨迹样本得到的估计的累积回报来更新策略的参数$\theta $。REINFORCE算法能够起效的原因是因为采样的梯度的期望值是真实梯度的无偏估计：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;= \mathbb{E}_\pi [Q^\pi(s, a) \nabla_\theta \ln \pi_\theta(a \vert s)] &amp; \\<br>&amp;= \mathbb{E}_\pi [G_t \nabla_{\theta} \ln \pi_\theta(A_t \vert S_t)] &amp; \scriptstyle{\text{; 因为 } Q^\pi(S_t, A_t) = \mathbb{E}_\pi[G_t \vert S_t, A_t]}<br>\end{aligned}<br>$$<br>因此我们能够从真实的采样轨迹中计算$G_t$并且使用它来去更新我们的策略梯度。它依赖于一条完整的轨迹，这也是为什么被叫做蒙特卡洛方法的原因。</p><p>整个算法流程十分直接：</p><ol><li>随机初始化策略参数$\theta $</li><li>使用当前策略$\pi_{\theta} $产生一条完整的轨迹：$S_{1}, A_{1}, R_{2}, S_{2}, A_{2}, \dots, S_{T}$</li><li>对于每个时间步$\mathrm{t}=1,2, \ldots, \mathrm{T}$：<ol><li>估计累积回报$G_t$</li><li>更新参数：$\theta \leftarrow \theta+\alpha \gamma^{t} G_{t} \nabla_{\theta} \ln \pi_{\theta}\left(A_{t} | S_{t}\right)$</li></ol></li></ol><p>一个被广泛应用的REINFORCE算法的变种是从$G_t$中减去一个基准值用来<em>在保证偏差不变的情况下减小估计梯度时产生的方差</em>（我们总是希望尽可能这样做）。举个例子，一个被广泛使用的基准值是状态-值，如果我们应用状态-值作为基准，那么我们实际在估计梯度进行梯度上升来更新参数的过程中使用的是优势值：$A(s, a)=Q(s, a)-V(s)$。<a href="https://danieltakeshi.github.io/2017/03/28/going-deeper-into-reinforcement-learning-fundamentals-of-policy-gradients/" target="_blank" rel="external">这篇博客</a>不仅仅很好地解释了为什么采用基准值会减小方差，而且还详细讲解了策略梯度的一些基础知识。</p><h3 id="演员-评论家算法（Actor-Critic）"><a href="#演员-评论家算法（Actor-Critic）" class="headerlink" title="演员-评论家算法（Actor-Critic）"></a>演员-评论家算法（Actor-Critic）</h3><p>策略梯度算法主要包括策略模型以及值函数两个部分。在学习策略的基础上额外学习值函数是有很大意义的，因为值函数可以辅助策略更新，例如在平凡策略梯度算法中利用值函数来进行方差缩减，而这也是演员-评论家算法在做的事情。</p><p>演员-评论家模型由两个模型组成，可以选择是否共享参数：</p><ul><li><strong>评论家</strong>更新值函数的参数$w$并且根据算法的不同值函数可以为动作-值$Q_{w}(a | s)$或者状态-值$V_{w}(s)$</li><li><strong>演员</strong>根据评论家建议的方向更新策略$\pi_{\theta}(a | s)$参数$\theta $</li></ul><p>下面让我们看看一个简单的动作-值演员-评论家算法：</p><ol><li>随机初始化$s, w, \theta$；从初始策略中采样$a \sim \pi_{\theta}(a | s)$</li><li>对于每个时间步$t=1 \ldots T :$<ol><li>采样回报$r_{t} \sim R(s, a)$以及下一个状态$s^{\prime} \sim P\left(s^{\prime} | s, a\right)$</li><li>采样下一个动作$a^{\prime} \sim \pi_{\theta}\left(a^{\prime} | s^{\prime}\right)$</li><li>更新策略参数：$\theta \leftarrow \theta+\alpha_{\theta} Q_{w}(s, a) \nabla_{\theta} \ln \pi_{\theta}(a | s)$</li><li>对于当前时间步的动作-值计算校正值（TD误差）：$\delta_{t}=r_{t}+\gamma Q_{w}\left(s^{\prime}, a^{\prime}\right)-Q_{w}(s, a)$并且使用它来更新动作-值函数的参数：$w \leftarrow w+\alpha_{w} \delta_{t} \nabla_{w} Q_{w}(s, a)$</li><li>更新当前动作$a \leftarrow a^{\prime}$以及状态$s \leftarrow s^{\prime}$</li></ol></li></ol><p>$\alpha_w$和$\alpha_{\theta}$是两个预先定义的分别用来更新策略以及值函数的学习率。</p><h3 id="离线策略梯度（Off-Policy-Policy-Gradient）"><a href="#离线策略梯度（Off-Policy-Policy-Gradient）" class="headerlink" title="离线策略梯度（Off-Policy Policy Gradient）"></a>离线策略梯度（Off-Policy Policy Gradient）</h3><p>REINFORCE算法以及上述简单版本的演员-评论家算法都是在线（on-policy）的：训练样本是通过目标策略（target policy）——我们想要去优化的策略——收集的。然而离线方法拥有以下额外的优势：</p><ol><li>离线方法不需要完整的轨迹样本并且可以复用任何历史轨迹的样本（<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#deep-q-network" target="_blank" rel="external">“经验回放”</a>）从而具有更好的样本有效性。</li><li>训练样本根据行为策略（behavior policy）而不是目标策略收集而来，给算法带来更好的<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#exploration-exploitation-dilemma" target="_blank" rel="external">探索性</a>。</li></ol><p>现在让我们来看看离线策略梯度是如何计算的。用来收集训练样本的行为策略是一个已知的策略（类似一个预先定义好的超参数），我们把它记作$\beta(a | s)$。那么目标函数（这里我们采用的是平均值形式的目标函数，其他形式的目标函数可以导出相同的结果）为由此行为策略导出的平稳状态分布下的回报的加和：</p><p>$$<br>J(\theta)=\sum_{s \in \mathcal{S}} d^{\beta}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s)=\mathbb{E}_{s \sim d^{\beta}}\left[\sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s)\right],<br>$$<br>其中$d^{\beta}(s)$为行为策略$\beta$导出的平稳分布，$d^{\beta}(s)=\lim _{t \rightarrow \infty} P\left(S_{t}=s | S_{0}, \beta\right)$。$Q^{\pi}$为根据目标策略$\pi$（不是行为策略！）估计的动作-值函数。</p><p>给定根据行为策略采样得到的动作$a \sim \beta(a | s)$产生的训练样本，我们可以将策略梯度改写为如下形式：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;= \nabla_{\theta} \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a \vert s) \Big] &amp; \\<br>&amp;= \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} \big( Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a \vert s) + \color{red}{\pi_{\theta}(a \vert s) \nabla_{\theta} Q^{\pi}(s, a)} \big) \Big] &amp; \scriptstyle{\text{; 微分乘法法则.}}\\<br>&amp;\stackrel{(i)}{\approx} \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a \vert s) \Big] &amp; \scriptstyle{\text{; 忽略红色部分: } \color{red}{\pi_{\theta}(a \vert s) \nabla_{\theta} Q^{\pi}(s, a)}}. \\<br>&amp;= \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} \beta (a \vert s) \frac{\pi_{\theta}(a \vert s)}{\beta (a \vert s)} Q^{\pi}(s, a) \frac{\nabla_{\theta} \pi_{\theta}(a \vert s)}{\pi_{\theta}(a \vert s)} \Big] &amp; \\<br>&amp;= \mathbb{E}_\beta \Big[\frac{\color{blue}{\pi_{\theta}(a \vert s)}}{\color{blue}{\beta (a \vert s)}} Q^{\pi}(s, a) \nabla_{\theta} \ln \pi_{\theta}(a \vert s) \Big], &amp; \scriptstyle{\text{; 蓝色部分成为重要性权重.}}<br>\end{aligned}<br>$$<br>其中$\frac{\pi_{\theta}(a | s)}{\beta(a | s)}$为<a href="http://timvieira.github.io/blog/post/2014/12/21/importance-sampling/" target="_blank" rel="external">重要性权重(importance weight)</a>。由于$Q^{\pi}$是目标策略的函数因而也就是策略参数$\theta$的参数，因而根据微分乘法法则我们需要计算梯度$\nabla_{\theta} Q^{\pi}(s, a)$。然而在现实问题中计算$\nabla_{\theta} Q^{\pi}(s, a)$是一件超级困难的事情。幸运的是如果我们直接忽略掉$Q$的梯度而去使用一个近似的策略梯度的话，依旧能够保证采用梯度上升算法能够使得策略性能提升并且最终收敛到一个真实的局部最优解。上述结论的具体证明过程请参阅<a href="https://arxiv.org/pdf/1205.4839.pdf" target="_blank" rel="external">这篇论文</a>（Degris, White &amp; Sutton, 2012）。</p><p>总而言之，当我们想在离线环境下应用策略梯度时，只需通过加权求和的方式对其进行简单的修改，权重为目标策略与行为策略的比值。</p><h3 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h3><p>[<a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">论文</a>|<a href="https://github.com/dennybritz/reinforcement-learning/tree/master/PolicyGradient/a3c" target="_blank" rel="external">代码</a>]</p><p>异步优势演员-评论家方法（<strong>Asynchronous Advantage Actor-Critic</strong>）（<a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">Mnih et al., 2016</a>），简写为<strong>A3C</strong>时一种经典的策略梯度方法，尤其注重并行训练。</p><p>在A3C中，评论家学习值函数，同时有多个演员并行训练并且不时与全局参数同步。因而，A3C旨在用于并行训练。</p><p>让我们用状态-值函数进行举例。状态值的损失函数是最小化均方误差 $J_{v}(w)=\left(G_{t}-V_{w}(s)\right)^{2}$，因而采用梯度下降方法可以找到最优参数$w$。状态-值函数用来在策略梯度更新中作为基准值。</p><p>下面是算法大纲：</p><ol><li>定义全局参数 $\theta$ 和 $w$ 以及特定线程参数 $\theta^{\prime}$ 和 $w^{\prime}$。</li><li>初始化时间步 $t=1$。</li><li><p>当 $T&lt;=T_{\mathrm{max}}$：</p><ol><li><p>重置梯度：$\mathrm{d} \theta=0$ 并且 $\mathrm{d} \mathrm{w}=0$。</p></li><li><p>将特定于线程的参数与全局参数同步：$\theta^{\prime}=\theta$ 以及 $w^{\prime}=w$。</p></li><li><p>令 $t_{\text {start }}=t$ 并且随机采样一个初始状态 $s_t$。</p></li><li><p>当 （$s_{t} !=$ 终止状态）并且 $t-t_{\text {start}}&lt;=t_{\text {max}}$：</p><ol><li>根据当前线程的策略选择当前执行的动作 $a_{t} \sim \pi_{\theta^{\prime}}\left(a_{t} | s_{t}\right)$，执行动作后接收回报$r_t$然后转移到下一个状态$s_{t+1}$。</li><li>更新 $t$ 以及 $T$：$t=t+1$ 并且 $T=T+1$。</li></ol></li><li><p>初始化保存累积回报估计值的变量：$r=\left\{\begin{array}{ll}{0} &amp; {\text { 如果 } s_{t} \text { 是终止状态}} \\ {V_{w^{\prime}}\left(s_{t}\right)} &amp; {\text { 否则}}\end{array}\right.$</p></li><li><p>对于 $i=t-1, \dots, t_{\text {start}}$：</p><ol><li><p>$r \leftarrow \gamma r+r_{i}$；这里 $r$ 是 $G_i$ 的蒙特卡洛估计。</p></li><li><p>累积关于参数 $\theta^{\prime}$ 的梯度：$d \theta \leftarrow d \theta+\nabla_{\theta^{\prime}} \log \pi_{\theta^{\prime}}\left(a_{i} | s_{i}\right)\left(r-V_{w^{\prime}}\left(s_{i}\right)\right)$；</p><p>累积关于参数 $w^{\prime}$ 的梯度：$d w \leftarrow d w+2\left(r-V_{w^{\prime}}\left(s_{i}\right)\right) \nabla_{w^{\prime}}\left(r-V_{w^{\prime}}\left(s_{i}\right)\right)$。</p></li></ol></li><li><p>分别使用 $d\theta$ 以及 $dw$异步更新 $\theta$ 以及 $w$。</p></li></ol></li></ol><p>A3C支持多智能体（<strong>译者注：这里的多智能体与多智能体强化学习中的多智能体不是一个概念</strong>）并行训练。梯度累积步骤（6.2）可以认为是基于小批量样本的随机梯度下降在并行环境下的变形：$w$ 或者 $\theta$ 的值在每个训练线程得出的更新方向上独立地校正一点点。</p><h3 id="A2C"><a href="#A2C" class="headerlink" title="A2C"></a>A2C</h3><p>[<a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/blob/master/baselines/a2c/a2c.py" target="_blank" rel="external">代码</a>]</p><p><strong>A2C</strong>是A3C的同步、确定版本；这也是为什么要把A3C的第一个”A“（”异步“）去掉。在A3C中，每个演员独立地与（保存）全局参数（的服务器）进行交互，因此有时不同线程中的演员将使用不同版本的策略，因此累积更新的方向将不是最优的。为了解决上述执行策略不一致问题，A2C中引入协调器，在更新全局参数之前等待所有并行的演员完成其工作，那么在下一次迭代中并行的演员将均执行同一策略。同步的梯度更新使得训练过程更加耦合因而有可能使得算法具有更快得收敛速度。</p><p>A2C已被<a href="https://blog.openai.com/baselines-acktr-a2c/" target="_blank" rel="external">证明</a>在能够实现与A3C相同或更好的性能得同时，更有效地利用GPU，并且能够适应更大的批量大小。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-936d61bf7c84165f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2. A3C与A2C架构对比。"></p><h3 id="确定性策略梯度（DPG）"><a href="#确定性策略梯度（DPG）" class="headerlink" title="确定性策略梯度（DPG）"></a>确定性策略梯度（DPG）</h3><p>[<a href="https://hal.inria.fr/file/index/docid/938992/filename/dpg-icml2014.pdf" target="_blank" rel="external">论文</a>|代码]</p><p>在上述方法中，策略函数 $\pi( . | s)$ 总是被建模为给定当前状态下在动作空间 $\mathcal{A}$ 上的概率分布，因而策略是随机的。相反，确定性策略梯度（<strong>Deterministic Policy Gradient</strong>）将环境建模为一个确定性决策：$a=\mu(s)$。这可能看上去很奇怪——你如何计算一个只能输出单个动作的策略函数的梯度呢？让我们一步步往下看。</p><p>回忆一些符号以便进行下面的讨论：</p><ul><li>$\rho_{0}(s)$：初始状态分布</li><li>$\rho^{\mu}\left(s \rightarrow s^{\prime}, k\right)$：从状态 $s$ 开始，遵循策略 $\mu$ 的情况下经过 $k$ 个时间步后到达状态 $s^{\prime}$ 的访问概率密度</li><li>$\rho^{\mu}\left(s^{\prime}\right)$：折扣状态分布，定义为 $\rho^{\mu}\left(s^{\prime}\right)=\int_{\mathcal{S}} \sum_{k=1}^{\infty} \gamma^{k-1} \rho_{0}(s) \rho^{\mu}\left(s \rightarrow s^{\prime}, k\right) d s$</li></ul><p>（平均值形式的）目标函数定义如下：<br>$$<br>J(\theta)=\int_{\mathcal{S}} \rho^{\mu}(s) Q\left(s, \mu_{\theta}(s)\right) ds<br>$$<br><strong>确定性策略梯度定理</strong>：现在该计算梯度了！根据链式法则，我们首先计算 $Q$ 相对于动作 $a$ 的梯度然后计算确定性策略函数 $\mu$ 相对于其参数 $\theta$ 的参数：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;=\int_{\mathcal{S}} \rho^{\mu}(s) \nabla_{a} Q^{\mu}(s, a) \nabla_{\theta} \mu_{\theta}\left.(s)\right|_{a=\mu_{\theta}(s)} d s \\ &amp;=\mathbb{E}_{s \sim \rho^{\mu}}\left[\nabla_{a} Q^{\mu}(s, a) \nabla_{\theta} \mu_{\theta}\left.(s)\right|_{a=\mu_{\theta}(s)}\right]<br>\end{aligned}<br>$$<br>我们可以将确定性策略看成是随即策略的一个特例，前者的在整个动作空间的概率分布只在一个动作上是非零值。实际上在DPG<a href="https://hal.inria.fr/file/index/docid/938992/filename/dpg-icml2014.pdf" target="_blank" rel="external">论文</a>中作者表明，如果随机策略 $\pi_{\mu_{\theta}, \sigma}$ 被确定性策略 $\mu_{\theta}$ 以及一个方差变量 $\sigma$ 重参数化，则当 $\sigma = 0$ 时随机策略最终将等价于确定策略。与确定性策略相比，我们可以认为随机策略需要更多样本，因为它整合了整个状态和动作空间的数据。</p><p>确定性梯度定理可以整合到通用的策略梯度算法框架中。</p><p>让我们考虑一个在线演员-评论家算法的例子来表明这个过程。在在线演员-评论家算法的每次迭代过程中，两个时间步的动作通过确定策略来选择 $a=\mu_{\theta}(s)$，然后 <a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#sarsa-on-policy-td-control" target="_blank" rel="external">SARSA</a> 算法通过上面计算得到的新形式的梯度来更新策略参数：<br>$$<br>\begin{aligned}<br>\delta_t &amp;= R_t + \gamma Q_w(s_{t+1}, a_{t+1}) - Q_w(s_t, a_t) &amp; \scriptstyle{\text{; SARSA算法中的 TD 误差}}\\<br>w_{t+1} &amp;= w_t + \alpha_w \delta_t \nabla_w Q_w(s_t, a_t) &amp; \\<br>\theta_{t+1} &amp;= \theta_t + \alpha_\theta \color{red}{\nabla_a Q_w(s_t, a_t) \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)}} &amp; \scriptstyle{\text{; 确定性策略梯度定理}}<br>\end{aligned}<br>$$<br>然而，除非环境本身具有足够多的噪声，否则由于策略的确定性很难保证在训练的过程中有进行足够多的<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#exploration-exploitation-dilemma" target="_blank" rel="external">探索</a>。我们可以在确定策略中添加噪音（讽刺的是，这使得它将不具有确定性！）或者通过遵循不同的随机<strong>行为</strong>策略来收集样本来离线地学习<strong>目标</strong>确定策略。</p><p>比方说，在离线方法中，训练轨迹样本是通过一个随机行为策略 $\beta(a | s)$ 产生的因而状态分布服从对应的折扣状态密度 $\rho^{\beta}$：<br>$$<br>\begin{aligned}<br>J_\beta(\theta) &amp;= \int_\mathcal{S} \rho^\beta Q^\mu(s, \mu_\theta(s)) ds \\<br>\nabla_\theta J_\beta(\theta) &amp;= \mathbb{E}_{s \sim \rho^\beta} [\nabla_a Q^\mu(s, a) \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)} ]<br>\end{aligned}<br>$$<br>注意由于策略是确定性的，我们只需要通过 $Q^{\mu}\left(s, \mu_{\theta}(s)\right)$ 而不是 $\sum_{a} \pi(a | s) Q^{\pi}(s, a)$ 来估计给定状态 $s$ 的累积回报（<strong>译者注：这也是为什么上述第二个等式期望的下标只有状态的期望</strong>）。就像我们在<a href="#离线策略梯度">之前</a>提到的，在采用随机目标策略的离线方法中，会引入重要性采样来校正行为策略与目标策略之间的不匹配现象。然而，由于确定性策略梯度中移除了在动作空间中的积分项，我们就可以避免使用重要性采样。</p><h3 id="深度确定性策略梯度-（DDPG）"><a href="#深度确定性策略梯度-（DDPG）" class="headerlink" title="深度确定性策略梯度 （DDPG）"></a>深度确定性策略梯度 （DDPG）</h3><p>[<a href="https://arxiv.org/pdf/1509.02971.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/ddpg" target="_blank" rel="external">代码</a>]</p><p><strong>DDPG</strong>（<a href="https://arxiv.org/pdf/1509.02971.pdf" target="_blank" rel="external">Lillicrap, et al., 2015</a>）是深度确定性策略梯度（<strong>Deep Deterministic Policy Gradient</strong>）的缩写，是一个结合了<a href="https://lilianweng.github.io/lil-log/2018/04/08/policy-gradient-algorithms.html#dpg" target="_blank" rel="external">DPG</a>以及<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#deep-q-network" target="_blank" rel="external">DQN</a>的无模型离线演员-评论家算法。回忆一下，DQN（深度Q网络）通过经验回访以及冻结目标网络的方式来稳定Q函数的训练过程。原始的DQN算法只能在离散的动作空间上使用，DDPG算法在学习一个确定性策略的同时通过演员-评论家框架将其扩展到连续的动作空间中。</p><p>为了获得更好的探索度，DDPG通过添加噪声 $\mathcal{N}$ 的方式构建了一个探索策略 $\mu^{\prime}$：<br>$$<br>\mu^{\prime}(s)=\mu_{\theta}(s)+\mathcal{N}<br>$$<br>另外，DDPG对演员以及评论家的目标网络的参数实行的是软更新（”保守策略迭代“），其中 $\tau \ll 1$：$\theta^{\prime} \leftarrow \tau \theta+(1-\tau) \theta^{\prime}$。采用这种方式，目标网络的值被限制为缓慢变化，不同于在DQN的设计中目标网络在一段时间内直接被冻结。</p><p>论文中关于机器人领域特别有用的一个细节是如何正则化低维特征的不同物理单位。例如，我们设计一个模型旨在学习以机器人的位置和速度为输入的策略；这些物理统计数据本质上是不同的，甚至相同类型的统计数据在多个机器人中也可能会有很大差异。论文通过应用<a href="http://proceedings.mlr.press/v37/ioffe15.pdf" target="_blank" rel="external">批正则化</a>通过对一个小批量中的样本的每个维度进行正则化来解决上述问题。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-c2801505c52ccbf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3. DDPG算法。图片来源：[Lillicrap, et al., 2015](https://arxiv.org/pdf/1509.02971.pdf)"></p><h3 id="D4PG"><a href="#D4PG" class="headerlink" title="D4PG"></a>D4PG</h3><p>[<a href="https://openreview.net/forum?id=SyZipzbCb" target="_blank" rel="external">论文</a>|代码（在谷歌中搜索”github d4pg“可以找到一些非官方开源实现）]</p><p>分布地分布式DDPG（<strong>Distributed Distributional DDPG</strong>，<strong>D4PG</strong>）在DDPG算法上进行了一系列的改进使得其可以分布式地运行。</p><p>（1）<strong>分布式评论家</strong>：分布式评论家不再只估计Q值的期望值，而是去估计期望Q值的分布，即将期望Q值作为一个随机变量来进行估计——该变量服从一个由 $w$ 参数化的分布 $Z_w$ 因而 $Q_{w}(s, a)=\mathbb{E} Z_{w}(x, a)$。学习该分布的参数所对应的损失函数是去最小化两个分布之间的某种距离度量——分布式TD误差：$L(w)=\mathbb{E}\left[d\left(\mathcal{T}_{\mu_{\theta}}, Z_{w^{\prime}}(s, a), Z_{w}(s, a)\right]\right.$，其中 $T_{\mu_{\theta}}$ 表示贝尔曼算子。</p><p>相应的，确定性策略梯度更新转变为以下形式：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;\approx \mathbb{E}_{\rho^\mu} [\nabla_a Q_w(s, a) \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)}] &amp; \scriptstyle{\text{; DPG中的梯度更新}} \\<br>&amp;= \mathbb{E}_{\rho^\mu} [\mathbb{E}[\nabla_a Q_w(s, a)] \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)}] &amp; \scriptstyle{\text{; Q值分布的期望}}<br>\end{aligned}<br>$$<br>（2）<strong>N步累积回报</strong>：当计算TD误差时，D4PG计算的是N步的TD目标值而不仅仅只有一步，这样就可以考虑未来更多步骤的回报。因而新的TD目标值变为：<br>$$<br>r\left(s_{0}, a_{0}\right)+\mathbb{E}\left[\sum_{n=1}^{N-1} r\left(s_{n}, a_{n}\right)+\gamma^{N} Q\left(s_{N}, \mu_{\theta}\left(s_{N}\right)\right) | s_{0}, a_{0}\right]<br>$$<br>（3）<strong>多个分布式并行演员</strong>：D4PG使用$K$个独立的演员并行收集训练样本并存储到同一个回访缓冲中。</p><p>（4）<strong>优先经验回放</strong>（<strong>Prioritized Experience Replay</strong>，<a href="https://arxiv.org/abs/1511.05952" target="_blank" rel="external"><strong>PER</strong></a>）：最后一个改进是使用一个非均匀的概率 $p_i$ 从一个大小为 $R$ 的回放缓冲中进行采样。在这种采样方式下，一个样本 $i$ 将以概率 $\left(R p_{i}\right)^{-1}$ 被采样到因而重要性权重为 $\left(R p_{i}\right)^{-1}$。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-73d004524ff39cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4. D4PG算法。图片来源：[Barth-Maron, et al. 2018。注意在原始论文中变量符号的选择与本文有些微的区别；例如，我使用$\mu(.)$而不是$\pi(.)$来表示一个确定性策略](https://openreview.net/forum?id=SyZipzbCb)。"></p><h3 id="MADDPG"><a href="#MADDPG" class="headerlink" title="MADDPG"></a>MADDPG</h3><p>[<a href="https://arxiv.org/pdf/1706.02275.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/maddpg" target="_blank" rel="external">代码</a>]</p><p>多智能体DDPG（<strong>Multi-agent DDPG</strong>，<strong>MADDPG</strong>，<a href="https://arxiv.org/pdf/1706.02275.pdf" target="_blank" rel="external">Lowe et al., 2017</a>）将DDPG扩展到多智能体环境中，其中包含多个智能体在仅依靠局部信息的情况下协作完成任务。从单个智能体的角度来看，环境是非平稳的，因为其他智能体的策略在很快地更新并且一直是未知的。MADDPG是一个经过重新设计的演员评论家算法，专门用于处理这种不断变化的环境以及智能体之间的互动。</p><p>这个问题可以被建模为多智能体版本的MDP，也被称为<em>马尔科夫游戏</em>。其中，共有 $N$ 个智能体，公共的状态空间为 $\mathcal{S}$。每个智能体拥有自己的动作空间 $\mathcal{A}_{1}, \dots, \mathcal{A}_{N}$ 以及观察空间 $\mathcal{O}_{1}, \dots, \mathcal{O}_{N}$。状态转移函数包括所有的状态、动作以及观察空间$\mathcal{T} : \mathcal{S} \times \mathcal{A}_{1} \times \ldots \mathcal{A}_{N} \mapsto \mathcal{S}$。每个智能体自己的随机策略仅仅用到属于自己的观察以及动作：$\pi_{\theta_{i}} : \mathcal{O}_{i} \times \mathcal{A}_{i} \mapsto[0,1]$，一个给定其自身观察下关于动作的概率分布；或者一个确定性策略：$\mu_{\theta_{i}} : \mathcal{O}_{i} \mapsto \mathcal{A}_{i}$。</p><p>令 $\vec{o}=o_{1}, \ldots, o_{N}, \vec{\mu}=\mu_{1}, \ldots, \mu_{N}$ 并且策略是由 $\vec{\theta}=\theta_{1}, \dots, \theta_{N}$ 参数化的。</p><p>MADDPG中的评论家为第 $i$ 个智能体（每个智能体）学习一个中心化的动作-值函数 $Q_{i}^{\vec{\mu}}\left(\vec{o}, a_{1}, \ldots, a_{N}\right)$，其中 $a_{1} \in \mathcal{A}_{1}, \ldots, a_{N} \in \mathcal{A}_{N}$ 是所有智能体的动作。每一个 $Q_{i}^{\vec{\mu}},\;i=1, \dots, N$ 都是独立学习的，因而每个智能体可以拥有任意形式的回报函数，包括竞争环境中相互冲突的回报函数。同时，每个智能体各自的演员，也是独立探索以及独立更新策略参数 $\theta_{i}$。</p><p><strong>演员更新：</strong><br>$$<br>\nabla_{\theta_{i}} J\left(\theta_{i}\right)=\mathbb{E}_{\vec{o}, a \sim D}\left[\nabla_{a_{i}} Q_{i}^{\vec{\mu}}\left(\vec{o}, a_{1}, \ldots, a_{N}\right) \nabla_{\theta_{i}} \mu_{\theta_{i}}\left.\left(o_{i}\right)\right|_{a_{i}=\mu_{\theta_{i}}\left(o_{i}\right)}\right]<br>$$<br>其中 $\mathcal{D}$ 表示经验回放缓冲，包含大量轨迹样本 $\left(\vec{o}, a_{1}, \ldots, a_{N}, r_{1}, \ldots, r_{N}, \vec{o}^{\prime}\right)$ —— 给定当前联合观察 $\vec{o}$，每个智能体分别执行动作 $a_{1}, \dots, a_{N}$ 后获取各自的回报 $r_{1}, \dots, r_{N}$，并转移到下一个联合观察 $\vec{o}^{\prime}$。</p><p><strong>评论家更新：</strong><br>$$<br>\begin{aligned}<br>\mathcal{L}(\theta_i) &amp;= \mathbb{E}_{\vec{o}, a_1, \dots, a_N, r_1, \dots, r_N, \vec{o}’}[ (Q^{\vec{\mu}}_i(\vec{o}, a_1, \dots, a_N) - y)^2 ] &amp; \\<br>\text{其中 } y &amp;= r_i + \gamma Q^{\vec{\mu}’}_i (\vec{o}’, a’_1, \dots, a’_N) \rvert_{a’_j = \mu’_{\theta_j}} &amp; \scriptstyle{\text{; TD目标值!}}<br>\end{aligned}<br>$$<br>其中 $\vec{\mu}^{\prime}$ 是延迟软更新参数的目标策略。</p><p>如果在评论家更新的过程中策略 $\vec{\mu}$ 是未知的，我们可以让每个智能体学习并更新自己对其他智能体策略的近似。当使用近似的策略时，尽管推断出的策略可能不够精确但是MADDPG仍然能够有效地学习。</p><p>为了缓解环境中竞争或协作关系的智能体之间由于相互作用所带来的高方差，MADDPG提出了另外一个技术——策略集成：</p><ol><li>为单个智能体训练 $K$ 个策略；</li><li>随机选取一个策略用以轨迹采样；</li><li>使用 $K$ 个策略的集成梯度来进行参数更新。</li></ol><p>总之，MADDPG在DDPG之上添加了三个额外部分，使其适应多智能体环境：</p><ul><li>中心化评论家+去中心化演员；</li><li>智能体能够使用估计的其他智能体的策略来进行学习；</li><li>策略集成能够很好的减小方差。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13653853-6620a93556a2d0e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5. MADDPG的算法框架. 图片来源：[Lowe et al., 2017](https://arxiv.org/pdf/1706.02275.pdf)"></p><h3 id="TRPO"><a href="#TRPO" class="headerlink" title="TRPO"></a>TRPO</h3><p>[<a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/trpo_mpi" target="_blank" rel="external">代码</a>]</p><p>为了提升训练的稳定性，我们应该避免更新一步就使得策略发生剧烈变化的参数更新。置信区间策略优化（<strong>Trust region policy optimization，TRPO</strong> ，<a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">Schulman, et al., 2015</a>）通过在每次迭代时对策略更新的幅度强制施加KL散度约束来实现上述理念。</p><p>对于离线情况，目标函数衡量的是在遵循一个不同的行为策略 $\beta(a | s)$ 进行采样的同时在状态访问分布以及动作空间上所有的优势：<br>$$<br>\begin{aligned}<br>J(\theta)<br>&amp;= \sum_{s \in \mathcal{S}} \rho^{\pi_{\theta_\text{old}}} \sum_{a \in \mathcal{A}} \big( \pi_\theta(a \vert s) \hat{A}_{\theta_\text{old}}(s, a) \big) &amp; \\<br>&amp;= \sum_{s \in \mathcal{S}} \rho^{\pi_{\theta_\text{old}}} \sum_{a \in \mathcal{A}} \big( \beta(a \vert s) \frac{\pi_\theta(a \vert s)}{\beta(a \vert s)} \hat{A}_{\theta_\text{old}}(s, a) \big) &amp; \scriptstyle{\text{; 重要性采样}} \\<br>&amp;= \mathbb{E}_{s \sim \rho^{\pi_{\theta_\text{old}}}, a \sim \beta} \big[ \frac{\pi_\theta(a \vert s)}{\beta(a \vert s)} \hat{A}_{\theta_\text{old}}(s, a) \big] &amp;<br>\end{aligned}<br>$$<br>其中 $\theta_{\mathrm{old}}$ 是更新之前的策略参数因而对于我们来说是已知的；$\rho^{\pi_{\mathrm{old}}}$ 和<a href="#确定性策略梯度（DPG）">之前</a>的定义相同；$\beta(a | s)$是用来采样轨迹数据的行为策略。注意这里我们使用的是一个估计的优势 $\hat{A}(\cdot)$ 而不是真实的优势 $A(\cdot)$，因为真实的回报往往是未知的。</p><p>对于在线情况，行为策略是 $\pi_{\theta_{\text {old}}}(a | s) :$<br>$$<br>J(\theta) = \mathbb{E}_{s \sim \rho^{\pi_{\theta_\text{old}}}, a \sim \pi_{\theta_\text{old}}} \big[ \frac{\pi_\theta(a \vert s)}{\pi_{\theta_\text{old}}(a \vert s)} \hat{A}_{\theta_\text{old}}(s, a) \big]<br>$$<br>TRPO算法旨在满足<em>置信区间约束</em>下最大化目标函数 $J(\theta)$。该约束强制旧策略与新策略之间的<a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence" target="_blank" rel="external">KL散度</a>小于某个参数 $\delta$：<br>$$<br>\mathbb{E}_{s \sim \rho^{\pi_{\theta_\text{old}}}} [D_\text{KL}(\pi_{\theta_\text{old}}(.\vert s) | \pi_\theta(.\vert s)] \leq \delta<br>$$<br>通过这种方式，当满足这种硬约束时，旧策略和新策略不会差距太大。虽然如此，TRPO可以保证策略一直在往好的方向迭代（很厉害，对吧？）。如果大家感兴趣的话，可以去看看<a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">论文</a>中的证明:)</p><h3 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h3><p>[<a href="https://arxiv.org/pdf/1707.06347.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/ppo1" target="_blank" rel="external">代码</a>]</p><p>鉴于TRPO相对复杂但是我们仍然想要去实现一个类似的约束，近端策略优化（<strong>proximal policy optimization ，PPO</strong>）在实现相似性能的同时通过使用一个截断的替代目标函数来简化TRPO。</p><p>首先，让我们将旧策略和新策略之间的概率比值表示为：<br>$$<br>r(\theta)=\frac{\pi_{\theta}(a | s)}{\pi_{\theta_{\text {old}}}(a | s)}<br>$$<br>接着，TRPO的目标函数（在线）变为：<br>$$<br>J^{\mathrm{TRPO}}(\theta)=\mathbb{E}\left[r(\theta) \hat{A}_{\theta_{\mathrm{old}}}(s, a)\right]<br>$$<br>如果在最大化 $J^{\mathrm{TRPO}}(\theta)$ 时不对 $\theta_{\mathrm{old}}$ 和 $\theta$ 之间的距离加以限制的话，将会因为过大的参数更新幅度以及过大的策略比值而使得更新过程不稳定。PPO通过强行使得 $r(\theta)$ 保持在 $1$ 附近的邻域中，即 $[1-\varepsilon, 1+\varepsilon]$，来施加这一约束。其中 $\varepsilon$ 为超参数。<br>$$<br>J^{\mathrm{CLIP}}(\theta)=\mathbb{E}\left[\min \left(r(\theta) \hat{A}_{\theta_{\mathrm{dd}}}(s, a), \operatorname{clip}(r(\theta), 1-\epsilon, 1+\epsilon) \hat{A}_{\theta_{\mathrm{dd}}}(s, a)\right)\right]<br>$$<br>函数 $\operatorname{clip}(r(\theta), 1-\epsilon, 1+\epsilon)$ 将策略比值约束在 $[1-\varepsilon, 1+\varepsilon]$ 范围内。PPO的目标函数是去取原始值与截断版本的之间的较小值因此我们违背了TRPO最开始的一个理念，即尽可能最大化策略的更新幅度从而得到更好的回报。</p><p>当将PPO算法应用在策略（演员）和值函数（评论家）共享参数的网络结构上时，除了截断回报之外，目标函数上还加上了关于值估计的误差项（红色部分）以及一个熵正则项（蓝色部分）用以鼓励探索。<br>$$<br>J^\text{CLIP’} (\theta) = \mathbb{E} [ J^\text{CLIP} (\theta) - \color{red}{c_1 (V_\theta(s) - V_\text{target})^2} + \color{blue}{c_2 H(s, \pi_\theta(.))} ]<br>$$<br>其中 $c_1$ 和 $c_2$ 为两个常数超参数。</p><p>PPO已经在一系列基准任务上进行了测试并证明可以以更加简单的方式得到可喜的结果。</p><h3 id="ACER"><a href="#ACER" class="headerlink" title="ACER"></a>ACER</h3><p>[<a href="https://arxiv.org/pdf/1611.01224.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/acer" target="_blank" rel="external">代码</a>]</p><p>ACER，带有经验回放的演员-评论家（<strong>Actor-Critic with Experience Replay</strong>，<a href="https://arxiv.org/pdf/1611.01224.pdf" target="_blank" rel="external">Wang, et al., 2017</a>）算法的缩写，是一个带有经验回放的离线演员-评论家算法，它极大地提升了采样有效性并且较低了训练数据间的关联性。A3C基于ACER构建，只不过它是在线方法；ACER是A3C的离线版本。使A3C成为离线方法的主要障碍是如何保证离线估计器的稳定性。ACER提出了三种改进来去克服这个障碍：</p><ul><li>使用 Retrace Q值估计</li><li>使用偏差校正截断重要性权重</li><li>使用更加高效的TRPO算法</li></ul><p><strong>Retrace Q值估计</strong></p><p><a href="http://papers.nips.cc/paper/6538-safe-and-efficient-off-policy-reinforcement-learning.pdf" target="_blank" rel="external">Retrace</a> 是一种离线的基于累积回报的Q值估计算法。它在任意的目标-策略网络对 $(\pi, \beta)$ 下都有一个比较好的收敛性保证并且拥有很好的数据有效性。</p><p>回忆一下TD学习是如何进行预测的：</p><ol><li>计算TD误差：$\delta_{t}=R_{t}+\gamma \mathbb{E}_{a \sim \pi} Q\left(S_{t+1}, a\right)-Q\left(S_{t}, A_{t}\right)$；其中 $r_{t}+\gamma \mathbb{E}_{a \sim \pi} Q\left(s_{t+1}, a\right)$ 被称为”TD目标“。使用期望值 $\mathbb{E}_{a \sim \pi}$ 是因为如果我们遵循当前策略 $\pi$ 的话对于未来时间步我们能做的最好的估计就是累积回报可能是多少。</li><li>通过校正误差往目标移动来更新Q值：$Q\left(S_{t}, A_{t}\right) \leftarrow Q\left(S_{t}, A_{t}\right)+\alpha \delta_{t}$。换句话说，Q的增量更新幅度与TD误差成正比：$\Delta Q\left(S_{t}, A_{t}\right)=\alpha \delta_{t}$。</li></ol><p>当进行离线采样时，我们需要在Q值更新过程中应用重要性采样：<br>$$<br>\Delta Q^{\mathrm{imp}}\left(S_{t}, A_{t}\right)=\gamma^{t} \prod_{1 \leq \tau \leq t} \frac{\pi\left(A_{\tau} | S_{\tau}\right)}{\beta\left(A_{\tau} | S_{\tau}\right)} \delta_{t}<br>$$<br>当我们想象一下重要性权重的连乘会带来多大的方差时就会感觉到这个连乘项有多么可怕了。Retrace Q值估计方法通过截断重要性权重使其不超过某个常数 $c$ 的方式对 $\Delta Q$ 进行修改：<br>$$<br>\Delta Q^{\mathrm{ret}}\left(S_{t}, A_{t}\right)=\gamma^{t} \prod_{1 \leq \tau \leq t} \min \left(c, \frac{\pi\left(A_{\tau} | S_{\tau}\right)}{\beta\left(A_{\tau} | S_{\tau}\right)}\right) \delta_{t}<br>$$<br>ACER使用 $Q^{\mathrm{ret}}$ 作为TD目标通过最小化 $L2$ 误差项来训练评论家：$\left(Q^{\mathrm{ret}}(s, a)-Q(s, a)\right)^{2}$。</p><p><strong>重要性权重截断</strong></p><p>为了减少估计策略梯度 $\hat{g}$ 时产生的高方差，ACER使用一个常数 $c$ 加上一个校正项来截断重要性权重。$\hat{g}_{t}^{\text { acer }}$ 代表 $t$ 时刻的ACER策略梯度。<br>$$<br>\begin{aligned}<br>\hat{g}_t^\text{acer}<br>= &amp; \omega_t \big( Q^\text{ret}(S_t, A_t) - V_{\theta_v}(S_t) \big) \nabla_\theta \ln \pi_\theta(A_t \vert S_t)<br>&amp; \scriptstyle{\text{; 令 }\omega_t=\frac{\pi(A_t \vert S_t)}{\beta(A_t \vert S_t)}} \\<br>= &amp; \color{blue}{\min(c, \omega_t) \big( Q^\text{ret}(S_t, A_t) - V_w(S_t) \big) \nabla_\theta \ln \pi_\theta(A_t \vert S_t)} \\<br>&amp; + \color{red}{\mathbb{E}_{a \sim \pi} \big[ \max(0, \frac{\omega_t(a) - c}{\omega_t(a)}) \big( Q_w(S_t, a) - V_w(S_t) \big) \nabla_\theta \ln \pi_\theta(a \vert S_t) \big]}<br>&amp; \scriptstyle{\text{; 令 }\omega_t (a) =\frac{\pi(a \vert S_t)}{\beta(a \vert S_t)}}<br>\end{aligned}<br>$$<br>其中 $Q_{w}( .)$ 以及 $V_{w}( .)$ 由 $w$ 参数化的评论家预测的动作-值以及状态-值。第一项（蓝色部分）包含了截断重要性权重。截断操作促进方差缩减，减去状态-值 $V_{w}( .)$ 作为基准进一步加强了方差缩减的效果。第二项（红色部分）进行了校正使得上述方差估计为无偏估计。</p><p><strong>高效TRPO</strong></p><p>此外，ACER采用TRPO的思想，但通过一个小的调整使其具有更高的计算效率：ACER不再去计算当前策略与更新一步之后的新策略之间的KL散度，而是去维护一个历史策略的运行平均（running average）值并且强制新策略不会偏离这个平均策略太远。</p><p>ACER论文信息量很大，包含很多公式。但是在事先了解了TD学习，Q学习，重要性采样和TRPO之后，你会发现这篇论文会稍微变得容易理解一些:)</p><h3 id="ACKTR"><a href="#ACKTR" class="headerlink" title="ACKTR"></a>ACKTR</h3><p>[<a href="https://arxiv.org/pdf/1708.05144.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/acktr" target="_blank" rel="external">代码</a>]</p><p>Kronecker因子化置信区间的演员-评论家算法（<strong>Actor-Critic using Kronecker-factored Trust Region，ACKTR</strong>，<a href="https://arxiv.org/pdf/1708.05144.pdf" target="_blank" rel="external">Yuhuai Wu, et al., 2017</a>）使用Kronecker因子化曲率估计（<a href="https://arxiv.org/pdf/1503.05671.pdf" target="_blank" rel="external">K-FAC</a>）同时进行演员以及评论家的梯度更新。K-FAC对自然梯度的计算进行了改进，这与我们的标准梯度有很大不同。<a href="http://kvfrans.com/a-intuitive-explanation-of-natural-gradient-descent/" target="_blank" rel="external">这里</a>有一个对于自然梯度很好很直观的解释。</p><p>如果要用一句话总结的话：</p><blockquote><p>“我们首先考虑所有参数组合，这些参数组合导致新网络与旧网络保持恒定的KL差异。该常数值可以视为步长或学习速率。在所有这些可能的组合中，我们选择最小化损失函数的组合。“</p></blockquote><p>我在这里列出了ACTKR主要是为了这篇文章的完整性，但我不会深入到细节部分，因为它涉及很多关于自然梯度和优化方法的理论知识。如果有兴趣，请在阅读ACKTR论文之前查看这些文章/帖子：</p><ul><li>Amari. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.452.7280&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Natural Gradient Works Efficiently in Learning</a>. 1998</li><li>Kakade. <a href="https://papers.nips.cc/paper/2073-a-natural-policy-gradient.pdf" target="_blank" rel="external">A Natural Policy Gradient</a>. 2002</li><li><a href="http://kvfrans.com/a-intuitive-explanation-of-natural-gradient-descent/" target="_blank" rel="external">A intuitive explanation of natural gradient descent</a></li><li><a href="https://en.wikipedia.org/wiki/Kronecker_product" target="_blank" rel="external">Wiki: Kronecker product</a></li><li>Martens &amp; Grosse. <a href="http://proceedings.mlr.press/v37/martens15.pdf" target="_blank" rel="external">Optimizing neural networks with kronecker-factored approximate curvature.</a> 2015.</li></ul><p>以下是K-FAC论文的高度概括（译者注：以下为论文原文，因此不做翻译）：</p><blockquote><p>“This approximation is built in two stages. In the first, the rows and columns of the Fisher are divided into groups, each of which corresponds to all the weights in a given layer, and this gives rise to a block-partitioning of the matrix. These blocks are then approximated as Kronecker products between much smaller matrices, which we show is equivalent to making certain approximating assumptions regarding the statistics of the network’s gradients.</p><p>In the second stage, this matrix is further approximated as having an inverse which is either block-diagonal or block-tridiagonal. We justify this approximation through a careful examination of the relationships between inverse covariances, tree-structured graphical models, and linear regression. Notably, this justification doesn’t apply to the Fisher itself, and our experiments confirm that while the inverse Fisher does indeed possess this structure (approximately), the Fisher itself does not.”</p></blockquote><h3 id="SAC"><a href="#SAC" class="headerlink" title="SAC"></a>SAC</h3><p>[<a href="https://arxiv.org/abs/1801.01290" target="_blank" rel="external">论文</a>|<a href="https://github.com/haarnoja/sac" target="_blank" rel="external">代码</a>]</p><p>软演员-评论家算法（<strong>Soft Actor-Critic，SAC</strong>，<a href="https://arxiv.org/abs/1801.01290" target="_blank" rel="external">Haarnoja et al. 2018</a>）将策略的熵度量纳入回报函数中用以鼓励探索：我们希望学习到一种尽可能随机行动的策略，同时仍然能够在任务中完成目标。它是一个遵循最大熵强化学习框架的离线演员-评论家模型。一个先例工作是<a href="https://arxiv.org/abs/1702.08165" target="_blank" rel="external">软Q学习</a>。</p><p>SAC算法中的三个关键部分如下：</p><ul><li>包含分离策略网络以及值函数网络的<a href="#演员-评论家算法">演员-评论家</a>架构；</li><li>离线形式使其能够复用历史收集的数据从而实现高采样有效性；</li><li>熵最大化以使得训练稳定并鼓励探索。</li></ul><p>策略的训练目标是同时最大化期望累积回报以及策略的熵度量：<br>$$<br>J(\theta)=\sum_{t=1}^{T} \mathbb{E}_{\left(s_{t}, a_{t}\right) \sim \rho_{\pi_{\theta}}}\left[r\left(s_{t}, a_{t}\right)+\alpha \mathcal{H}\left(\pi_{\theta}\left( . | s_{t}\right)\right)\right]<br>$$</p><p>其中 $\mathcal{H}( .)$ 表示熵度量，$\alpha$ 被称为<em>热度（temperature）</em>参数用以控制熵正则项的重要度。熵最大化使得策略再训练过程中可以（1）进行更多的探索更多和（2）捕获近似最优策略的多种模式（例如，如果存在似乎同样好的多种选项，则策略应该为每个选项分配以相同的概率被选中）。</p><p>准确地说，SAC旨在学习三个函数：</p><ul><li>由 $\theta$ 参数化的策略 $\pi_{\theta}$。</li><li>由 $w$ 参数化的软Q值函数 $Q_w$。</li><li>由 $\psi$ 参数化的软状态-值函数 $V_{\psi}$ ；理论上来说我们可以通过 $Q$ 以及 $\pi$ 来推导出 $V$，但是在实际情况下，显式对状态-值函数建模可以使得训练过程更加稳定。</li></ul><p>软Q值以及软状态值分别定义如下：<br>$$<br>\begin{aligned}<br>Q(s_t, a_t) &amp;= r(s_t, a_t) + \gamma \mathbb{E}_{s_{t+1} \sim \rho_{\pi}(s)} [V(s_{t+1})] &amp; \text{; 根据贝尔曼方程}\\<br>\text{where }V(s_t) &amp;= \mathbb{E}_{a_t \sim \pi} [Q(s_t, a_t) - \alpha \log \pi(a_t \vert s_t)] &amp; \text{; 软状态值函数}<br>\end{aligned}<br>$$</p><p>$$<br>\text{Thus, } Q(s_t, a_t) = r(s_t, a_t) + \gamma \mathbb{E}_{(s_{t+1}, a_{t+1}) \sim \rho_{\pi}} [Q(s_{t+1}, a_{t+1}) - \alpha \log \pi(a_{t+1} \vert s_{t+1})]<br>$$</p><p>$\rho_{\pi}(s)$ 和 $\rho_{\pi}(s, a)$ 分别表示由策略 $\pi(a\vert s)$ 导出的状态分布的状态以及状态-动作边际分布；<a href="#离线策略梯度（Off-Policy Policy Gradient）">DPG算法</a>部分有类似的定义。</p><p>软状态值函数通过最小化均方误差来训练：<br>$$<br>\begin{aligned}<br>J_V(\psi) &amp;= \mathbb{E}_{s_t \sim \mathcal{D}} [\frac{1}{2} \big(V_\psi(s_t) - \mathbb{E}[Q_w(s_t, a_t) - \log \pi_\theta(a_t \vert s_t)] \big)^2] \\<br>\text{其中梯度为: }\nabla_\psi J_V(\psi) &amp;= \nabla_\psi V_\psi(s_t)\big( V_\psi(s_t) - Q_w(s_t, a_t) + \log \pi_\theta (a_t \vert s_t) \big)<br>\end{aligned}<br>$$<br>其中 $\mathcal{D}$ 代表经验回放缓冲。</p><p>软Q值函数通过最小化软贝尔曼残差来训练：<br>$$<br>\begin{aligned}<br>J_Q(w) &amp;= \mathbb{E}_{(s_t, a_t) \sim \mathcal{D}} [\frac{1}{2}\big( Q_w(s_t, a_t) - (r(s_t, a_t) + \gamma \mathbb{E}_{s_{t+1} \sim \rho_\pi(s)}[V_{\bar{\psi}}(s_{t+1})]) \big)^2] \\<br>\text{其中梯度为: } \nabla_w J_Q(w) &amp;= \nabla_w Q_w(s_t, a_t) \big( Q_w(s_t, a_t) - r(s_t, a_t) - \gamma V_{\bar{\psi}}(s_{t+1})\big)<br>\end{aligned}<br>$$<br>其中 $\bar{\psi}$ 代表目标值函数，它是个指数移动平均值（exponential moving average）或者只是采用一种“硬”方式进行周期更新。就像<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#deep-q-network" target="_blank" rel="external">DQN</a>中目标Q网络中的参数一样，为了使得训练过程更加稳定。</p><p>SAC通过最小化如下<a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence" target="_blank" rel="external">KL散度</a>来去更新策略：<br>$$<br>\begin{aligned}<br>\pi_\text{new}<br>&amp;= \arg\min_{\pi’ \in \Pi} D_\text{KL} \Big( \pi’(.\vert s_t) | \frac{\exp(Q^{\pi_\text{old}}(s_t, .))}{Z^{\pi_\text{old}}(s_t)} \Big) \[6pt]<br>&amp;= \arg\min_{\pi’ \in \Pi} D_\text{KL} \big( \pi’(.\vert s_t) | \exp(Q^{\pi_\text{old}}(s_t, .) - \log Z^{\pi_\text{old}}(s_t)) \big) \[6pt]<br>\text{目标函数: } J_\pi(\theta) &amp;= \nabla_\theta D_\text{KL} \big( \pi_\theta(. \vert s_t) | \exp(Q_w(s_t, .) - \log Z_w(s_t)) \big) \[6pt]<br>&amp;= \mathbb{E}_{a_t\sim\pi} \Big[ - \log \big( \frac{\exp(Q_w(s_t, a_t) - \log Z_w(s_t))}{\pi_\theta(a_t \vert s_t)} \big) \Big] \[6pt]<br>&amp;= \mathbb{E}_{a_t\sim\pi} [ \log \pi_\theta(a_t \vert s_t) - Q_w(s_t, a_t) + \log Z_w(s_t) ]<br>\end{aligned}<br>$$<br>其中 $\prod$ 是潜在策略的集合，我们可以将这些策略建模为容易处理的形式；例如，$\prod$ 可以是高斯混合分布族，虽然建模时复杂度较高但是具有很强的表达能力并且易于处理。$Z^{\pi_\text{old}}(s_t)$ 是用于正则化分布的配分函数。它一般是很难处理的但所幸对于梯度值没有影响。最小化 $J_{\pi}(\theta)$ 的方式依赖于 $\prod$ 的选择。</p><p>一旦我们为软动作-值，软状态值和策略网络定义了目标函数和梯度，软演员-评论家算法就很简单了：</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-88808043234e89e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6. 软演员-评论家算法. 图片来源：[原始论文](https://arxiv.org/abs/1801.01290)"></p><h3 id="带有自动热度调整的软演员-评论家算法"><a href="#带有自动热度调整的软演员-评论家算法" class="headerlink" title="带有自动热度调整的软演员-评论家算法"></a>带有自动热度调整的软演员-评论家算法</h3><p>[<a href="https://arxiv.org/abs/1812.05905" target="_blank" rel="external">论文</a>|<a href="https://github.com/rail-berkeley/softlearning" target="_blank" rel="external">代码</a>]</p><p>SAC算法对于热度参数十分敏感。不幸的是，调整热度参数是一件很困难的事情。因为在随着策略由于训练变得更优的过程中或者在不同任务中进行训练时熵都会出现不可预测的变化。在SAC算法针对上述问题的改进可以建模为如下带约束的优化问题：在最大化期望累积回报的同时，策略应满足最小熵约束：<br>$$<br>\max _{\pi_{0}, \ldots, \pi_{T}} \mathbb{E}\left[\sum_{t=0}^{T} r\left(s_{t}, a_{t}\right)\right] \text { s.t. } \forall t, \mathcal{H}\left(\pi_{t}\right) \geq \mathcal{H}_{0}<br>$$<br>其中 $\mathcal{H}_{0}$ 表示预定义的最小策略熵阈值。</p><p>其中期望收益 $\mathbb{E}\left[\sum_{t=0}^{T} r\left(s_{t}, a_{t}\right)\right]$ 可以分解为每一时间步回报的和。因为在时刻 $t$ 的策略 $\pi_t$ 不会影响到之前时刻的策略 $\pi_{t-1}$，我们可以从后往前逐步最大化收益——这其实就是<strong>动态规划</strong>了。<br>$$<br>\underbrace{\max_{\pi_0} \Big( \mathbb{E}[r(s_0, a_0)]+ \underbrace{\max_{\pi_1} \Big(\mathbb{E}[…] + \underbrace{\max_{\pi_T} \mathbb{E}[r(s_T, a_T)]}_\text{第一步最大化} \Big)}_\text{第二步但也是最后一步最大化} \Big)}_\text{最后一步最大化}<br>$$<br>其中 $\gamma=1$。</p><p>我们从最后一个时间步 $T$ 开始最大化：<br>$$<br>\mathbb{E}_{\left(s_{T}, a_{T}\right) \sim \rho_{\pi}}\left[r\left(s_{T}, a_{T}\right)\right] \text { s.t. } \mathcal{H}\left(\pi_{T}\right)-\mathcal{H}_{0} \geq 0<br>$$<br>首先，我们定义以下一些函数：<br>$$<br>\begin{aligned}<br>h(\pi_T) &amp;= \mathcal{H}(\pi_T) - \mathcal{H}_0 = \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [-\log \pi_T(a_T\vert s_T)] - \mathcal{H}_0\\<br>f(\pi_T) &amp;= \begin{cases}<br>\mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) ], &amp; \text{if }h(\pi_T) \geq 0 \\<br>-\infty, &amp; \text{otherwise}<br>\end{cases}<br>\end{aligned}<br>$$<br>因而优化问题就转变为如下形式：<br>$$<br>f\left(\pi_{T}\right) \text { s.t. } h\left(\pi_{T}\right) \geq 0<br>$$<br>为了解决带有不等式约束的最大化优化问题，我们可以构建一个带有拉格朗日乘子（也被称为“对偶变量”） $\alpha_{T}$ 的<a href="https://cs.stanford.edu/people/davidknowles/lagrangian_duality.pdf" target="_blank" rel="external">拉格朗日表达式</a>：<br>$$<br>L\left(\pi_{T}, \alpha_{T}\right)=f\left(\pi_{T}\right)+\alpha_{T} h\left(\pi_{T}\right)<br>$$<br>考虑如下情况，在给定策略 $\pi_{T}$ 的情况下，我们尝试去找到最小化 $L\left(\pi_{T}, \alpha_{T}\right)$ 的 $\alpha_{T}$ 值，</p><ul><li>如果约束被满足，即 $h\left(\pi_{T}\right) \geq 0$ ，那么因为我们无法通过 $\alpha_T$ 控制 $f\left(\pi_{T}\right)$ 的值因此最好将其设置为0（<strong>译者注：这里我有些无法理解，如果要最小化，那么当 $h\left(\pi_{T}\right) \geq 0$ 时 $\alpha_T$ 为负数应该会使得目标函数更小？</strong>）。因而，$L\left(\pi_{T}, 0\right)=f\left(\pi_{T}\right)$。</li><li>如果约束被违背了，即 $h\left(\pi_{T}\right)&lt;0$，我们可以通过令 $\alpha_{T} \rightarrow \infty$ 来使得 $L\left(\pi_{T}, \alpha_{T}\right) \rightarrow-\infty$。因而 $L\left(\pi_{T}, \infty\right)=-\infty=f\left(\pi_{T}\right)$。</li></ul><p>无论哪种情况，我们都可以得到如下等式：<br>$$<br>f\left(\pi_{T}\right)=\min _{\alpha_{T} \geq 0} L\left(\pi_{T}, \alpha_{T}\right)<br>$$<br>同时，我们想要去最大化$ f\left(\pi_{T}\right)$：<br>$$<br>\max _{\pi_{T}} f\left(\pi_{T}\right)=\min _{\alpha_{T} \geq 0} \max _{\pi_{T}} L\left(\pi_{T}, \alpha_{T}\right)<br>$$<br>因此，为了最大化 $f\left(\pi_{T}\right)$，其对应的对偶问题罗列如下。注意为了保证 $\max _{\pi_{T}} f\left(\pi_{T}\right)$ 是一个良定的操作（即 $f\left(\pi_{T}\right)$ 不为 $-\infty$），约束必须要被满足。<br>$$<br>\begin{aligned}<br>\max_{\pi_T} \mathbb{E}[ r(s_T, a_T) ]<br>&amp;= \max_{\pi_T} f(\pi_T) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} L(\pi_T, \alpha_T) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} f(\pi_T) + \alpha_T h(\pi_T) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) ] + \alpha_T ( \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [-\log \pi_T(a_T\vert s_T)] - \mathcal{H}_0) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) - \alpha_T \log \pi_T(a_T\vert s_T)] - \alpha_T \mathcal{H}_0 \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) + \alpha_T \mathcal{H}(\pi_T) - \alpha_T \mathcal{H}_0 ]<br>\end{aligned}<br>$$<br>我们可以迭代地计算最优的 $\pi_T$ 以及 $\alpha_T$。首先给定目前的 $\alpha_{T}$，通过最大化 $L\left(\pi_{T}^{<em>}, \alpha_{T}\right)$ 来得到最优的策略 $\pi_{T}^{</em>}$。然后将 $\pi_{T}^{<em>}$ 代入去最小化 $L\left(\pi_{T}^{</em>}, \alpha_{T}\right)$ 来计算 $\alpha_{T}^{<em>}$。想象一下我们用一个神经网络来表示策略，用另一个网络来表示热度参数，这个迭代过程就与训练演员-评论家算法时更新两者的网络参数比较类似了。<br>$$<br>\begin{aligned}<br>\pi^{</em>}_T<br>&amp;= \arg\max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) + \alpha_T \mathcal{H}(\pi_T) - \alpha_T \mathcal{H}_0 ] \\<br>\color{blue}{\alpha^{<em>}_T}<br>&amp;\color{blue}{=} \color{blue}{\arg\min_{\alpha_T \geq 0} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi^{</em>}}} [\alpha_T \mathcal{H}(\pi^{*}_T) - \alpha_T \mathcal{H}_0 ]}<br>\end{aligned}<br>$$</p><p>$$<br>\text{因而, }\max_{\pi_T} \mathbb{E} [ r(s_T, a_T) ]<br>= \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi^{<em>}}} [ r(s_T, a_T) + \alpha^{</em>}_T \mathcal{H}(\pi^{<em>}_T) - \alpha^{</em>}_T \mathcal{H}_0 ]<br>$$</p><p>现在，让我们回到软Q值函数：<br>$$<br>\begin{aligned}<br>Q_{T-1}(s_{T-1}, a_{T-1})<br>&amp;= r(s_{T-1}, a_{T-1}) + \mathbb{E} [Q(s_T, a_T) - \alpha_T \log \pi(a_T \vert s_T)] \\<br>&amp;= r(s_{T-1}, a_{T-1}) + \mathbb{E} [r(s_T, a_T)] + \alpha_T \mathcal{H}(\pi_T) \\<br>Q_{T-1}^{<em>}(s_{T-1}, a_{T-1})<br>&amp;= r(s_{T-1}, a_{T-1}) + \max_{\pi_T} \mathbb{E} [r(s_T, a_T)] + \alpha_T^{</em>} \mathcal{H}(\pi^{<em>}_T) &amp; \text{; 代入最优策略 }\pi_T^{</em>}<br>\end{aligned}<br>$$<br>因此，当我们进一步退回到 $T-1$ 时间步时，期望收益如下：<br>$$<br>\begin{aligned}<br>&amp;\max_{\pi_{T-1}}\Big(\mathbb{E}[r(s_{T-1}, a_{T-1})] + \max_{\pi_T} \mathbb{E}[r(s_T, a_T] \Big) \\<br>&amp;= \max_{\pi_{T-1}} \Big( Q^{<em>}_{T-1}(s_{T-1}, a_{T-1}) - \alpha^{</em>}_T \mathcal{H}(\pi^{<em>}_T) \Big) &amp; \text{; 需 } \mathcal{H}(\pi_{T-1}) - \mathcal{H}_0 \geq 0 \\<br>&amp;= \min_{\alpha_{T-1} \geq 0} \max_{\pi_{T-1}} \Big( Q^{</em>}_{T-1}(s_{T-1}, a_{T-1}) - \alpha^{<em>}_T \mathcal{H}(\pi^{</em>}_T) + \alpha_{T-1} \big( \mathcal{H}(\pi_{T-1}) - \mathcal{H}_0 \big) \Big) &amp; \text{; 对偶问题} \\<br>&amp;= \min_{\alpha_{T-1} \geq 0} \max_{\pi_{T-1}} \Big( Q^{<em>}_{T-1}(s_{T-1}, a_{T-1}) + \alpha_{T-1} \mathcal{H}(\pi_{T-1}) - \alpha_{T-1}\mathcal{H}_0 \Big) - \alpha^{</em>}_T \mathcal{H}(\pi^{<em>}_T)<br>\end{aligned}<br>$$<br>与之前类似，我们有：<br>$$<br>\begin{aligned}<br>\pi^{</em>}_{T-1} &amp;= \arg\max_{\pi_{T-1}} \mathbb{E}_{(s_{T-1}, a_{T-1}) \sim \rho_\pi} [Q^{<em>}_{T-1}(s_{T-1}, a_{T-1}) + \alpha_{T-1} \mathcal{H}(\pi_{T-1}) - \alpha_{T-1} \mathcal{H}_0 ] \\<br>\color{green}{\alpha^{</em>}_{T-1}} &amp;\color{green}{=} \color{green}{\arg\min_{\alpha_{T-1} \geq 0} \mathbb{E}_{(s_{T-1}, a_{T-1}) \sim \rho_{\pi^{<em>}}} [ \alpha_{T-1} \mathcal{H}(\pi^{</em>}_{T-1}) - \alpha_{T-1}\mathcal{H}_0 ]}<br>\end{aligned}<br>$$<br>绿色部分更新 $\alpha_{T-1}^{<em>}$ 的公式与上面蓝色部分更新 $\alpha_{T}^{</em>}$ 的公式具有相同的形式。通过不断重复上述过程，我们可以通过最小化相同的目标函数（译者注：这里的目标函数中的策略不是最优的）来学习每个时间步的最优热度参数：<br>$$<br>J(\alpha)=\mathbb{E}_{a_{t} \sim \pi_{t}}\left[-\alpha \log \pi_{t}\left(a_{t} | \pi_{t}\right)-\alpha \mathcal{H}_{0}\right]<br>$$<br>除了根据最小化 $J(\alpha)$ 来显式地学习 $\alpha$ 之外本部分算法与SAC算法没有任何区别（见图7）。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-b6a8d9fdca4d146d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7. 带有自动热度调整的软演员-评论家算法. 图片来源：[原始论文](https://arxiv.org/abs/1812.05905)"></p><h3 id="TD3"><a href="#TD3" class="headerlink" title="TD3"></a>TD3</h3><p>[<a href="https://arxiv.org/abs/1802.09477" target="_blank" rel="external">论文</a>|<a href="https://github.com/sfujim/TD3" target="_blank" rel="external">代码</a>]</p><p>众所周知Q学习一直存在对值函数过估计的问题。过估计会随着训练过程不断传播最终会对策略学习造成负面影响。这个问题促使<a href="https://papers.nips.cc/paper/3964-double-q-learning" target="_blank" rel="external">双Q学习</a>以及<a href="https://arxiv.org/abs/1509.06461" target="_blank" rel="external">双DQN</a>的提出：通过使用两个值网络将动作选择和Q值更新进行解耦。</p><p>双延迟深度确定性策略梯度方法（<strong>Twin Delayed Deep Deterministic，TD3</strong>; <a href="https://arxiv.org/abs/1802.09477" target="_blank" rel="external">Fujimoto et al., 2018</a>）在<a href="#深度确定性策略梯度 （DDPG）">DDPG</a>算法的基础上应用了很多新的改进从而防止值函数的过估计现象：</p><p>（1）<strong>截断双Q学习</strong>：在双Q学习中，动作选择以及Q值估计是通过两个独立的网络完成的。在DDPG中，给定两个确定性演员 $\left(\mu_{\theta_{1}}, \mu_{\theta_{2}}\right)$ 以及两个对应的评论家 $\left(Q_{w_{1}}, Q_{w_{2}}\right)$，双Q学习的贝尔曼目标如下：<br>$$<br>\begin{aligned}<br>y_1 &amp;= r + \gamma Q_{w_2}(s’, \mu_{\theta_1}(s’))\\<br>y_2 &amp;= r + \gamma Q_{w_1}(s’, \mu_{\theta_2}(s’))<br>\end{aligned}<br>$$<br>然而，由于策略变化过于缓慢，使得两个演员网络会过于相似从而很难做出完全独立的决策。<em>截断双Q学习</em>使用两者中的最小估计，从而倾向于使用难以通过训练传播的欠估计偏差：<br>$$<br>\begin{aligned}<br>y_1 &amp;= r + \gamma \min_{i=1,2}Q_{w_i}(s’, \mu_{\theta_1}(s’))\\<br>y_2 &amp;= r + \gamma \min_{i=1,2} Q_{w_i}(s’, \mu_{\theta_2}(s’))<br>\end{aligned}<br>$$<br>（2）<strong>延迟更新目标和策略网络</strong>：在<a href="#演员-评论家算法（Actor-Critic）">演员-评论家</a>模型中，策略与值函数的更新深度耦合：当策略较差时值函数的估计将会由于过估计问题发散；相反如果值函数估计不准确又会使得策略变差。</p><p>为了减小训练过程中的方差，TD3以一个相对于Q值函数更低的更新频率来更新策略。策略网络的参数将会保持不变直至值函数误差经过多轮迭代后足够小。这个想法类似于定期更新的目标网络如何在<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#dqn" target="_blank" rel="external">DQN</a>中作为稳定的目标存在。</p><p>（3）<strong>目标策略平滑：</strong>考虑到确定性策略会过拟合到值函数的峰值上，TD3在值函数上引入了平滑正则化策略。在所选动作中添加少量经过截断的随机噪声，并对小批量数据进行平均。<br>$$<br>\begin{aligned}<br>y &amp;= r + \gamma Q_w (s’, \mu_{\theta}(s’) + \epsilon) &amp; \\<br>\epsilon &amp;\sim \text{clip}(\mathcal{N}(0, \sigma), -c, +c) &amp; \scriptstyle{\text{ ; 截断的随机噪声}}<br>\end{aligned}<br>$$<br>这种做法模仿了<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#sarsa-on-policy-td-control" target="_blank" rel="external">SARSA</a>参数更新的思想，并强制相似的动作应具有相似的动作-值。</p><p>下面是最终的算法框架：</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-bb3945372d7d7578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8. TD3算法. 图片来源：[原始论文](https://arxiv.org/abs/1802.09477)"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>研究完上面的所有算法后，我列出了一些似乎在它们中很常见的基础构件或原则：</p><ul><li>尽量减少方差并保持偏差不变以稳定训练过程。</li><li>离线方法可以带来更高的探索度以及更高的数据有效性。</li><li>经验回放（训练数据从一个回放缓存中采样）。</li><li>目标网络要么周期更新要么比正在学习的网络更慢地更新。</li><li>批标准化。</li><li>带有熵正则的回报函数</li><li>演员和评论家可以共享网络的低层参数然后两个输出头分别为策略和值函数。</li><li>可以学习一个确定性的策略而不是一个随即策略。</li><li>在策略更新上施加距离约束。</li><li>新的优化方法（例如K-FAC）。</li><li>最大化策略的熵度量从而鼓励探索。</li><li>避免对值函数过估计。</li><li>等等</li></ul><p>如果你在这篇文章中发现了一些错误或描述不当的地方，不要犹豫，马上通过邮件<em>[lilian dot wengweng at gmail dot com]</em>联系我，我很乐意及时改正！</p><p>下篇文章再见:D</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] jeremykun.com <a href="https://jeremykun.com/2015/04/06/markov-chain-monte-carlo-without-all-the-bullshit/" target="_blank" rel="external">Markov Chain Monte Carlo Without all the Bullshit</a></p><p>[2] Richard S. Sutton and Andrew G. Barto. <a href="http://incompleteideas.net/book/bookdraft2017nov5.pdf" target="_blank" rel="external">Reinforcement Learning: An Introduction; 2nd Edition</a>. 2017.</p><p>[3] John Schulman, et al. <a href="https://arxiv.org/pdf/1506.02438.pdf" target="_blank" rel="external">“High-dimensional continuous control using generalized advantage estimation.”</a> ICLR 2016.</p><p>[4] Thomas Degris, Martha White, and Richard S. Sutton. <a href="https://arxiv.org/pdf/1205.4839.pdf" target="_blank" rel="external">“Off-policy actor-critic.”</a> ICML 2012.</p><p>[5] timvieira.github.io <a href="http://timvieira.github.io/blog/post/2014/12/21/importance-sampling/" target="_blank" rel="external">Importance sampling</a></p><p>[6] Mnih, Volodymyr, et al. <a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">“Asynchronous methods for deep reinforcement learning.”</a> ICML. 2016.</p><p>[7] David Silver, et al. <a href="https://hal.inria.fr/file/index/docid/938992/filename/dpg-icml2014.pdf" target="_blank" rel="external">“Deterministic policy gradient algorithms.”</a> ICML. 2014.</p><p>[8] Timothy P. Lillicrap, et al. <a href="https://arxiv.org/pdf/1509.02971.pdf" target="_blank" rel="external">“Continuous control with deep reinforcement learning.”</a> arXiv preprint arXiv:1509.02971 (2015).</p><p>[9] Ryan Lowe, et al. <a href="https://arxiv.org/pdf/1706.02275.pdf" target="_blank" rel="external">“Multi-agent actor-critic for mixed cooperative-competitive environments.”</a>NIPS. 2017.</p><p>[10] John Schulman, et al. <a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">“Trust region policy optimization.”</a> ICML. 2015.</p><p>[11] Ziyu Wang, et al. <a href="https://arxiv.org/pdf/1611.01224.pdf" target="_blank" rel="external">“Sample efficient actor-critic with experience replay.”</a> ICLR 2017.</p><p>[12] Rémi Munos, Tom Stepleton, Anna Harutyunyan, and Marc Bellemare. <a href="http://papers.nips.cc/paper/6538-safe-and-efficient-off-policy-reinforcement-learning.pdf" target="_blank" rel="external">“Safe and efficient off-policy reinforcement learning”</a> NIPS. 2016.</p><p>[13] Yuhuai Wu, et al. <a href="https://arxiv.org/pdf/1708.05144.pdf" target="_blank" rel="external">“Scalable trust-region method for deep reinforcement learning using Kronecker-factored approximation.”</a> NIPS. 2017.</p><p>[14] kvfrans.com <a href="http://kvfrans.com/a-intuitive-explanation-of-natural-gradient-descent/" target="_blank" rel="external">A intuitive explanation of natural gradient descent</a></p><p>[15] Sham Kakade. <a href="https://papers.nips.cc/paper/2073-a-natural-policy-gradient.pdf" target="_blank" rel="external">“A Natural Policy Gradient.”</a>. NIPS. 2002.</p><p>[16] <a href="https://danieltakeshi.github.io/2017/03/28/going-deeper-into-reinforcement-learning-fundamentals-of-policy-gradients/" target="_blank" rel="external">“Going Deeper Into Reinforcement Learning: Fundamentals of Policy Gradients.”</a> - Seita’s Place, Mar 2017.</p><p>[17] <a href="https://danieltakeshi.github.io/2017/04/02/notes-on-the-generalized-advantage-estimation-paper/" target="_blank" rel="external">“Notes on the Generalized Advantage Estimation Paper.”</a> - Seita’s Place, Apr, 2017.</p><p>[18] Gabriel Barth-Maron, et al. <a href="https://arxiv.org/pdf/1804.08617.pdf" target="_blank" rel="external">“Distributed Distributional Deterministic Policy Gradients.”</a> ICLR 2018 poster.</p><p>[19] Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. <a href="https://arxiv.org/pdf/1801.01290.pdf" target="_blank" rel="external">“Soft Actor-Critic: Off-Policy Maximum Entropy Deep Reinforcement Learning with a Stochastic Actor.”</a> arXiv preprint arXiv:1801.01290 (2018).</p><p>[20] Scott Fujimoto, Herke van Hoof, and Dave Meger. <a href="https://arxiv.org/abs/1802.09477" target="_blank" rel="external">“Addressing Function Approximation Error in Actor-Critic Methods.”</a> arXiv preprint arXiv:1802.09477 (2018).</p><p>[21] Tuomas Haarnoja, et al. <a href="https://arxiv.org/abs/1812.05905" target="_blank" rel="external">“Soft Actor-Critic Algorithms and Applications.”</a> arXiv preprint arXiv:1812.05905 (2018).</p><p>[22] David Knowles. <a href="https://cs.stanford.edu/people/davidknowles/lagrangian_duality.pdf" target="_blank" rel="external">“Lagrangian Duality for Dummies”</a> Nov 13, 2010.</p></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/reinforcement-learning/" rel="tag"># reinforcement learning</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/04/06/Guided-Policy-Search-GPS/" rel="next" title="Guided Policy Search(GPS)"><i class="fa fa-chevron-left"></i> Guided Policy Search(GPS)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f731508143741d" async></script></div></div></div></div><div class="comments" id="comments"><div id="hypercomments_widget"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview">Overview</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Ewan Li"><p class="site-author-name" itemprop="name">Ewan Li</p><p class="site-description motion-element" itemprop="description">Ewan's IT Blog</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">131</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">64</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ewanlee" target="_blank" title="Github"><i class="fa fa-fw fa-globe"></i> Github </a></span><span class="links-of-author-item"><a href="https://twitter.com/tomaxent" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是策略梯度"><span class="nav-number">1.</span> <span class="nav-text">什么是策略梯度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#符号"><span class="nav-number">1.1.</span> <span class="nav-text">符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#策略梯度"><span class="nav-number">1.2.</span> <span class="nav-text">策略梯度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#策略梯度定理"><span class="nav-number">1.3.</span> <span class="nav-text">策略梯度定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#策略梯度定理的证明"><span class="nav-number">1.4.</span> <span class="nav-text">策略梯度定理的证明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略梯度算法"><span class="nav-number">2.</span> <span class="nav-text">策略梯度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#REINFORCE"><span class="nav-number">2.1.</span> <span class="nav-text">REINFORCE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#演员-评论家算法（Actor-Critic）"><span class="nav-number">2.2.</span> <span class="nav-text">演员-评论家算法（Actor-Critic）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离线策略梯度（Off-Policy-Policy-Gradient）"><span class="nav-number">2.3.</span> <span class="nav-text">离线策略梯度（Off-Policy Policy Gradient）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A3C"><span class="nav-number">2.4.</span> <span class="nav-text">A3C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A2C"><span class="nav-number">2.5.</span> <span class="nav-text">A2C</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确定性策略梯度（DPG）"><span class="nav-number">2.6.</span> <span class="nav-text">确定性策略梯度（DPG）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度确定性策略梯度-（DDPG）"><span class="nav-number">2.7.</span> <span class="nav-text">深度确定性策略梯度 （DDPG）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D4PG"><span class="nav-number">2.8.</span> <span class="nav-text">D4PG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MADDPG"><span class="nav-number">2.9.</span> <span class="nav-text">MADDPG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TRPO"><span class="nav-number">2.10.</span> <span class="nav-text">TRPO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPO"><span class="nav-number">2.11.</span> <span class="nav-text">PPO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ACER"><span class="nav-number">2.12.</span> <span class="nav-text">ACER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ACKTR"><span class="nav-number">2.13.</span> <span class="nav-text">ACKTR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SAC"><span class="nav-number">2.14.</span> <span class="nav-text">SAC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带有自动热度调整的软演员-评论家算法"><span class="nav-number">2.15.</span> <span class="nav-text">带有自动热度调整的软演员-评论家算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TD3"><span class="nav-number">2.16.</span> <span class="nav-text">TD3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">4.</span> <span class="nav-text">参考文献</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Ewan Li</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">Theme - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user">本站访客数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次</span> <span class="site-pv"><i class="fa fa-eye">本站总访问量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">_hcwp=window._hcwp||[],_hcwp.push({widget:"Bloggerstream",widget_id:89825,selector:".hc-comment-count",label:"{%COUNT%}"}),_hcwp.push({widget:"Stream",widget_id:89825,xid:"2019/04/14/策略梯度方法/"}),function(){if(!("HC_LOAD_INIT"in window)){HC_LOAD_INIT=!0;var t=(navigator.language||navigator.systemLanguage||navigator.userLanguage||"en").substr(0,2).toLowerCase(),e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src=("https:"==document.location.protocol?"https":"http")+"://w.hypercomments.com/widget/hc/89825/"+t+"/widget.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(e,a.nextSibling)}}()</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),n=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,n=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=n&&a.forEach(function(e,t){i=n.indexOf(e),l=s.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+n+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),n.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("e27VKX5tTklQLCtF7iNMmhcA-gzGzoHsz","nnQn2znNgXXEdK7W2bVJ3bfK")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html>