<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abracdabra</title>
  <subtitle>Do it yourself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-10T03:00:37.566Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ewan Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cs231n Lecture 11 Recap</title>
    <link href="http://yoursite.com/2017/04/10/cs231n-Lecture-11-Recap/"/>
    <id>http://yoursite.com/2017/04/10/cs231n-Lecture-11-Recap/</id>
    <published>2017-04-10T02:30:44.000Z</published>
    <updated>2017-04-10T03:00:37.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Working-with-CNNs-in-practice"><a href="#Working-with-CNNs-in-practice" class="headerlink" title="Working with CNNs in practice"></a>Working with CNNs in practice</h1><ul><li>Making the most of your data<ul><li>Data augmentation</li><li>Transfer learning</li></ul></li><li>All about convolutions<ul><li>How to arrange them</li><li>How to compute them fast</li></ul></li><li>Implementation details<ul><li>GPU / CPU, bottlenecks, ditributed training</li></ul></li></ul><h2 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h2><h3 id="Horizontal-flips"><a href="#Horizontal-flips" class="headerlink" title="Horizontal flips"></a>Horizontal flips</h3><h3 id="Random-crops-scales"><a href="#Random-crops-scales" class="headerlink" title="Random crops/scales"></a>Random crops/scales</h3><p><strong>Training:</strong> sample random crops /scales</p><p>ResNet:</p><ol><li>Pick random L in range [256, 480]</li><li>Resize training image, short side = L</li><li>Sample random 224 x 224 patch</li></ol><p><strong>Testing:</strong> average a fixed set of crops</p><p>ResNet:</p><ol><li>Resize image at 5 scales: {224, 256, 384, 480, 640}</li><li>For each size, use 10 224 x 224 crops: 4 corners + center, + flips</li></ol><h3 id="Color-jitter"><a href="#Color-jitter" class="headerlink" title="Color jitter"></a>Color jitter</h3><p><strong>Simple:</strong><br>Randomly jitter contrast</p><p><strong>Complex:</strong></p><ol><li>Apply PCA to all [R, G, B] pixels in training set</li><li>Sample a “color offset” along principal component directions</li><li>Add offset to all pixels of a training image</li></ol><p>(As seen in [Krizhevsky et al. 2012], ResNet, etc)</p><h2 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h2><p>“You need a lot of a data if you want to train/use CNNs”</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lec11/tl.png" alt="tl"></p><p>some tricks:</p><div class="table-container"><table><thead><tr><th></th><th>very similar dataset</th><th>very different dataset</th></tr></thead><tbody><tr><td>very little data</td><td>Use Linear Classifer on top layer</td><td>Try linear classifer from different stages</td></tr><tr><td>quite a lot of data</td><td>Finetune a few layers</td><td>Finetune a larger number of layers</td></tr></tbody></table></div><h2 id="All-about-Convolutions"><a href="#All-about-Convolutions" class="headerlink" title="All about Convolutions"></a>All about Convolutions</h2><h3 id="How-to-stack-them"><a href="#How-to-stack-them" class="headerlink" title="How to stack them"></a>How to stack them</h3><ul><li>Replace large convolutions (5 x 5, 7 x 7) with stacks of 3 x 3 convolutions</li><li>1 x 1 “bottleneck” convolutions are very efficient</li><li>Can factor N x N convolutions into 1 x N and N x 1</li><li>All of the above give fewer parameters, less compute, more nonlinearity</li></ul><h3 id="How-to-compute-them"><a href="#How-to-compute-them" class="headerlink" title="How to compute them"></a>How to compute them</h3><h4 id="im2col"><a href="#im2col" class="headerlink" title="im2col"></a>im2col</h4><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lec11/cs231n11_im2col.png" alt="im2col"></p><h4 id="BLAS"><a href="#BLAS" class="headerlink" title="BLAS"></a>BLAS</h4><h4 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h4><ol><li>Compute FFT of weights: F(W)</li><li>Compute FFT of image: F(X)</li><li>Compute elementwise product: F(W) ○ F(X)</li><li>Compute inverse FFT: Y = F-1(F(W) ○ F(X))</li></ol><p>FFT convolutions get a big speedup for larger filters</p><p>Not much speedup for 3x3 filters =(</p><h4 id="Fast-algorithms"><a href="#Fast-algorithms" class="headerlink" title="Fast algorithms"></a>Fast algorithms</h4><ul><li>Strassen’s Algorithm</li><li>And so on…</li></ul><h2 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h2><ul><li>GPUs much faster than CPUs</li><li>Distributed training is sometimes used<ul><li>Not needed for small problems</li></ul></li><li>Be aware of bottlenecks: CPU / GPU, CPU / disk</li><li>Low precison makes things faster and still works<ul><li>32 bit is standard now, 16 bit soon</li><li>In the future: binary nets?</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Working-with-CNNs-in-practice&quot;&gt;&lt;a href=&quot;#Working-with-CNNs-in-practice&quot; class=&quot;headerlink&quot; title=&quot;Working with CNNs in practice&quot;&gt;&lt;/a
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="cs231n" scheme="http://yoursite.com/tags/cs231n/"/>
    
  </entry>
  
  <entry>
    <title>Dynet xor demo [python version]</title>
    <link href="http://yoursite.com/2017/04/09/Dynet-xor-demo-python-version/"/>
    <id>http://yoursite.com/2017/04/09/Dynet-xor-demo-python-version/</id>
    <published>2017-04-09T06:15:18.000Z</published>
    <updated>2017-04-09T06:17:35.115Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> dynet <span class="keyword">as</span> dy</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="comment"># Parameters of the model and training</span></div><div class="line">HIDDEN_SIZE = <span class="number">20</span></div><div class="line">NUM_EPOCHS = <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment"># Define the model and SGD optimizer</span></div><div class="line">model = dy.Model()</div><div class="line">W_xh_p = model.add_parameters((HIDDEN_SIZE, <span class="number">2</span>))</div><div class="line">b_h_p = model.add_parameters(HIDDEN_SIZE)</div><div class="line">W_hy_p = model.add_parameters((<span class="number">1</span>, HIDDEN_SIZE))</div><div class="line">b_y_p = model.add_parameters(<span class="number">1</span>)</div><div class="line">trainer = dy.SimpleSGDTrainer(model)</div><div class="line"></div><div class="line"><span class="comment"># Define the training data, consisting of (x,y) tuples</span></div><div class="line">data = [([<span class="number">1</span>,<span class="number">1</span>],<span class="number">1</span>), ([<span class="number">-1</span>,<span class="number">1</span>],<span class="number">-1</span>), ([<span class="number">1</span>,<span class="number">-1</span>],<span class="number">-1</span>), ([<span class="number">-1</span>,<span class="number">-1</span>],<span class="number">1</span>)]</div><div class="line"></div><div class="line"><span class="comment"># Define the function we would like to calculate</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_function</span><span class="params">(x)</span>:</span></div><div class="line">	dy.renew_cg()</div><div class="line">	w_xh = dy.parameter(W_xh_p)</div><div class="line">	b_h = dy.parameter(b_h_p)</div><div class="line">	W_hy = dy.parameter(W_hy_p)</div><div class="line">	b_y = dy.parameter(b_y_p)</div><div class="line">	x_val = dy.inputVector(x)</div><div class="line">	h_val = dy.tanh(w_xh * x_val + b_h)</div><div class="line">	y_val = W_hy * h_val + b_y</div><div class="line">	<span class="keyword">return</span> y_val</div><div class="line"></div><div class="line"><span class="comment"># Perform training</span></div><div class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(NUM_EPOCHS):</div><div class="line">	epoch_loss = <span class="number">0</span></div><div class="line">	random.shuffle(data)</div><div class="line">	<span class="keyword">for</span> x, ystar <span class="keyword">in</span> data:</div><div class="line">		y = calc_function(x)</div><div class="line">		loss = dy.squared_distance(y, dy.scalarInput(ystar))</div><div class="line">		epoch_loss += loss.value()</div><div class="line">		loss.backward()</div><div class="line">		trainer.update()</div><div class="line">	print(<span class="string">"Epoch %d: loss=%f"</span> % (epoch, epoch_loss))</div><div class="line"></div><div class="line"><span class="comment"># Print results of prediction</span></div><div class="line"><span class="keyword">for</span> x, ystar <span class="keyword">in</span> data:</div><div class="line">	y = calc_function(x)</div><div class="line">	print(<span class="string">"%r -&gt; %f"</span> % (x, y.value()))</div></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[dynet] random seed: 1174664263</div><div class="line">[dynet] allocating memory: 512MB</div><div class="line">[dynet] memory allocation done.</div><div class="line">Epoch 0: loss=12.391680</div><div class="line">Epoch 1: loss=8.196088</div><div class="line">Epoch 2: loss=8.103037</div><div class="line">Epoch 3: loss=8.636450</div><div class="line">Epoch 4: loss=7.573008</div><div class="line">Epoch 5: loss=4.910318</div><div class="line">Epoch 6: loss=3.079966</div><div class="line">Epoch 7: loss=1.328273</div><div class="line">Epoch 8: loss=1.171368</div><div class="line">Epoch 9: loss=0.515850</div><div class="line">Epoch 10: loss=1.885216</div><div class="line">Epoch 11: loss=0.568994</div><div class="line">Epoch 12: loss=0.278629</div><div class="line">Epoch 13: loss=0.025215</div><div class="line">Epoch 14: loss=0.018466</div><div class="line">Epoch 15: loss=0.055305</div><div class="line">Epoch 16: loss=0.014131</div><div class="line">Epoch 17: loss=0.010476</div><div class="line">Epoch 18: loss=0.003893</div><div class="line">Epoch 19: loss=0.003332</div><div class="line">[1, 1] -&gt; 1.049703</div><div class="line">[-1, 1] -&gt; -0.996379</div><div class="line">[1, -1] -&gt; -0.974599</div><div class="line">[-1, -1] -&gt; 0.995763</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="dynet" scheme="http://yoursite.com/tags/dynet/"/>
    
  </entry>
  
  <entry>
    <title>Installing the Python Dynet module</title>
    <link href="http://yoursite.com/2017/04/09/Installing-the-Python-Dynet-module/"/>
    <id>http://yoursite.com/2017/04/09/Installing-the-Python-Dynet-module/</id>
    <published>2017-04-09T05:57:09.000Z</published>
    <updated>2017-04-09T06:05:58.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Installing-the-Python-Dynet-module"><a href="#Installing-the-Python-Dynet-module" class="headerlink" title="Installing the Python Dynet module"></a>Installing the Python Dynet module</h1><p>(for instructions on installing on a computer with GPU, see below)</p><p>Python bindings to DyNet are supported for both Python 2.x and 3.x.</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>(see below for the details)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># Installing Python DyNet:</div><div class="line"></div><div class="line">pip install cython  # if you don&apos;t have it already.</div><div class="line">mkdir dynet-base</div><div class="line">cd dynet-base</div><div class="line"># getting dynet and eigen</div><div class="line">git clone https://github.com/clab/dynet.git</div><div class="line">hg clone https://bitbucket.org/eigen/eigen -r 346ecdb  # -r NUM specified a known working revision</div><div class="line">cd dynet</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line"># without GPU support:</div><div class="line">cmake .. -DEIGEN3_INCLUDE_DIR=../../eigen -DPYTHON=`which python`</div><div class="line"># or with GPU support:</div><div class="line">cmake .. -DEIGEN3_INCLUDE_DIR=../../eigen -DPYTHON=`which python` -DBACKEND=cuda</div><div class="line"></div><div class="line">make -j 2 # replace 2 with the number of available cores</div><div class="line">cd python</div><div class="line">python setup.py install  # or `python setup.py install --user` for a user-local install.</div><div class="line"></div><div class="line"># this should suffice, but on some systems you may need to add the following line to your</div><div class="line"># init files in order for the compiled .so files be accessible to Python.</div><div class="line"># /path/to/dynet/build/dynet is the location in which libdynet.dylib resides.</div><div class="line">export DYLD_LIBRARY_PATH=/path/to/dynet/build/dynet/:$DYLD_LIBRARY_PATH</div></pre></td></tr></table></figure><h2 id="Detailed-Instructions"><a href="#Detailed-Instructions" class="headerlink" title="Detailed Instructions"></a>Detailed Instructions</h2><p>First, get DyNet:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd $HOME</div><div class="line">mkdir dynet-base</div><div class="line">cd dynet-base</div><div class="line">git clone https://github.com/clab/dynet.git</div><div class="line">cd dynet</div><div class="line">git submodule init # To be consistent with DyNet&apos;s installation instructions.</div><div class="line">git submodule update # To be consistent with DyNet&apos;s installation instructions.</div></pre></td></tr></table></figure><p>Then get Eigen:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd $HOME</div><div class="line">cd dynet-base</div><div class="line">hg clone https://bitbucket.org/eigen/eigen/ -r 346ecdb</div></pre></td></tr></table></figure><p>(-r NUM specifies a known working revision of Eigen. You can remove this in order to get the bleeding edge Eigen, with the risk of some compile breaks, and the possible benefit of added optimizations.)</p><p>We also need to make sure the <code>cython</code> module is installed. (you can replace <code>pip</code> with your favorite package manager, such as <code>conda</code>, or install within a virtual environment)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install cython</div></pre></td></tr></table></figure><p>To simplify the following steps, we can set a bash variable to hold where we have saved the main directories of DyNet and Eigen. In case you have gotten DyNet and Eigen differently from the instructions above and saved them in different location(s), these variables will be helpful:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PATH_TO_DYNET=$HOME/dynet-base/dynet/</div><div class="line">PATH_TO_EIGEN=$HOME/dynet-base/eigen/</div></pre></td></tr></table></figure><p>Compile DyNet.</p><p>This is pretty much the same process as compiling DyNet, with the addition of the <code>-DPYTHON=</code> flag, pointing to the location of your Python interpreter.</p><p>If Boost is installed in a non-standard location, you should add the corresponding flags to the <code>cmake</code> commandline, see the <a href="https://github.com/clab/dynet/blob/master/doc/source/install.rst" target="_blank" rel="external">DyNet installation instructions page</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd $PATH_TO_DYNET</div><div class="line">PATH_TO_PYTHON=`which python`</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake .. -DEIGEN3_INCLUDE_DIR=$PATH_TO_EIGEN -DPYTHON=$PATH_TO_PYTHON</div><div class="line">make -j 2</div></pre></td></tr></table></figure><p>Assuming that the <code>cmake</code> command found all the needed libraries and didn’t fail, the <code>make</code> command will take a while, and compile DyNet as well as the Python bindings. You can change <code>make -j 2</code> to a higher number, depending on the available cores you want to use while compiling.</p><p>You now have a working Python binding inside of <code>build/dynet</code>. To verify this is working:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd $PATH_TO_DYNET/build/python</div><div class="line">python</div></pre></td></tr></table></figure><p>then, within Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> dynet <span class="keyword">as</span> dy</div><div class="line"><span class="keyword">print</span> dy.__version__</div><div class="line">model = dy.Model()</div></pre></td></tr></table></figure><p>In order to install the module so that it is accessible from everywhere in the system, run the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd $PATH_TO_DYNET/build/python</div><div class="line">python setup.py install --user</div></pre></td></tr></table></figure><p>The <code>--user</code> switch will install the module in your local site-packages, and works without root privileges. To install the module to the system site-packages (for all users), or to the current virtualenv (if you are on one), run <code>python setup.py install</code>without this switch.</p><p>You should now have a working python binding (the <code>dynet</code> module).</p><p>Note however that the installation relies on the compiled DyNet library being in <code>$PATH_TO_DYNET/build/dynet</code>, so make sure not to move it from there.</p><p>Now, check that everything works:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd $PATH_TO_DYNET</div><div class="line">cd examples/python</div><div class="line">python xor.py</div><div class="line">python rnnlm.py rnnlm.py</div></pre></td></tr></table></figure><p>Alternatively, if the following script works for you, then your installation is likely to be working:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> dynet <span class="keyword">import</span> *</div><div class="line">model = Model()</div></pre></td></tr></table></figure><p>If it doesn’t work and you get an error similar to the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ImportError: dlopen(/Users/sneharajana/.python-eggs/dyNET-0.0.0-py2.7-macosx-10.11-intel.egg-tmp/_dynet.so, 2): Library not loaded: @rpath/libdynet.dylib</div><div class="line">Referenced from: /Users/sneharajana/.python-eggs/dyNET-0.0.0-py2.7-macosx-10.11-intel.egg-tmp/_dynet.so</div><div class="line">Reason: image not found``</div></pre></td></tr></table></figure><p>then you may need to run the following (and add it to your shell init files):</p><blockquote><p>export DYLD_LIBRARY_PATH=/path/to/dynet/build/dynet/:$DYLD_LIBRARY_PATH</p></blockquote><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>There are two ways to import the dynet module :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> dynet</div></pre></td></tr></table></figure><p>imports dynet and automatically initializes the global dynet parameters with the command line arguments (see the <a href="https://github.com/clab/dynet/blob/master/doc/source/commandline" target="_blank" rel="external">documentation</a>). The amount of memory allocated, GPU/CPU usage is fixed from there on.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> _dynet</div><div class="line"><span class="comment"># or</span></div><div class="line"><span class="keyword">import</span> _gdynet <span class="comment"># For GPU</span></div></pre></td></tr></table></figure><p>Imports dynet for CPU (resp. GPU) and doesn’t initialize the global parameters. These must be initialized manually before using dynet, using one of the following :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Same as import dynet as dy</span></div><div class="line"><span class="keyword">import</span> _dynet <span class="keyword">as</span> dy</div><div class="line">dy.init()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Same as import dynet as dy</span></div><div class="line"><span class="keyword">import</span> _dynet <span class="keyword">as</span> dy</div><div class="line"><span class="comment"># Declare a DynetParams object</span></div><div class="line">dyparams = dy.DynetParams()</div><div class="line"><span class="comment"># Fetch the command line arguments (optional)</span></div><div class="line">dyparams.from_args()</div><div class="line"><span class="comment"># Set some parameters manualy (see the command line arguments documentation)</span></div><div class="line">dyparams.set_mem(<span class="number">2048</span>)</div><div class="line">dyparams.set_random_seed(<span class="number">666</span>)</div><div class="line">dyparams.set_weight_decay(<span class="number">1e-7</span>)</div><div class="line">dyparams.set_shared_parameters(<span class="keyword">False</span>)</div><div class="line">dyparams.set_requested_gpus(<span class="number">1</span>)</div><div class="line">dyparams.set_gpu_mask([<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>])</div><div class="line"><span class="comment"># Initialize with the given parameters</span></div><div class="line">dyparams.init() <span class="comment"># or init_from_params(dyparams)</span></div></pre></td></tr></table></figure><h2 id="Anaconda-Support"><a href="#Anaconda-Support" class="headerlink" title="Anaconda Support"></a>Anaconda Support</h2><p><a href="https://www.continuum.io/downloads" target="_blank" rel="external">Anaconda</a> is a popular package management system for Python. DyNet can be used from within an Anaconda environment, but be sure to activate the environment</p><blockquote><p>source activate my_environment_name</p></blockquote><p>then install some necessary packages as follows:</p><blockquote><p>conda install gcc cmake boost cython</p></blockquote><p>After this, the build process should be the same as normal.</p><p>Note that on some conda environments, people have reported build errors related to the interaction between the <code>icu</code> and <code>boost</code> packages. If you encounter this, try the solution in <a href="https://github.com/clab/dynet/issues/268#issuecomment-278806398" target="_blank" rel="external">this comment</a>.</p><h2 id="Windows-Support"><a href="#Windows-Support" class="headerlink" title="Windows Support"></a>Windows Support</h2><p>You can also use Python on Windows by following similar steps to the above. For simplicity, we recommend using a Python distribution that already has Cython installed. The following has been tested to work:</p><ol><li>Install WinPython 2.7.10 (comes with Cython already installed).</li><li>Run CMake as above with <code>-DPYTHON=/path/to/your/python.exe</code>.</li><li>Open a command prompt and set <code>VS90COMNTOOLS</code> to the path to your Visual Studio “Common7/Tools” directory. One easy way to do this is a command such as:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set VS90COMNTOOLS=%VS140COMNTOOLS%</div></pre></td></tr></table></figure><ol><li>Open dynet.sln from this command prompt and build the “Release” version of the solution.</li><li>Follow the rest of the instructions above for testing the build and installing it for other users</li></ol><p>Note, currently only the Release version works.</p><h2 id="GPU-MKL-Support"><a href="#GPU-MKL-Support" class="headerlink" title="GPU/MKL Support"></a>GPU/MKL Support</h2><h3 id="Installing-running-on-GPU"><a href="#Installing-running-on-GPU" class="headerlink" title="Installing/running on GPU"></a>Installing/running on GPU</h3><p>For installing on a computer with GPU, first install CUDA. The following instructions assume CUDA is installed.</p><p>The installation process is pretty much the same, while adding the <code>-DBACKEND=cuda</code> flag to the <code>cmake</code> stage:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmake .. -DEIGEN3_INCLUDE_DIR=$PATH_TO_EIGEN -DPYTHON=$PATH_TO_PYTHON -DBACKEND=cuda</div></pre></td></tr></table></figure><p>(if CUDA is installed in a non-standard location and <code>cmake</code> cannot find it, you can specify also <code>-DCUDA_TOOLKIT_ROOT_DIR=/path/to/cuda</code>.)</p><p>Now, build the Python modules (as above, we assume Cython is installed):</p><p>After running <code>make -j 2</code>, you should have the files <code>_dynet.so</code> and <code>_gdynet.so</code> in the <code>build/python</code> folder.</p><p>As before, <code>cd build/python</code> followed by <code>python setup.py install --user</code> will install the module.</p><p>In order to use the GPU support, you can either:</p><ul><li>Use <code>import _gdynet as dy</code> instead of <code>import dynet as dy</code></li><li>Or, (preferred), <code>import dynet</code> as usual, but use the commandline switch <code>--dynet-gpu</code> or the GPU switches detailed <a href="https://github.com/clab/dynet/blob/master/doc/source/commandline.rst" target="_blank" rel="external">here</a>when invoking the program. This option lets the same code work with either the GPU or the CPU version depending on how it is invoked.</li></ul><h3 id="Running-with-MKL"><a href="#Running-with-MKL" class="headerlink" title="Running with MKL"></a>Running with MKL</h3><p>If you’ve built DyNet to use MKL (using <code>-DMKL</code> or <code>-DMKL_ROOT</code>), Python sometimes has difficulty finding the MKL shared libraries. You can try setting <code>LD_LIBRARY_PATH</code> to point to your MKL library directory. If that doesn’t work, try setting the following environment variable (supposing, for example, your MKL libraries are located at <code>/opt/intel/mkl/lib/intel64</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export LD_PRELOAD=/opt/intel/mkl/lib/intel64/libmkl_def.so:/opt/intel/mkl/lib/intel64/libmkl_avx2.so:/opt/intel/mkl/lib</div></pre></td></tr></table></figure><h2 id="Some-Errors-and-correspond-Solutions"><a href="#Some-Errors-and-correspond-Solutions" class="headerlink" title="Some Errors and correspond Solutions"></a>Some Errors and correspond Solutions</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import dynet as dy</div><div class="line">-------------------------------------------</div><div class="line"></div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;dynet.py&quot;, line 17, in &lt;module&gt;</div><div class="line">    from _dynet import *</div><div class="line">ImportError: /home/ewan/anaconda2/lib/libstdc++.so.6: version `GLIBCXX_3.4.20&apos; not found (required by /home/ewan/dynet-base/dynet/build/dynet/libdynet.so)</div><div class="line"></div><div class="line">-------------------------------------------</div><div class="line">Solution:</div><div class="line"></div><div class="line">conda install libgcc</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Installing-the-Python-Dynet-module&quot;&gt;&lt;a href=&quot;#Installing-the-Python-Dynet-module&quot; class=&quot;headerlink&quot; title=&quot;Installing the Python Dy
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="dynet" scheme="http://yoursite.com/tags/dynet/"/>
    
  </entry>
  
  <entry>
    <title>lda for news classification</title>
    <link href="http://yoursite.com/2017/03/26/lda-for-news-classification/"/>
    <id>http://yoursite.com/2017/03/26/lda-for-news-classification/</id>
    <published>2017-03-26T08:54:12.000Z</published>
    <updated>2017-03-26T08:54:12.906Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netease news spider</title>
    <link href="http://yoursite.com/2017/03/26/netease-news-spider/"/>
    <id>http://yoursite.com/2017/03/26/netease-news-spider/</id>
    <published>2017-03-26T08:53:50.000Z</published>
    <updated>2017-03-26T08:53:50.064Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LDA</title>
    <link href="http://yoursite.com/2017/03/24/LDA/"/>
    <id>http://yoursite.com/2017/03/24/LDA/</id>
    <published>2017-03-24T07:11:52.000Z</published>
    <updated>2017-03-24T07:29:41.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scikit-learn-example"><a href="#Scikit-learn-example" class="headerlink" title="Scikit-learn example"></a>Scikit-learn example</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div></pre></td></tr></table></figure><h2 id="Topic-extraction-with-Non-negative-Matrix-Factorization-and-Latent-Dirichlet-Allocation"><a href="#Topic-extraction-with-Non-negative-Matrix-Factorization-and-Latent-Dirichlet-Allocation" class="headerlink" title="Topic extraction with Non-negative Matrix Factorization and Latent Dirichlet Allocation"></a>Topic extraction with Non-negative Matrix Factorization and Latent Dirichlet Allocation</h2><p>This is an example of applying Non-negative Matrix Factorization and Latent Dirichlet Allocation on a corpus of documents and extract additive models of the topic structure of the corpus. The output is a list of topics, each represented as a list of terms (weights are not shown).</p><p>The default parameters (n_samples / n_features / n_topics) should make the example runnable in a couple of tens of seconds. You can try to increase the dimensions of the problem, but be aware that the time complexity is polynomial in NMF. In LDA, the time complexity is proportional to (n_samples * iterations).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Author: Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span></div><div class="line"><span class="comment">#         Lars Buitinck</span></div><div class="line"><span class="comment">#         Chyi-Kwei Yau &lt;chyikwei.yau@gmail.com&gt;</span></div><div class="line"><span class="comment"># License: BSD 3 clause</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer, CountVectorizer</div><div class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> NMF, LatentDirichletAllocation</div><div class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</div><div class="line"></div><div class="line">n_samples = <span class="number">2000</span></div><div class="line">n_features = <span class="number">1000</span></div><div class="line">n_topics = <span class="number">10</span></div><div class="line">n_top_words = <span class="number">20</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_top_words</span><span class="params">(model, feature_names, n_top_words)</span>:</span></div><div class="line">    <span class="keyword">for</span> topic_idx, topic <span class="keyword">in</span> enumerate(model.components_):</div><div class="line">        print(<span class="string">"Topic #%d:"</span> % topic_idx)</div><div class="line">        print(<span class="string">" "</span>.join([feature_names[i]</div><div class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> topic.argsort()[:-n_top_words - <span class="number">1</span>:<span class="number">-1</span>]]))</div><div class="line">    print()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Load the 20 newsgroups dataset and vectorize it. We use a few heuristics</span></div><div class="line"><span class="comment"># to filter out useless terms early on: the posts are stripped of headers,</span></div><div class="line"><span class="comment"># footers and quoted replies, and common English words, words occurring in</span></div><div class="line"><span class="comment"># only one document or in at least 95% of the documents are removed.</span></div><div class="line"></div><div class="line">print(<span class="string">"Loading dataset..."</span>)</div><div class="line">t0 = time()</div><div class="line">dataset = fetch_20newsgroups(shuffle=<span class="keyword">True</span>, random_state=<span class="number">1</span>,</div><div class="line">                             remove=(<span class="string">'headers'</span>, <span class="string">'footers'</span>, <span class="string">'quotes'</span>))</div><div class="line">data_samples = dataset.data[:n_samples]</div><div class="line">print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</div><div class="line"></div><div class="line"><span class="comment"># Use tf-idf features for NMF.</span></div><div class="line">print(<span class="string">"Extracting tf-idf features for NMF..."</span>)</div><div class="line">tfidf_vectorizer = TfidfVectorizer(max_df=<span class="number">0.95</span>, min_df=<span class="number">2</span>,</div><div class="line">                                   max_features=n_features,</div><div class="line">                                   stop_words=<span class="string">'english'</span>)</div><div class="line">t0 = time()</div><div class="line">tfidf = tfidf_vectorizer.fit_transform(data_samples)</div><div class="line">print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</div><div class="line"></div><div class="line"><span class="comment"># Use tf (raw term count) features for LDA.</span></div><div class="line">print(<span class="string">"Extracting tf features for LDA..."</span>)</div><div class="line">tf_vectorizer = CountVectorizer(max_df=<span class="number">0.95</span>, min_df=<span class="number">2</span>,</div><div class="line">                                max_features=n_features,</div><div class="line">                                stop_words=<span class="string">'english'</span>)</div><div class="line">t0 = time()</div><div class="line">tf = tf_vectorizer.fit_transform(data_samples)</div><div class="line">print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</div><div class="line"></div><div class="line"><span class="comment"># Fit the NMF model</span></div><div class="line">print(<span class="string">"Fitting the NMF model with tf-idf features, "</span></div><div class="line">      <span class="string">"n_samples=%d and n_features=%d..."</span></div><div class="line">      % (n_samples, n_features))</div><div class="line">t0 = time()</div><div class="line">nmf = NMF(n_components=n_topics, random_state=<span class="number">1</span>,</div><div class="line">          alpha=<span class="number">.1</span>, l1_ratio=<span class="number">.5</span>).fit(tfidf)</div><div class="line">print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</div><div class="line"></div><div class="line">print(<span class="string">"\nTopics in NMF model:"</span>)</div><div class="line">tfidf_feature_names = tfidf_vectorizer.get_feature_names()</div><div class="line">print_top_words(nmf, tfidf_feature_names, n_top_words)</div><div class="line"></div><div class="line">print(<span class="string">"Fitting LDA models with tf features, "</span></div><div class="line">      <span class="string">"n_samples=%d and n_features=%d..."</span></div><div class="line">      % (n_samples, n_features))</div><div class="line">lda = LatentDirichletAllocation(n_topics=n_topics, max_iter=<span class="number">5</span>,</div><div class="line">                                learning_method=<span class="string">'online'</span>,</div><div class="line">                                learning_offset=<span class="number">50.</span>,</div><div class="line">                                random_state=<span class="number">0</span>)</div><div class="line">t0 = time()</div><div class="line">lda.fit(tf)</div><div class="line">print(<span class="string">"done in %0.3fs."</span> % (time() - t0))</div><div class="line"></div><div class="line">print(<span class="string">"\nTopics in LDA model:"</span>)</div><div class="line">tf_feature_names = tf_vectorizer.get_feature_names()</div><div class="line">print_top_words(lda, tf_feature_names, n_top_words)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Loading dataset...</div></pre></td></tr></table></figure><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No handlers could be found <span class="keyword">for</span> logger <span class="string">"sklearn.datasets.twenty_newsgroups"</span></div></pre></td></tr></table></figure><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">done <span class="keyword">in</span> <span class="number">691.647</span>s.</div><div class="line">Extracting tf-idf features <span class="keyword">for</span> NMF...</div><div class="line">done <span class="keyword">in</span> <span class="number">0.454</span>s.</div><div class="line">Extracting tf features <span class="keyword">for</span> LDA...</div><div class="line">done <span class="keyword">in</span> <span class="number">0.416</span>s.</div><div class="line">Fitting the NMF model <span class="keyword">with</span> tf-idf features, n_samples=<span class="number">2000</span> <span class="keyword">and</span> n_features=<span class="number">1000.</span>..</div><div class="line">done <span class="keyword">in</span> <span class="number">0.367</span>s.</div><div class="line"></div><div class="line">Topics <span class="keyword">in</span> NMF model:</div><div class="line">Topic <span class="comment">#0:</span></div><div class="line">just people don think like know time good make way really say right ve want did ll new use years</div><div class="line">Topic <span class="comment">#1:</span></div><div class="line">windows use dos using window program os drivers application help software pc running ms screen files version card code work</div><div class="line">Topic <span class="comment">#2:</span></div><div class="line">god jesus bible faith christian christ christians does heaven sin believe lord life church mary atheism belief human love religion</div><div class="line">Topic <span class="comment">#3:</span></div><div class="line">thanks know does mail advance hi info interested email anybody looking card help like appreciated information send list video need</div><div class="line">Topic <span class="comment">#4:</span></div><div class="line">car cars tires miles <span class="number">00</span> new engine insurance price condition oil power speed good <span class="number">000</span> brake year models used bought</div><div class="line">Topic <span class="comment">#5:</span></div><div class="line">edu soon com send university internet mit ftp mail cc pub article information hope program mac email home contact blood</div><div class="line">Topic <span class="comment">#6:</span></div><div class="line">file problem files format win sound ftp pub read save site help image available create copy running memory self version</div><div class="line">Topic <span class="comment">#7:</span></div><div class="line">game team games year win play season players nhl runs goal hockey toronto division flyers player defense leafs bad teams</div><div class="line">Topic <span class="comment">#8:</span></div><div class="line">drive drives hard disk floppy software card mac computer power scsi controller apple mb <span class="number">00</span> pc rom sale problem internal</div><div class="line">Topic <span class="comment">#9:</span></div><div class="line">key chip clipper keys encryption government public use secure enforcement phone nsa communications law encrypted security clinton used legal standard</div><div class="line"></div><div class="line">Fitting LDA models <span class="keyword">with</span> tf features, n_samples=<span class="number">2000</span> <span class="keyword">and</span> n_features=<span class="number">1000.</span>..</div><div class="line">done <span class="keyword">in</span> <span class="number">2.169</span>s.</div><div class="line"></div><div class="line">Topics <span class="keyword">in</span> LDA model:</div><div class="line">Topic <span class="comment">#0:</span></div><div class="line">edu com mail send graphics ftp pub available contact university list faq ca information cs <span class="number">1993</span> program sun uk mit</div><div class="line">Topic <span class="comment">#1:</span></div><div class="line">don like just know think ve way use right good going make sure ll point got need really time doesn</div><div class="line">Topic <span class="comment">#2:</span></div><div class="line">christian think atheism faith pittsburgh new bible radio games alt lot just religion like book read play time subject believe</div><div class="line">Topic <span class="comment">#3:</span></div><div class="line">drive disk windows thanks use card drives hard version pc software file using scsi help does new dos controller <span class="number">16</span></div><div class="line">Topic <span class="comment">#4:</span></div><div class="line">hiv health aids disease april medical care research <span class="number">1993</span> light information study national service test led <span class="number">10</span> page new drug</div><div class="line">Topic <span class="comment">#5:</span></div><div class="line">god people does just good don jesus say israel way life know true fact time law want believe make think</div><div class="line">Topic <span class="comment">#6:</span></div><div class="line"><span class="number">55</span> <span class="number">10</span> <span class="number">11</span> <span class="number">18</span> <span class="number">15</span> team game <span class="number">19</span> period play <span class="number">23</span> <span class="number">12</span> <span class="number">13</span> flyers <span class="number">20</span> <span class="number">25</span> <span class="number">22</span> <span class="number">17</span> <span class="number">24</span> <span class="number">16</span></div><div class="line">Topic <span class="comment">#7:</span></div><div class="line">car year just cars new engine like bike good oil insurance better tires <span class="number">000</span> thing speed model brake driving performance</div><div class="line">Topic <span class="comment">#8:</span></div><div class="line">people said did just didn know time like went think children came come don took years say dead told started</div><div class="line">Topic <span class="comment">#9:</span></div><div class="line">key space law government public use encryption earth section security moon probe enforcement keys states lunar military crime surface technology</div></pre></td></tr></table></figure><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data_samples[<span class="number">0</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">u"Well i'm not sure about the story nad it did seem biased. What\nI disagree with is your statement that the U.S. Media is out to\nruin Israels reputation. That is rediculous. The U.S. media is\nthe most pro-israeli media in the world. Having lived in Europe\nI realize that incidences such as the one described in the\nletter have occured. The U.S. media as a whole seem to try to\nignore them. The U.S. is subsidizing Israels existance and the\nEuropeans are not (at least not to the same degree). So I think\nthat might be a reason they report more clearly on the\natrocities.\n\tWhat is a shame is that in Austria, daily reports of\nthe inhuman acts commited by Israeli soldiers and the blessing\nreceived from the Government makes some of the Holocaust guilt\ngo away. After all, look how the Jews are treating other races\nwhen they got power. It is unfortunate.\n"</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tfidf_vectorizer.get_feature_names()[<span class="number">-10</span>:]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="string">u'worth'</span>,</div><div class="line"> <span class="string">u'wouldn'</span>,</div><div class="line"> <span class="string">u'write'</span>,</div><div class="line"> <span class="string">u'written'</span>,</div><div class="line"> <span class="string">u'wrong'</span>,</div><div class="line"> <span class="string">u'xfree86'</span>,</div><div class="line"> <span class="string">u'year'</span>,</div><div class="line"> <span class="string">u'years'</span>,</div><div class="line"> <span class="string">u'yes'</span>,</div><div class="line"> <span class="string">u'young'</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tfidf.toarray().shape</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">2000L</span>, <span class="number">1000L</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dataset.target_names</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'alt.atheism'</span>,</div><div class="line"> <span class="string">'comp.graphics'</span>,</div><div class="line"> <span class="string">'comp.os.ms-windows.misc'</span>,</div><div class="line"> <span class="string">'comp.sys.ibm.pc.hardware'</span>,</div><div class="line"> <span class="string">'comp.sys.mac.hardware'</span>,</div><div class="line"> <span class="string">'comp.windows.x'</span>,</div><div class="line"> <span class="string">'misc.forsale'</span>,</div><div class="line"> <span class="string">'rec.autos'</span>,</div><div class="line"> <span class="string">'rec.motorcycles'</span>,</div><div class="line"> <span class="string">'rec.sport.baseball'</span>,</div><div class="line"> <span class="string">'rec.sport.hockey'</span>,</div><div class="line"> <span class="string">'sci.crypt'</span>,</div><div class="line"> <span class="string">'sci.electronics'</span>,</div><div class="line"> <span class="string">'sci.med'</span>,</div><div class="line"> <span class="string">'sci.space'</span>,</div><div class="line"> <span class="string">'soc.religion.christian'</span>,</div><div class="line"> <span class="string">'talk.politics.guns'</span>,</div><div class="line"> <span class="string">'talk.politics.mideast'</span>,</div><div class="line"> <span class="string">'talk.politics.misc'</span>,</div><div class="line"> <span class="string">'talk.religion.misc'</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lda.transform(tf)[<span class="number">1934</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">array([ <span class="number">0.3587206</span> ,  <span class="number">0.00227337</span>,  <span class="number">0.00227317</span>,  <span class="number">0.50146046</span>,  <span class="number">0.00227288</span>,</div><div class="line">        <span class="number">0.12390701</span>,  <span class="number">0.00227282</span>,  <span class="number">0.00227329</span>,  <span class="number">0.00227343</span>,  <span class="number">0.00227299</span>])</div></pre></td></tr></table></figure><h1 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h1><p>Some materials can find from Github.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Scikit-learn-example&quot;&gt;&lt;a href=&quot;#Scikit-learn-example&quot; class=&quot;headerlink&quot; title=&quot;Scikit-learn example&quot;&gt;&lt;/a&gt;Scikit-learn example&lt;/h1&gt;&lt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Tic-Tac-Toe</title>
    <link href="http://yoursite.com/2017/03/18/Tic-Tac-Toe/"/>
    <id>http://yoursite.com/2017/03/18/Tic-Tac-Toe/</id>
    <published>2017-03-18T14:26:52.000Z</published>
    <updated>2017-03-18T14:27:44.552Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#######################################################################</span></div><div class="line"><span class="comment"># Copyright (C)                                                       #</span></div><div class="line"><span class="comment"># 2016 Shangtong Zhang(zhangshangtong.cpp@gmail.com)                  #</span></div><div class="line"><span class="comment"># 2016 Jan Hakenberg(jan.hakenberg@gmail.com)                         #</span></div><div class="line"><span class="comment"># 2016 Tian Jun(tianjun.cpp@gmail.com)                                #</span></div><div class="line"><span class="comment"># Permission given to modify the code as long as you keep this        #</span></div><div class="line"><span class="comment"># declaration at the top                                              #</span></div><div class="line"><span class="comment">#######################################################################</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pickle</div><div class="line"></div><div class="line">BOARD_ROWS = <span class="number">3</span></div><div class="line">BOARD_COLS = <span class="number">3</span></div><div class="line">BOARD_SIZE = BOARD_ROWS * BOARD_COLS</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># the board is represented by a n * n array,</span></div><div class="line">        <span class="comment"># 1 represents chessman of the player who moves first,</span></div><div class="line">        <span class="comment"># -1 represents chessman of another player</span></div><div class="line">        <span class="comment"># 0 represents empty position</span></div><div class="line">        self.data = np.zeros((BOARD_ROWS, BOARD_COLS))</div><div class="line">        self.winner = <span class="keyword">None</span></div><div class="line">        self.hashVal = <span class="keyword">None</span></div><div class="line">        self.end = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="comment"># calculate the hash value for one state, it's unique</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHash</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hashVal <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.hashVal = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> self.data.reshape(BOARD_ROWS * BOARD_COLS):</div><div class="line">                <span class="keyword">if</span> i == <span class="number">-1</span>:</div><div class="line">                    i = <span class="number">2</span></div><div class="line">                self.hashVal = self.hashVal * <span class="number">3</span> + i</div><div class="line">        <span class="keyword">return</span> int(self.hashVal)</div><div class="line"></div><div class="line">    <span class="comment"># determine whether a player has won the game, or it's a tie</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEnd</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.end <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self.end</div><div class="line">        results = []</div><div class="line">        <span class="comment"># check row</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_ROWS):</div><div class="line">            results.append(np.sum(self.data[i, :]))</div><div class="line">        <span class="comment"># check columns</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_COLS):</div><div class="line">            results.append(np.sum(self.data[:, i]))</div><div class="line"></div><div class="line">        <span class="comment"># check diagonals</span></div><div class="line">        results.append(<span class="number">0</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_ROWS):</div><div class="line">            results[<span class="number">-1</span>] += self.data[i, i]</div><div class="line">        results.append(<span class="number">0</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_ROWS):</div><div class="line">            results[<span class="number">-1</span>] += self.data[i, BOARD_ROWS - <span class="number">1</span> - i]</div><div class="line"></div><div class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">            <span class="keyword">if</span> result == <span class="number">3</span>:</div><div class="line">                self.winner = <span class="number">1</span></div><div class="line">                self.end = <span class="keyword">True</span></div><div class="line">                <span class="keyword">return</span> self.end</div><div class="line">            <span class="keyword">if</span> result == <span class="number">-3</span>:</div><div class="line">                self.winner = <span class="number">-1</span></div><div class="line">                self.end = <span class="keyword">True</span></div><div class="line">                <span class="keyword">return</span> self.end</div><div class="line"></div><div class="line">        <span class="comment"># whether it's a tie</span></div><div class="line">        sum = np.sum(np.abs(self.data))</div><div class="line">        <span class="keyword">if</span> sum == BOARD_ROWS * BOARD_COLS:</div><div class="line">            self.winner = <span class="number">0</span></div><div class="line">            self.end = <span class="keyword">True</span></div><div class="line">            <span class="keyword">return</span> self.end</div><div class="line"></div><div class="line">        <span class="comment"># game is still going on</span></div><div class="line">        self.end = <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> self.end</div><div class="line"></div><div class="line">    <span class="comment"># @symbol 1 or -1</span></div><div class="line">    <span class="comment"># put chessman symbol in position (i, j)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextState</span><span class="params">(self, i, j, symbol)</span>:</span></div><div class="line">        newState = State()</div><div class="line">        newState.data = np.copy(self.data)</div><div class="line">        newState.data[i, j] = symbol</div><div class="line">        <span class="keyword">return</span> newState</div><div class="line"></div><div class="line">    <span class="comment"># print the board</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_ROWS):</div><div class="line">            print(<span class="string">'-------------'</span>)</div><div class="line">            out = <span class="string">'| '</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_COLS):</div><div class="line">                <span class="keyword">if</span> self.data[i, j] == <span class="number">1</span>:</div><div class="line">                    token = <span class="string">'*'</span></div><div class="line">                <span class="keyword">if</span> self.data[i, j] == <span class="number">0</span>:</div><div class="line">                    token = <span class="string">'0'</span></div><div class="line">                <span class="keyword">if</span> self.data[i, j] == <span class="number">-1</span>:</div><div class="line">                    token = <span class="string">'x'</span></div><div class="line">                out += token + <span class="string">' | '</span></div><div class="line">            print(out)</div><div class="line">        print(<span class="string">'-------------'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllStatesImpl</span><span class="params">(currentState, currentSymbol, allStates)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_ROWS):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, BOARD_COLS):</div><div class="line">            <span class="keyword">if</span> currentState.data[i][j] == <span class="number">0</span>:</div><div class="line">                newState = currentState.nextState(i, j, currentSymbol)</div><div class="line">                newHash = newState.getHash()</div><div class="line">                <span class="keyword">if</span> newHash <span class="keyword">not</span> <span class="keyword">in</span> allStates.keys():</div><div class="line">                    isEnd = newState.isEnd()</div><div class="line">                    allStates[newHash] = (newState, isEnd)</div><div class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isEnd:</div><div class="line">                        getAllStatesImpl(newState, -currentSymbol, allStates)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllStates</span><span class="params">()</span>:</span></div><div class="line">    currentSymbol = <span class="number">1</span></div><div class="line">    currentState = State()</div><div class="line">    allStates = dict()</div><div class="line">    allStates[currentState.getHash()] = (currentState, currentState.isEnd())</div><div class="line">    getAllStatesImpl(currentState, currentSymbol, allStates)</div><div class="line">    <span class="keyword">return</span> allStates</div><div class="line"></div><div class="line"><span class="comment"># all possible board configurations</span></div><div class="line">allStates = getAllStates()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Judger</span>:</span></div><div class="line">    <span class="comment"># @player1: player who will move first, its chessman will be 1</span></div><div class="line">    <span class="comment"># @player2: another player with chessman -1</span></div><div class="line">    <span class="comment"># @feedback: if True, both players will receive rewards when game is end</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, player1, player2, feedback=True)</span>:</span></div><div class="line">        self.p1 = player1</div><div class="line">        self.p2 = player2</div><div class="line">        self.feedback = feedback</div><div class="line">        self.currentPlayer = <span class="keyword">None</span></div><div class="line">        self.p1Symbol = <span class="number">1</span></div><div class="line">        self.p2Symbol = <span class="number">-1</span></div><div class="line">        self.p1.setSymbol(self.p1Symbol)</div><div class="line">        self.p2.setSymbol(self.p2Symbol)</div><div class="line">        self.currentState = State()</div><div class="line">        self.allStates = allStates</div><div class="line"></div><div class="line">    <span class="comment"># give reward to two players</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveReward</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.currentState.winner == self.p1Symbol:</div><div class="line">            self.p1.feedReward(<span class="number">1</span>)</div><div class="line">            self.p2.feedReward(<span class="number">0</span>)</div><div class="line">        <span class="keyword">elif</span> self.currentState.winner == self.p2Symbol:</div><div class="line">            self.p1.feedReward(<span class="number">0</span>)</div><div class="line">            self.p2.feedReward(<span class="number">1</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.p1.feedReward(<span class="number">0</span>)</div><div class="line">            self.p2.feedReward(<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedCurrentState</span><span class="params">(self)</span>:</span></div><div class="line">        self.p1.feedState(self.currentState)</div><div class="line">        self.p2.feedState(self.currentState)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></div><div class="line">        self.p1.reset()</div><div class="line">        self.p2.reset()</div><div class="line">        self.currentState = State()</div><div class="line">        self.currentPlayer = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="comment"># @show: if True, print each board during the game</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self, show=False)</span>:</span></div><div class="line">        self.reset()</div><div class="line">        self.feedCurrentState()</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="comment"># set current player</span></div><div class="line">            <span class="keyword">if</span> self.currentPlayer == self.p1:</div><div class="line">                self.currentPlayer = self.p2</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.currentPlayer = self.p1</div><div class="line">            <span class="keyword">if</span> show:</div><div class="line">                self.currentState.show()</div><div class="line">            [i, j, symbol] = self.currentPlayer.takeAction()</div><div class="line">            self.currentState = self.currentState.nextState(i, j, symbol)</div><div class="line">            hashValue = self.currentState.getHash()</div><div class="line">            self.currentState, isEnd = self.allStates[hashValue]</div><div class="line">            self.feedCurrentState()</div><div class="line">            <span class="keyword">if</span> isEnd:</div><div class="line">                <span class="keyword">if</span> self.feedback:</div><div class="line">                    self.giveReward()</div><div class="line">                <span class="keyword">return</span> self.currentState.winner</div><div class="line"></div><div class="line"><span class="comment"># AI player</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>:</span></div><div class="line">    <span class="comment"># @stepSize: step size to update estimations</span></div><div class="line">    <span class="comment"># @exploreRate: possibility to explore</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, stepSize = <span class="number">0.1</span>, exploreRate=<span class="number">0.1</span>)</span>:</span></div><div class="line">        self.allStates = allStates</div><div class="line">        self.estimations = dict()</div><div class="line">        self.stepSize = stepSize</div><div class="line">        self.exploreRate = exploreRate</div><div class="line">        self.states = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></div><div class="line">        self.states = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setSymbol</span><span class="params">(self, symbol)</span>:</span></div><div class="line">        self.symbol = symbol</div><div class="line">        <span class="keyword">for</span> hash <span class="keyword">in</span> self.allStates.keys():</div><div class="line">            (state, isEnd) = self.allStates[hash]</div><div class="line">            <span class="keyword">if</span> isEnd:</div><div class="line">                <span class="keyword">if</span> state.winner == self.symbol:</div><div class="line">                    self.estimations[hash] = <span class="number">1.0</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    self.estimations[hash] = <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.estimations[hash] = <span class="number">0.5</span></div><div class="line"></div><div class="line">    <span class="comment"># accept a state</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedState</span><span class="params">(self, state)</span>:</span></div><div class="line">        self.states.append(state)</div><div class="line"></div><div class="line">    <span class="comment"># update estimation according to reward</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedReward</span><span class="params">(self, reward)</span>:</span></div><div class="line">        <span class="keyword">if</span> len(self.states) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        self.states = [state.getHash() <span class="keyword">for</span> state <span class="keyword">in</span> self.states]</div><div class="line">        target = reward</div><div class="line">        <span class="keyword">for</span> latestState <span class="keyword">in</span> reversed(self.states):</div><div class="line">            value = self.estimations[latestState] + self.stepSize * (target - self.estimations[latestState])</div><div class="line">            self.estimations[latestState] = value</div><div class="line">            target = value</div><div class="line">        self.states = []</div><div class="line"></div><div class="line">    <span class="comment"># determine next action</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeAction</span><span class="params">(self)</span>:</span></div><div class="line">        state = self.states[<span class="number">-1</span>]</div><div class="line">        nextStates = []</div><div class="line">        nextPositions = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(BOARD_ROWS):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(BOARD_COLS):</div><div class="line">                <span class="keyword">if</span> state.data[i, j] == <span class="number">0</span>:</div><div class="line">                    nextPositions.append([i, j])</div><div class="line">                    nextStates.append(state.nextState(i, j, self.symbol).getHash())</div><div class="line">        <span class="keyword">if</span> np.random.binomial(<span class="number">1</span>, self.exploreRate):</div><div class="line">            np.random.shuffle(nextPositions)</div><div class="line">            <span class="comment"># Not sure if truncating is the best way to deal with exploratory step</span></div><div class="line">            <span class="comment"># Maybe it's better to only skip this step rather than forget all the history</span></div><div class="line">            self.states = []</div><div class="line">            action = nextPositions[<span class="number">0</span>]</div><div class="line">            action.append(self.symbol)</div><div class="line">            <span class="keyword">return</span> action</div><div class="line"></div><div class="line">        values = []</div><div class="line">        <span class="keyword">for</span> hash, pos <span class="keyword">in</span> zip(nextStates, nextPositions):</div><div class="line">            values.append((self.estimations[hash], pos))</div><div class="line">        np.random.shuffle(values)</div><div class="line">        values.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="keyword">True</span>)</div><div class="line">        action = values[<span class="number">0</span>][<span class="number">1</span>]</div><div class="line">        action.append(self.symbol)</div><div class="line">        <span class="keyword">return</span> action</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">savePolicy</span><span class="params">(self)</span>:</span></div><div class="line">        fw = open(<span class="string">'optimal_policy_'</span> + str(self.symbol), <span class="string">'wb'</span>)</div><div class="line">        pickle.dump(self.estimations, fw)</div><div class="line">        fw.close()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadPolicy</span><span class="params">(self)</span>:</span></div><div class="line">        fr = open(<span class="string">'optimal_policy_'</span> + str(self.symbol),<span class="string">'rb'</span>)</div><div class="line">        self.estimations = pickle.load(fr)</div><div class="line">        fr.close()</div><div class="line"></div><div class="line"><span class="comment"># human interface</span></div><div class="line"><span class="comment"># input a number to put a chessman</span></div><div class="line"><span class="comment"># | 1 | 2 | 3 |</span></div><div class="line"><span class="comment"># | 4 | 5 | 6 |</span></div><div class="line"><span class="comment"># | 7 | 8 | 9 |</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanPlayer</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, stepSize = <span class="number">0.1</span>, exploreRate=<span class="number">0.1</span>)</span>:</span></div><div class="line">        self.symbol = <span class="keyword">None</span></div><div class="line">        self.currentState = <span class="keyword">None</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setSymbol</span><span class="params">(self, symbol)</span>:</span></div><div class="line">        self.symbol = symbol</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedState</span><span class="params">(self, state)</span>:</span></div><div class="line">        self.currentState = state</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedReward</span><span class="params">(self, reward)</span>:</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeAction</span><span class="params">(self)</span>:</span></div><div class="line">        data = int(input(<span class="string">"Input your position:"</span>))</div><div class="line">        data -= <span class="number">1</span></div><div class="line">        i = data // int(BOARD_COLS)</div><div class="line">        j = data % BOARD_COLS</div><div class="line">        <span class="keyword">if</span> self.currentState.data[i, j] != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> self.takeAction()</div><div class="line">        <span class="keyword">return</span> (i, j, self.symbol)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(epochs=<span class="number">20000</span>)</span>:</span></div><div class="line">    player1 = Player()</div><div class="line">    player2 = Player()</div><div class="line">    judger = Judger(player1, player2)</div><div class="line">    player1Win = <span class="number">0.0</span></div><div class="line">    player2Win = <span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, epochs):</div><div class="line">        print(<span class="string">"Epoch"</span>, i)</div><div class="line">        winner = judger.play()</div><div class="line">        <span class="keyword">if</span> winner == <span class="number">1</span>:</div><div class="line">            player1Win += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> winner == <span class="number">-1</span>:</div><div class="line">            player2Win += <span class="number">1</span></div><div class="line">        judger.reset()</div><div class="line">    print(player1Win / epochs)</div><div class="line">    print(player2Win / epochs)</div><div class="line">    player1.savePolicy()</div><div class="line">    player2.savePolicy()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compete</span><span class="params">(turns=<span class="number">500</span>)</span>:</span></div><div class="line">    player1 = Player(exploreRate=<span class="number">0</span>)</div><div class="line">    player2 = Player(exploreRate=<span class="number">0</span>)</div><div class="line">    judger = Judger(player1, player2, <span class="keyword">False</span>)</div><div class="line">    player1.loadPolicy()</div><div class="line">    player2.loadPolicy()</div><div class="line">    player1Win = <span class="number">0.0</span></div><div class="line">    player2Win = <span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, turns):</div><div class="line">        print(<span class="string">"Epoch"</span>, i)</div><div class="line">        winner = judger.play()</div><div class="line">        <span class="keyword">if</span> winner == <span class="number">1</span>:</div><div class="line">            player1Win += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> winner == <span class="number">-1</span>:</div><div class="line">            player2Win += <span class="number">1</span></div><div class="line">        judger.reset()</div><div class="line">    print(player1Win / turns)</div><div class="line">    print(player2Win / turns)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        player1 = Player(exploreRate=<span class="number">0</span>)</div><div class="line">        player2 = HumanPlayer()</div><div class="line">        judger = Judger(player1, player2, <span class="keyword">False</span>)</div><div class="line">        player1.loadPolicy()</div><div class="line">        winner = judger.play(<span class="keyword">True</span>)</div><div class="line">        <span class="keyword">if</span> winner == player2.symbol:</div><div class="line">            print(<span class="string">"Win!"</span>)</div><div class="line">        <span class="keyword">elif</span> winner == player1.symbol:</div><div class="line">            print(<span class="string">"Lose!"</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"Tie!"</span>)</div><div class="line"></div><div class="line">train()</div><div class="line">compete()</div><div class="line">play()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
    
    </summary>
    
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Excel merge the same value that in a column to a cell</title>
    <link href="http://yoursite.com/2017/03/16/Excel-merge-the-same-value-that-in-a-column-to-a-cell/"/>
    <id>http://yoursite.com/2017/03/16/Excel-merge-the-same-value-that-in-a-column-to-a-cell/</id>
    <published>2017-03-16T05:59:42.000Z</published>
    <updated>2017-03-16T06:04:36.866Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o7ie0tcjk.bkt.clouddn.com/excel/merge_same_value_in_a_column/merge.gif" alt="excel_merge"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o7ie0tcjk.bkt.clouddn.com/excel/merge_same_value_in_a_column/merge.gif&quot; alt=&quot;excel_merge&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Excel" scheme="http://yoursite.com/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Installing ptproc on Ubuntu 16.04 LTS</title>
    <link href="http://yoursite.com/2017/03/16/Installing-ptproc-on-Ubuntu-16-04-LTS/"/>
    <id>http://yoursite.com/2017/03/16/Installing-ptproc-on-Ubuntu-16-04-LTS/</id>
    <published>2017-03-16T03:32:55.000Z</published>
    <updated>2017-03-16T03:41:16.706Z</updated>
    
    <content type="html"><![CDATA[<p>想对事件数据用点过程进行建模，为了不用重复造轮子，所以找到了一个R包ptproc，但是安装时报错</p><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"ptproc"</span>)</div><div class="line"></div><div class="line">-------------------------------</div><div class="line">package ‘ptproc’ is not available (as a binary package <span class="keyword">for</span> R version <span class="number">3.2</span><span class="number">.3</span>)</div></pre></td></tr></table></figure><p>既然仓库里没有，那就只好用源码安装了，源码<a href="http://www.biostat.jhsph.edu/~rpeng/software/src/contrib/ptproc_1.5-1.tar.gz" target="_blank" rel="external">下载地址</a>, 但是依旧报错：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt; install.packages(<span class="string">"ptproc"</span>, repos=<span class="string">"http://www.biostat.jhsph.edu/~rpeng/software"</span>, type=<span class="string">"source"</span>)</div><div class="line">trying URL <span class="string">'http://www.biostat.jhsph.edu/~rpeng/software/src/contrib/ptproc_1.5-1.tar.gz'</span></div><div class="line">Content type <span class="string">'application/x-gzip'</span> length <span class="number">282002</span> bytes (<span class="number">275</span> KB)</div><div class="line">opened URL</div><div class="line">==================================================</div><div class="line">downloaded <span class="number">275</span> KB </div><div class="line"></div><div class="line">* installing *<span class="keyword">source</span>* package ‘ptproc’ <span class="keyword">...</span></div><div class="line">ERROR: a <span class="string">'NAMESPACE'</span> file is required</div><div class="line">* removing ‘/Library/Frameworks/R.framework/Versions/<span class="number">3.1</span>/Resources/<span class="keyword">library</span>/ptproc’ </div><div class="line"></div><div class="line">The downloaded <span class="keyword">source</span> packages are <span class="keyword">in</span> 		‘/private/var/folders/0b/qdw3f3zn0gq5yy2cjjpm8cgw0000gn/<span class="literal">T</span>/RtmpuW1EPA/downloaded_packages’</div><div class="line">Warning message:</div><div class="line">In install.packages(<span class="string">"ptproc"</span>, repos = <span class="string">"http://www.biostat.jhsph.edu/~rpeng/software"</span>, :</div><div class="line">                    installation of package ‘ptproc’ had non-zero exit status</div></pre></td></tr></table></figure><p>看来只有手动添加一个NAMESPACE,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd ptproc</div><div class="line">echo &apos;exportPattern( &quot;.&quot; )&apos; &gt; NAMESPACE</div><div class="line">cd ../</div><div class="line">rm ptproc_1.5-1.tar.gz</div><div class="line">tar cvzf ptproc/ ptproc_1.5-1.tar.gz</div></pre></td></tr></table></figure><p>继续源码安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">R CMD INSTALL -l &lt;ourRlibrarylocation&gt; &lt;path where I saved the packagename.tar.gz file&gt;</div></pre></td></tr></table></figure><p>Got it.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想对事件数据用点过程进行建模，为了不用重复造轮子，所以找到了一个R包ptproc，但是安装时报错&lt;/p&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/d
    
    </summary>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
      <category term="point process" scheme="http://yoursite.com/tags/point-process/"/>
    
  </entry>
  
  <entry>
    <title>python data analysis learning note Ch12</title>
    <link href="http://yoursite.com/2017/03/09/python-data-analysis-learning-note-Ch12/"/>
    <id>http://yoursite.com/2017/03/09/python-data-analysis-learning-note-Ch12/</id>
    <published>2017-03-09T06:02:20.000Z</published>
    <updated>2017-03-09T06:03:38.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Numpy高级应用"><a href="#Numpy高级应用" class="headerlink" title="Numpy高级应用"></a>Numpy高级应用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">np.set_printoptions(precision=<span class="number">4</span>)</div><div class="line"><span class="keyword">import</span> sys</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure><h2 id="ndarray对象的内部机制"><a href="#ndarray对象的内部机制" class="headerlink" title="ndarray对象的内部机制"></a>ndarray对象的内部机制</h2><h3 id="NumPy-数据类型体系"><a href="#NumPy-数据类型体系" class="headerlink" title="NumPy 数据类型体系"></a>NumPy 数据类型体系</h3><p>检测类型是否是某种类型的子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ints = np.ones(<span class="number">10</span>, dtype=np.uint16)</div><div class="line">floats = np.ones(<span class="number">10</span>, dtype=np.float32)</div><div class="line">np.issubdtype(ints.dtype, np.integer)</div><div class="line">np.issubdtype(floats.dtype, np.floating)</div></pre></td></tr></table></figure><pre><code>True






True
</code></pre><p>输出某种类型的所有父类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.float64.mro()</div></pre></td></tr></table></figure><pre><code>[numpy.float64,
 numpy.floating,
 numpy.inexact,
 numpy.number,
 numpy.generic,
 float,
 object]
</code></pre><h2 id="高级数组操作"><a href="#高级数组操作" class="headerlink" title="高级数组操作"></a>高级数组操作</h2><h3 id="数组重塑"><a href="#数组重塑" class="headerlink" title="数组重塑"></a>数组重塑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">8</span>)</div><div class="line">arr</div><div class="line">arr.reshape((<span class="number">4</span>, <span class="number">2</span>))</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4, 5, 6, 7])






array([[0, 1],
       [2, 3],
       [4, 5],
       [6, 7]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.reshape((<span class="number">4</span>, <span class="number">2</span>)).reshape((<span class="number">2</span>, <span class="number">4</span>))</div></pre></td></tr></table></figure><pre><code>array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
</code></pre><p>-1代表自动选择合适的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">15</span>)</div><div class="line">arr.reshape((<span class="number">5</span>, <span class="number">-1</span>))</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])
</code></pre><p>用其他数组的shape进行重塑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">other_arr = np.ones((<span class="number">3</span>, <span class="number">5</span>))</div><div class="line">other_arr.shape</div><div class="line">arr.reshape(other_arr.shape)</div></pre></td></tr></table></figure><pre><code>(3, 5)






array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
</code></pre><p>拉直</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">5</span>, <span class="number">3</span>))</div><div class="line">arr</div><div class="line">arr.ravel()</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])






array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre><p>会产生一个副本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.flatten()</div></pre></td></tr></table></figure><pre><code>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre><h3 id="C-vs-Fortran-顺序"><a href="#C-vs-Fortran-顺序" class="headerlink" title="C vs. Fortran 顺序"></a>C vs. Fortran 顺序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line">arr</div><div class="line">arr.ravel()</div><div class="line">arr.ravel(<span class="string">'F'</span>)</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])






array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])






array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])
</code></pre><h3 id="数组的合并以及拆分"><a href="#数组的合并以及拆分" class="headerlink" title="数组的合并以及拆分"></a>数组的合并以及拆分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line">arr2 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</div><div class="line">np.concatenate([arr1, arr2], axis=<span class="number">0</span>)</div><div class="line">np.concatenate([arr1, arr2], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])






array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])
</code></pre><p>更方便的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">np.vstack((arr1, arr2))</div><div class="line">np.hstack((arr1, arr2))</div></pre></td></tr></table></figure><pre><code>array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])






array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line">arr = randn(<span class="number">5</span>, <span class="number">2</span>)</div><div class="line">arr</div><div class="line">first, second, third = np.split(arr, [<span class="number">1</span>, <span class="number">3</span>])</div><div class="line">first</div><div class="line">second</div><div class="line">third</div></pre></td></tr></table></figure><pre><code>array([[ 0.9659,  1.3079],
       [-1.7632,  0.0904],
       [-0.6033,  0.2266],
       [-0.4417, -1.8609],
       [-1.2463, -0.6249]])






array([[ 0.9659,  1.3079]])






array([[-1.7632,  0.0904],
       [-0.6033,  0.2266]])






array([[-0.4417, -1.8609],
       [-1.2463, -0.6249]])
</code></pre><h4 id="堆叠辅助类"><a href="#堆叠辅助类" class="headerlink" title="堆叠辅助类"></a>堆叠辅助类</h4><p>更…简洁…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">6</span>)</div><div class="line">arr1 = arr.reshape((<span class="number">3</span>, <span class="number">2</span>))</div><div class="line">arr2 = randn(<span class="number">3</span>, <span class="number">2</span>)</div><div class="line">np.r_[arr1, arr2]</div><div class="line">np.c_[np.r_[arr1, arr2], arr]</div></pre></td></tr></table></figure><pre><code>array([[ 0.    ,  1.    ],
       [ 2.    ,  3.    ],
       [ 4.    ,  5.    ],
       [ 0.0376,  1.8236],
       [ 0.9025, -0.053 ],
       [-0.6849,  1.6728]])






array([[ 0.    ,  1.    ,  0.    ],
       [ 2.    ,  3.    ,  1.    ],
       [ 4.    ,  5.    ,  2.    ],
       [ 0.0376,  1.8236,  3.    ],
       [ 0.9025, -0.053 ,  4.    ],
       [-0.6849,  1.6728,  5.    ]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.c_[<span class="number">1</span>:<span class="number">6</span>, <span class="number">-10</span>:<span class="number">-5</span>]</div></pre></td></tr></table></figure><pre><code>array([[  1, -10],
       [  2,  -9],
       [  3,  -8],
       [  4,  -7],
       [  5,  -6]])
</code></pre><h3 id="元素的重复操作-tile-and-repeat"><a href="#元素的重复操作-tile-and-repeat" class="headerlink" title="元素的重复操作: tile and repeat"></a>元素的重复操作: tile and repeat</h3><p>元素级重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">3</span>)</div><div class="line">arr.repeat(<span class="number">3</span>)</div></pre></td></tr></table></figure><pre><code>array([0, 0, 0, 1, 1, 1, 2, 2, 2])
</code></pre><p>指定重复次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.repeat([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div></pre></td></tr></table></figure><pre><code>array([0, 0, 1, 1, 1, 2, 2, 2, 2])
</code></pre><p>多维数组需要指定<code>axis</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">2</span>, <span class="number">2</span>)</div><div class="line">arr</div><div class="line">arr.repeat(<span class="number">2</span>, axis=<span class="number">0</span>)</div></pre></td></tr></table></figure><pre><code>array([[-0.4628,  1.1142],
       [ 0.3637,  0.4341]])






array([[-0.4628,  1.1142],
       [-0.4628,  1.1142],
       [ 0.3637,  0.4341],
       [ 0.3637,  0.4341]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.repeat([<span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">0</span>)</div><div class="line">arr.repeat([<span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>array([[-0.4628,  1.1142],
       [-0.4628,  1.1142],
       [ 0.3637,  0.4341],
       [ 0.3637,  0.4341],
       [ 0.3637,  0.4341]])






array([[-0.4628, -0.4628,  1.1142,  1.1142,  1.1142],
       [ 0.3637,  0.3637,  0.4341,  0.4341,  0.4341]])
</code></pre><p>块级重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr</div><div class="line">np.tile(arr, <span class="number">2</span>)</div></pre></td></tr></table></figure><pre><code>array([[-0.4628,  1.1142],
       [ 0.3637,  0.4341]])






array([[-0.4628,  1.1142, -0.4628,  1.1142],
       [ 0.3637,  0.4341,  0.3637,  0.4341]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr</div><div class="line">np.tile(arr, (<span class="number">2</span>, <span class="number">1</span>))</div><div class="line">np.tile(arr, (<span class="number">3</span>, <span class="number">2</span>))</div></pre></td></tr></table></figure><pre><code>array([[-0.4628,  1.1142],
       [ 0.3637,  0.4341]])






array([[-0.4628,  1.1142],
       [ 0.3637,  0.4341],
       [-0.4628,  1.1142],
       [ 0.3637,  0.4341]])






array([[-0.4628,  1.1142, -0.4628,  1.1142],
       [ 0.3637,  0.4341,  0.3637,  0.4341],
       [-0.4628,  1.1142, -0.4628,  1.1142],
       [ 0.3637,  0.4341,  0.3637,  0.4341],
       [-0.4628,  1.1142, -0.4628,  1.1142],
       [ 0.3637,  0.4341,  0.3637,  0.4341]])
</code></pre><h3 id="花式索引的等价函数-take-and-put"><a href="#花式索引的等价函数-take-and-put" class="headerlink" title="花式索引的等价函数: take and put"></a>花式索引的等价函数: take and put</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">10</span>) * <span class="number">100</span></div><div class="line">inds = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>]</div><div class="line">arr[inds]</div></pre></td></tr></table></figure><pre><code>array([700, 100, 200, 600])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr.take(inds)</div><div class="line">arr.put(inds, <span class="number">42</span>)</div><div class="line">arr</div><div class="line">arr.put(inds, [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>])</div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([700, 100, 200, 600])






array([  0,  42,  42, 300, 400, 500,  42,  42, 800, 900])






array([  0,  41,  42, 300, 400, 500,  43,  40, 800, 900])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">inds = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line">arr = randn(<span class="number">2</span>, <span class="number">4</span>)</div><div class="line">arr</div><div class="line">arr.take(inds, axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>array([[ 0.2772, -1.3059, -1.4607, -0.4856],
       [ 1.5585, -0.4521, -1.6259, -1.6644]])






array([[-1.4607,  0.2772, -1.4607, -1.3059],
       [-1.6259,  1.5585, -1.6259, -0.4521]])
</code></pre><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>每一个元素都乘以4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">5</span>)</div><div class="line">arr</div><div class="line">arr * <span class="number">4</span></div></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4])






array([ 0,  4,  8, 12, 16])
</code></pre><p>每一维对应减去均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">4</span>, <span class="number">3</span>)</div><div class="line">arr.mean(<span class="number">0</span>)</div><div class="line">demeaned = arr - arr.mean(<span class="number">0</span>)</div><div class="line">demeaned</div><div class="line">demeaned.mean(<span class="number">0</span>)</div></pre></td></tr></table></figure><pre><code>array([-0.1556,  0.3494, -0.2545])






array([[-0.3753,  0.5353,  1.3534],
       [-0.4282,  0.5606,  0.8935],
       [-0.0956, -0.9767, -1.2444],
       [ 0.899 , -0.1192, -1.0024]])






array([ -5.5511e-17,  -1.3878e-17,   0.0000e+00])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr</div><div class="line">row_means = arr.mean(<span class="number">1</span>)</div><div class="line">row_means.reshape((<span class="number">4</span>, <span class="number">1</span>))</div><div class="line">demeaned = arr - row_means.reshape((<span class="number">4</span>, <span class="number">1</span>))</div><div class="line">demeaned.mean(<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>array([[-0.5308,  0.8848,  1.0989],
       [-0.5837,  0.91  ,  0.639 ],
       [-0.2511, -0.6273, -1.4989],
       [ 0.7434,  0.2302, -1.2569]])






array([[ 0.4843],
       [ 0.3218],
       [-0.7924],
       [-0.0944]])






array([  7.4015e-17,   0.0000e+00,   0.0000e+00,   0.0000e+00])
</code></pre><h3 id="沿其他轴向广播"><a href="#沿其他轴向广播" class="headerlink" title="沿其他轴向广播"></a>沿其他轴向广播</h3><p>维度不对应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr - arr.mean(<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-31-7b87b85a20b2&gt; in &lt;module&gt;()
----&gt; 1 arr - arr.mean(1)


ValueError: operands could not be broadcast together with shapes (4,3) (4,) 
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr - arr.mean(<span class="number">1</span>).reshape((<span class="number">4</span>, <span class="number">1</span>))</div></pre></td></tr></table></figure><pre><code>array([[-1.0151,  0.4005,  0.6146],
       [-0.9055,  0.5882,  0.3173],
       [ 0.5413,  0.1652, -0.7065],
       [ 0.8378,  0.3246, -1.1625]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr = np.zeros((<span class="number">4</span>, <span class="number">4</span>))</div><div class="line">arr_3d = arr[:, np.newaxis]</div><div class="line">arr_3d</div><div class="line">arr_3d.shape</div></pre></td></tr></table></figure><pre><code>array([[[ 0.,  0.,  0.,  0.]],

       [[ 0.,  0.,  0.,  0.]],

       [[ 0.,  0.,  0.,  0.]],

       [[ 0.,  0.,  0.,  0.]]])






(4, 1, 4)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr_1d = np.random.normal(size=<span class="number">3</span>)</div><div class="line">arr_1d</div><div class="line">arr_1d[:, np.newaxis]</div><div class="line">arr_1d[np.newaxis, :]</div></pre></td></tr></table></figure><pre><code>array([-1.1083,  0.5576,  1.2277])






array([[-1.1083],
       [ 0.5576],
       [ 1.2277]])






array([[-1.1083,  0.5576,  1.2277]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">arr</div><div class="line">depth_means = arr.mean(<span class="number">2</span>)</div><div class="line">depth_means</div><div class="line">demeaned = arr - depth_means[:, :, np.newaxis]</div><div class="line">demeaned.mean(<span class="number">2</span>)</div></pre></td></tr></table></figure><pre><code>array([[[-1.9966, -0.2431, -0.992 ,  0.8283, -0.5073],
        [-0.3938, -0.1332, -0.7427,  0.3094, -0.9241],
        [ 1.1069, -0.5383, -0.9288,  0.0233, -0.4678],
        [-1.2015,  0.6905,  1.6706, -0.1703, -1.3975]],

       [[-0.3048, -1.7181, -0.189 ,  0.6263,  1.1194],
        [ 0.0823, -0.7132, -0.5162,  1.5305, -1.199 ],
        [ 0.5777,  1.2935,  0.1547, -1.3637,  0.4251],
        [ 0.4923,  1.4004,  0.3646,  0.1594, -0.7334]],

       [[ 1.3836, -0.5313,  0.2826,  0.4739, -1.3435],
        [-1.141 , -0.3084,  1.1364,  1.1326,  0.3064],
        [-0.9692,  1.0229, -0.0246,  1.4484, -1.137 ],
        [ 1.7033, -1.8358,  1.2087, -0.5463,  0.5904]]])






array([[-0.5822, -0.3769, -0.1609, -0.0816],
       [-0.0932, -0.1631,  0.2174,  0.3367],
       [ 0.0531,  0.2252,  0.0681,  0.2241]])






array([[  8.8818e-17,   0.0000e+00,  -4.4409e-17,  -8.8818e-17],
       [  0.0000e+00,   0.0000e+00,   2.7756e-17,   8.8818e-17],
       [  4.4409e-17,   5.5511e-17,   4.4409e-17,   0.0000e+00]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demean_axis</span><span class="params">(arr, axis=<span class="number">0</span>)</span>:</span></div><div class="line">    means = arr.mean(axis)</div><div class="line"></div><div class="line">    <span class="comment"># This generalized things like [:, :, np.newaxis] to N dimensions</span></div><div class="line">    indexer = [slice(<span class="keyword">None</span>)] * arr.ndim <span class="comment"># like :</span></div><div class="line">    indexer[axis] = np.newaxis</div><div class="line">    <span class="keyword">return</span> arr - means[indexer]</div></pre></td></tr></table></figure><h3 id="通过广播设置数组的值"><a href="#通过广播设置数组的值" class="headerlink" title="通过广播设置数组的值"></a>通过广播设置数组的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.zeros((<span class="number">4</span>, <span class="number">3</span>))</div><div class="line">arr[:] = <span class="number">5</span></div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">col = np.array([<span class="number">1.28</span>, <span class="number">-0.42</span>, <span class="number">0.44</span>, <span class="number">1.6</span>])</div><div class="line">arr[:] = col[:, np.newaxis]</div><div class="line">arr</div><div class="line">arr[:<span class="number">2</span>] = [[<span class="number">-1.37</span>], [<span class="number">0.509</span>]]</div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([[ 1.28,  1.28,  1.28],
       [-0.42, -0.42, -0.42],
       [ 0.44,  0.44,  0.44],
       [ 1.6 ,  1.6 ,  1.6 ]])






array([[-1.37 , -1.37 , -1.37 ],
       [ 0.509,  0.509,  0.509],
       [ 0.44 ,  0.44 ,  0.44 ],
       [ 1.6  ,  1.6  ,  1.6  ]])
</code></pre><h2 id="ufunc高级应用"><a href="#ufunc高级应用" class="headerlink" title="ufunc高级应用"></a>ufunc高级应用</h2><h3 id="ufunc实例方法"><a href="#ufunc实例方法" class="headerlink" title="ufunc实例方法"></a>ufunc实例方法</h3><p><code>reduce</code>通过一系列的二元运算对其值进行聚合（可指明轴向）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">10</span>)</div><div class="line">np.add.reduce(arr)</div><div class="line">arr.sum()</div></pre></td></tr></table></figure><pre><code>45






45
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.random.seed(<span class="number">12346</span>)</div></pre></td></tr></table></figure><p>这里聚合的是逻辑与操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">5</span>, <span class="number">5</span>)</div><div class="line">arr</div><div class="line">arr[::<span class="number">2</span>].sort(<span class="number">1</span>) <span class="comment"># sort a few rows</span></div><div class="line">arr</div><div class="line">arr[:, :<span class="number">-1</span>] &lt; arr[:, <span class="number">1</span>:]</div><div class="line">np.logical_and.reduce(arr[:, :<span class="number">-1</span>] &lt; arr[:, <span class="number">1</span>:], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>array([[-0.7066,  0.4268, -0.2776, -0.8283, -2.7628],
       [ 0.9835,  0.4378, -0.8496,  0.7188,  0.7329],
       [ 0.5047, -0.7893,  0.5392,  1.2907,  0.8676],
       [ 0.4113,  0.4459, -0.3172, -1.0493,  1.3459],
       [ 0.356 , -0.0915, -0.535 , -0.036 , -0.2591]])






array([[-2.7628, -0.8283, -0.7066, -0.2776,  0.4268],
       [ 0.9835,  0.4378, -0.8496,  0.7188,  0.7329],
       [-0.7893,  0.5047,  0.5392,  0.8676,  1.2907],
       [ 0.4113,  0.4459, -0.3172, -1.0493,  1.3459],
       [-0.535 , -0.2591, -0.0915, -0.036 ,  0.356 ]])






array([[ True,  True,  True,  True],
       [False, False,  True,  True],
       [ True,  True,  True,  True],
       [ True, False, False,  True],
       [ True,  True,  True,  True]], dtype=bool)






array([ True, False,  True, False,  True], dtype=bool)
</code></pre><p>相对于<code>reduce</code>只输出最后结果，<code>accumulate</code>保留中间结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</div><div class="line">np.add.accumulate(arr, axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>array([[ 0,  1,  3,  6, 10],
       [ 5, 11, 18, 26, 35],
       [10, 21, 33, 46, 60]], dtype=int32)
</code></pre><p><code>outer</code>计算两个数组的叉积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">3</span>).repeat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</div><div class="line">arr</div><div class="line">np.multiply.outer(arr, np.arange(<span class="number">5</span>))</div></pre></td></tr></table></figure><pre><code>array([0, 1, 1, 2, 2])






array([[0, 0, 0, 0, 0],
       [0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8],
       [0, 2, 4, 6, 8]])
</code></pre><p><code>outer</code>输出结果的维度是输入两个数组的维度之和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = np.subtract.outer(randn(<span class="number">3</span>, <span class="number">4</span>), randn(<span class="number">5</span>))</div><div class="line">result.shape</div></pre></td></tr></table></figure><pre><code>(3, 4, 5)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">10</span>)</div><div class="line">np.add.reduceat(arr, [<span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>])</div></pre></td></tr></table></figure><pre><code>array([10, 18, 17], dtype=int32)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.multiply.outer(np.arange(<span class="number">4</span>), np.arange(<span class="number">5</span>))</div><div class="line">arr</div><div class="line">np.add.reduceat(arr, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>array([[ 0,  0,  0,  0,  0],
       [ 0,  1,  2,  3,  4],
       [ 0,  2,  4,  6,  8],
       [ 0,  3,  6,  9, 12]])






array([[ 0,  0,  0],
       [ 1,  5,  4],
       [ 2, 10,  8],
       [ 3, 15, 12]], dtype=int32)
</code></pre><h3 id="自定义-ufuncs"><a href="#自定义-ufuncs" class="headerlink" title="自定义 ufuncs"></a>自定义 ufuncs</h3><p>两种不同的调用方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_elements</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">add_them = np.frompyfunc(add_elements, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># 2 input and 1 output</span></div><div class="line">add_them(np.arange(<span class="number">8</span>), np.arange(<span class="number">8</span>))</div></pre></td></tr></table></figure><pre><code>array([0, 2, 4, 6, 8, 10, 12, 14], dtype=object)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add_them = np.vectorize(add_elements, otypes=[np.float64])</div><div class="line">add_them(np.arange(<span class="number">8</span>), np.arange(<span class="number">8</span>))</div></pre></td></tr></table></figure><pre><code>array([  0.,   2.,   4.,   6.,   8.,  10.,  12.,  14.])
</code></pre><p>自己实现的还是比不上内置优化过的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">10000</span>)</div><div class="line">%timeit add_them(arr, arr)</div><div class="line">%timeit np.add(arr, arr)</div></pre></td></tr></table></figure><pre><code>100 loops, best of 3: 1.81 ms per loop
The slowest run took 16.51 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 3.65 µs per loop
</code></pre><h2 id="结构化和记录式数组"><a href="#结构化和记录式数组" class="headerlink" title="结构化和记录式数组"></a>结构化和记录式数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dtype = [(<span class="string">'x'</span>, np.float64), (<span class="string">'y'</span>, np.int32)]</div><div class="line">sarr = np.array([(<span class="number">1.5</span>, <span class="number">6</span>), (np.pi, <span class="number">-2</span>)], dtype=dtype)</div><div class="line">sarr</div></pre></td></tr></table></figure><pre><code>array([(1.5, 6), (3.141592653589793, -2)], 
      dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sarr[<span class="number">0</span>]</div><div class="line">sarr[<span class="number">0</span>][<span class="string">'y'</span>]</div></pre></td></tr></table></figure><pre><code>(1.5, 6)






6
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sarr[<span class="string">'x'</span>]</div></pre></td></tr></table></figure><pre><code>array([ 1.5   ,  3.1416])
</code></pre><h3 id="嵌套dtype和多维字段"><a href="#嵌套dtype和多维字段" class="headerlink" title="嵌套dtype和多维字段"></a>嵌套<code>dtype</code>和多维字段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dtype = [(<span class="string">'x'</span>, np.int64, <span class="number">3</span>), (<span class="string">'y'</span>, np.int32)]</div><div class="line">arr = np.zeros(<span class="number">4</span>, dtype=dtype)</div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([([0, 0, 0], 0), ([0, 0, 0], 0), ([0, 0, 0], 0), ([0, 0, 0], 0)], 
      dtype=[(&#39;x&#39;, &#39;&lt;i8&#39;, (3,)), (&#39;y&#39;, &#39;&lt;i4&#39;)])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr[<span class="number">0</span>][<span class="string">'x'</span>]</div></pre></td></tr></table></figure><pre><code>array([0, 0, 0], dtype=int64)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr[<span class="string">'x'</span>]</div></pre></td></tr></table></figure><pre><code>array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]], dtype=int64)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dtype = [(<span class="string">'x'</span>, [(<span class="string">'a'</span>, <span class="string">'f8'</span>), (<span class="string">'b'</span>, <span class="string">'f4'</span>)]), (<span class="string">'y'</span>, np.int32)]</div><div class="line">data = np.array([((<span class="number">1</span>, <span class="number">2</span>), <span class="number">5</span>), ((<span class="number">3</span>, <span class="number">4</span>), <span class="number">6</span>)], dtype=dtype)</div><div class="line">data[<span class="string">'x'</span>]</div><div class="line">data[<span class="string">'y'</span>]</div><div class="line">data[<span class="string">'x'</span>][<span class="string">'a'</span>]</div></pre></td></tr></table></figure><pre><code>array([(1.0, 2.0), (3.0, 4.0)], 
      dtype=[(&#39;a&#39;, &#39;&lt;f8&#39;), (&#39;b&#39;, &#39;&lt;f4&#39;)])






array([5, 6])






array([ 1.,  3.])
</code></pre><h2 id="更多有关排序的话题"><a href="#更多有关排序的话题" class="headerlink" title="更多有关排序的话题"></a>更多有关排序的话题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">6</span>)</div><div class="line">arr.sort()</div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([-1.3918, -0.2089,  0.2316,  0.728 ,  0.8356,  1.9956])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">3</span>, <span class="number">5</span>)</div><div class="line">arr</div><div class="line">arr[:, <span class="number">0</span>].sort()  <span class="comment"># Sort first column values in-place</span></div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([[ -2.9812e-01,   1.2037e+00,  -1.5768e-02,   7.4395e-01,
          8.6880e-01],
       [ -4.2865e-01,   7.1886e-01,  -1.4510e+00,   1.0510e-01,
         -1.7942e+00],
       [ -2.8792e-04,   6.1168e-01,  -9.1210e-02,  -1.2799e+00,
         -4.0230e-02]])






array([[ -4.2865e-01,   1.2037e+00,  -1.5768e-02,   7.4395e-01,
          8.6880e-01],
       [ -2.9812e-01,   7.1886e-01,  -1.4510e+00,   1.0510e-01,
         -1.7942e+00],
       [ -2.8792e-04,   6.1168e-01,  -9.1210e-02,  -1.2799e+00,
         -4.0230e-02]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">5</span>)</div><div class="line">arr</div><div class="line">np.sort(arr)</div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([-0.9699, -0.5626,  1.1172,  0.2791, -1.1148])






array([-1.1148, -0.9699, -0.5626,  0.2791,  1.1172])






array([-0.9699, -0.5626,  1.1172,  0.2791, -1.1148])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">3</span>, <span class="number">5</span>)</div><div class="line">arr</div><div class="line">arr.sort(axis=<span class="number">1</span>)</div><div class="line">arr</div></pre></td></tr></table></figure><pre><code>array([[ 0.2266,  0.3405,  2.6439, -1.6262, -0.3976],
       [-1.4821,  1.068 , -0.252 , -0.9331,  2.2639],
       [-0.2311,  1.1472,  0.9287, -0.9023,  1.1761]])






array([[-1.6262, -0.3976,  0.2266,  0.3405,  2.6439],
       [-1.4821, -0.9331, -0.252 ,  1.068 ,  2.2639],
       [-0.9023, -0.2311,  0.9287,  1.1472,  1.1761]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr[:, ::<span class="number">-1</span>]</div></pre></td></tr></table></figure><pre><code>array([[ 2.6439,  0.3405,  0.2266, -0.3976, -1.6262],
       [ 2.2639,  1.068 , -0.252 , -0.9331, -1.4821],
       [ 1.1761,  1.1472,  0.9287, -0.2311, -0.9023]])
</code></pre><h3 id="间接排序-argsort-and-lexsort"><a href="#间接排序-argsort-and-lexsort" class="headerlink" title="间接排序: argsort and lexsort"></a>间接排序: argsort and lexsort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">values = np.array([<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>])</div><div class="line">indexer = values.argsort()</div><div class="line">indexer</div><div class="line">values[indexer]</div></pre></td></tr></table></figure><pre><code>array([1, 2, 4, 3, 0], dtype=int64)






array([0, 1, 2, 3, 5])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr = randn(<span class="number">3</span>, <span class="number">5</span>)</div><div class="line">arr[<span class="number">0</span>] = values</div><div class="line">arr</div><div class="line">arr[:, arr[<span class="number">0</span>].argsort()]</div></pre></td></tr></table></figure><pre><code>array([[ 5.    ,  0.    ,  1.    ,  3.    ,  2.    ],
       [ 0.422 ,  0.1187,  1.1352,  1.4363, -1.2487],
       [ 0.1909, -1.0984,  0.7886, -0.5827,  1.1592]])






array([[ 0.    ,  1.    ,  2.    ,  3.    ,  5.    ],
       [ 0.1187,  1.1352, -1.2487,  1.4363,  0.422 ],
       [-1.0984,  0.7886,  1.1592, -0.5827,  0.1909]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">first_name = np.array([<span class="string">'Bob'</span>, <span class="string">'Jane'</span>, <span class="string">'Steve'</span>, <span class="string">'Bill'</span>, <span class="string">'Barbara'</span>])</div><div class="line">last_name = np.array([<span class="string">'Jones'</span>, <span class="string">'Arnold'</span>, <span class="string">'Arnold'</span>, <span class="string">'Jones'</span>, <span class="string">'Walters'</span>])</div><div class="line">sorter = np.lexsort((first_name, last_name))</div><div class="line">zip(last_name[sorter], first_name[sorter])</div></pre></td></tr></table></figure><pre><code>&lt;zip at 0x1d1284f87c8&gt;
</code></pre><h3 id="其他排序算法"><a href="#其他排序算法" class="headerlink" title="其他排序算法"></a>其他排序算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">values = np.array([<span class="string">'2:first'</span>, <span class="string">'2:second'</span>, <span class="string">'1:first'</span>, <span class="string">'1:second'</span>, <span class="string">'1:third'</span>])</div><div class="line">key = np.array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</div><div class="line">indexer = key.argsort(kind=<span class="string">'mergesort'</span>)</div><div class="line">indexer</div><div class="line">values.take(indexer)</div></pre></td></tr></table></figure><pre><code>array([2, 3, 4, 0, 1], dtype=int64)






array([&#39;1:first&#39;, &#39;1:second&#39;, &#39;1:third&#39;, &#39;2:first&#39;, &#39;2:second&#39;], 
      dtype=&#39;&lt;U8&#39;)
</code></pre><h3 id="numpy-searchsorted-在有序数组中查找元素"><a href="#numpy-searchsorted-在有序数组中查找元素" class="headerlink" title="numpy.searchsorted: 在有序数组中查找元素"></a>numpy.searchsorted: 在有序数组中查找元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">15</span>])</div><div class="line">arr.searchsorted(<span class="number">9</span>)</div></pre></td></tr></table></figure><pre><code>3
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.searchsorted([<span class="number">0</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">16</span>])</div></pre></td></tr></table></figure><pre><code>array([0, 3, 3, 5], dtype=int64)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</div><div class="line">arr.searchsorted([<span class="number">0</span>, <span class="number">1</span>])</div><div class="line">arr.searchsorted([<span class="number">0</span>, <span class="number">1</span>], side=<span class="string">'right'</span>)</div></pre></td></tr></table></figure><pre><code>array([0, 3], dtype=int64)






array([3, 7], dtype=int64)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = np.floor(np.random.uniform(<span class="number">0</span>, <span class="number">10000</span>, size=<span class="number">50</span>))</div><div class="line">bins = np.array([<span class="number">0</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">5000</span>, <span class="number">10000</span>])</div><div class="line">data</div></pre></td></tr></table></figure><pre><code>array([  143.,  8957.,   309.,  2349.,  5503.,  2754.,  4408.,  4259.,
        3313.,  3364.,  2492.,  9977.,  4704.,  5538.,  6089.,  5864.,
        6926.,  3677.,  8698.,  1832.,  8931.,  6631.,  5322.,  3712.,
        9350.,  3945.,  9514.,  3683.,  8568.,  8247.,  7087.,  7630.,
        3392.,  8320.,  1973.,   982.,  1672.,  7052.,  6230.,  3894.,
        1832.,  9488.,   755.,  8522.,  1858.,  5417.,  6162.,  7517.,
        9827.,  4458.])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">labels = bins.searchsorted(data)</div><div class="line">labels</div></pre></td></tr></table></figure><pre><code>array([2, 4, 2, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 4, 4, 4, 4, 3, 4, 3, 4, 4, 4,
       3, 4, 3, 4, 3, 4, 4, 4, 4, 3, 4, 3, 2, 3, 4, 4, 3, 3, 4, 2, 4, 3, 4,
       4, 4, 4, 3], dtype=int64)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Series(data).groupby(labels).mean()</div></pre></td></tr></table></figure><pre><code>2     547.250000
3    3178.550000
4    7591.038462
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.digitize(data, bins)</div></pre></td></tr></table></figure><pre><code>array([2, 4, 2, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 4, 4, 4, 4, 3, 4, 3, 4, 4, 4,
       3, 4, 3, 4, 3, 4, 4, 4, 4, 3, 4, 3, 2, 3, 4, 4, 3, 3, 4, 2, 4, 3, 4,
       4, 4, 4, 3], dtype=int64)
</code></pre><h2 id="NumPy-matrix-class"><a href="#NumPy-matrix-class" class="headerlink" title="NumPy matrix class"></a>NumPy matrix class</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">X =  np.array([[ <span class="number">8.82768214</span>,  <span class="number">3.82222409</span>, <span class="number">-1.14276475</span>,  <span class="number">2.04411587</span>],</div><div class="line">               [ <span class="number">3.82222409</span>,  <span class="number">6.75272284</span>,  <span class="number">0.83909108</span>,  <span class="number">2.08293758</span>],</div><div class="line">               [<span class="number">-1.14276475</span>,  <span class="number">0.83909108</span>,  <span class="number">5.01690521</span>,  <span class="number">0.79573241</span>],</div><div class="line">               [ <span class="number">2.04411587</span>,  <span class="number">2.08293758</span>,  <span class="number">0.79573241</span>,  <span class="number">6.24095859</span>]])</div><div class="line">X[:, <span class="number">0</span>]  <span class="comment"># one-dimensional</span></div><div class="line">y = X[:, :<span class="number">1</span>]  <span class="comment"># two-dimensional by slicing</span></div><div class="line">X</div><div class="line">y</div></pre></td></tr></table></figure><pre><code>array([ 8.8277,  3.8222, -1.1428,  2.0441])






array([[ 8.8277,  3.8222, -1.1428,  2.0441],
       [ 3.8222,  6.7527,  0.8391,  2.0829],
       [-1.1428,  0.8391,  5.0169,  0.7957],
       [ 2.0441,  2.0829,  0.7957,  6.241 ]])






array([[ 8.8277],
       [ 3.8222],
       [-1.1428],
       [ 2.0441]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.dot(y.T, np.dot(X, y))</div></pre></td></tr></table></figure><pre><code>array([[ 1195.468]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Xm = np.matrix(X)</div><div class="line">ym = Xm[:, <span class="number">0</span>]</div><div class="line">Xm</div><div class="line">ym</div><div class="line">ym.T * Xm * ym</div></pre></td></tr></table></figure><pre><code>matrix([[ 8.8277,  3.8222, -1.1428,  2.0441],
        [ 3.8222,  6.7527,  0.8391,  2.0829],
        [-1.1428,  0.8391,  5.0169,  0.7957],
        [ 2.0441,  2.0829,  0.7957,  6.241 ]])






matrix([[ 8.8277],
        [ 3.8222],
        [-1.1428],
        [ 2.0441]])






matrix([[ 1195.468]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Xm.I * X</div></pre></td></tr></table></figure><pre><code>matrix([[  1.0000e+00,   6.9616e-17,  -4.0136e-17,   8.1258e-17],
        [ -2.3716e-17,   1.0000e+00,   2.2230e-17,  -2.5721e-17],
        [  1.0957e-16,   5.0783e-18,   1.0000e+00,   7.8658e-18],
        [ -5.7092e-17,  -3.7777e-18,   6.2391e-18,   1.0000e+00]])
</code></pre><h2 id="高级数组输入输出"><a href="#高级数组输入输出" class="headerlink" title="高级数组输入输出"></a>高级数组输入输出</h2><h3 id="内存映像文件"><a href="#内存映像文件" class="headerlink" title="内存映像文件"></a>内存映像文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mmap = np.memmap(<span class="string">'mymmap'</span>, dtype=<span class="string">'float64'</span>, mode=<span class="string">'w+'</span>, shape=(<span class="number">10000</span>, <span class="number">10000</span>))</div><div class="line">mmap</div></pre></td></tr></table></figure><pre><code>memmap([[ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       ..., 
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.],
       [ 0.,  0.,  0., ...,  0.,  0.,  0.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">section = mmap[:<span class="number">5</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">section[:] = np.random.randn(<span class="number">5</span>, <span class="number">10000</span>)</div><div class="line">mmap.flush()</div><div class="line">mmap</div><div class="line"><span class="keyword">del</span> mmap</div></pre></td></tr></table></figure><pre><code>memmap([[-1.273 , -0.1547,  0.7817, ...,  0.3421,  1.0272, -1.8742],
       [-0.3544, -3.1195,  0.1256, ..., -0.4476,  0.4863, -0.8311],
       [-1.1117,  0.8186,  2.3934, ...,  0.1061,  1.4123,  0.6489],
       ..., 
       [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
       [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
       [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mmap = np.memmap(<span class="string">'mymmap'</span>, dtype=<span class="string">'float64'</span>, shape=(<span class="number">10000</span>, <span class="number">10000</span>))</div><div class="line">mmap</div></pre></td></tr></table></figure><pre><code>memmap([[-1.273 , -0.1547,  0.7817, ...,  0.3421,  1.0272, -1.8742],
       [-0.3544, -3.1195,  0.1256, ..., -0.4476,  0.4863, -0.8311],
       [-1.1117,  0.8186,  2.3934, ...,  0.1061,  1.4123,  0.6489],
       ..., 
       [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
       [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
       [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%xdel mmap</div><div class="line">!<span class="keyword">del</span> mymmap</div></pre></td></tr></table></figure><pre><code>NameError: name &#39;mmap&#39; is not defined
C:\Users\Ewan\Downloads\pydata-book-master\mymmap


The process cannot access the file because it is being used by another process.
</code></pre><p>​</p><h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><h3 id="连续内存的重要性"><a href="#连续内存的重要性" class="headerlink" title="连续内存的重要性"></a>连续内存的重要性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr_c = np.ones((<span class="number">1000</span>, <span class="number">1000</span>), order=<span class="string">'C'</span>)</div><div class="line">arr_f = np.ones((<span class="number">1000</span>, <span class="number">1000</span>), order=<span class="string">'F'</span>)</div><div class="line">arr_c.flags</div><div class="line">arr_f.flags</div><div class="line">arr_f.flags.f_contiguous</div></pre></td></tr></table></figure><pre><code>  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False






  C_CONTIGUOUS : False
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False






True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%timeit arr_c.sum(<span class="number">1</span>)</div><div class="line">%timeit arr_f.sum(<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>1000 loops, best of 3: 848 µs per loop
1000 loops, best of 3: 582 µs per loop
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr_f.copy(<span class="string">'C'</span>).flags</div></pre></td></tr></table></figure><pre><code>  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr_c[:<span class="number">50</span>].flags.contiguous</div><div class="line">arr_c[:, :<span class="number">50</span>].flags</div></pre></td></tr></table></figure><pre><code>True






  C_CONTIGUOUS : False
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%xdel arr_c</div><div class="line">%xdel arr_f</div><div class="line">%cd ..</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Downloads
</code></pre><p>​</p><h2 id="其他加速手段-Cython-f2py-C"><a href="#其他加速手段-Cython-f2py-C" class="headerlink" title="其他加速手段: Cython, f2py, C"></a>其他加速手段: Cython, f2py, C</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from numpy cimport ndarray, float64_t</div><div class="line"></div><div class="line">def sum_elements(ndarray[float64_t] arr):</div><div class="line">    cdef Py_ssize_t i, n = len(arr)</div><div class="line">    cdef float64_t result = 0</div><div class="line"></div><div class="line">    for i in range(n):</div><div class="line">        result += arr[i]</div><div class="line"></div><div class="line">    return result</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Numpy高级应用&quot;&gt;&lt;a href=&quot;#Numpy高级应用&quot; class=&quot;headerlink&quot; title=&quot;Numpy高级应用&quot;&gt;&lt;/a&gt;Numpy高级应用&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>GFW Break</title>
    <link href="http://yoursite.com/2017/03/08/GFW-Break/"/>
    <id>http://yoursite.com/2017/03/08/GFW-Break/</id>
    <published>2017-03-08T13:08:27.000Z</published>
    <updated>2017-03-09T03:14:45.841Z</updated>
    
    <content type="html"><![CDATA[<p>（Beta版本， 留待以后完善）</p><hr><h1 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h1><p>百度网盘链接：<a href="http://pan.baidu.com/s/1gftCmd1" target="_blank" rel="external">http://pan.baidu.com/s/1gftCmd1</a></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol><li><p>解压</p></li><li><p>解压后的目录如下：</p><p>​</p></li></ol><p><img src="http://o7ie0tcjk.bkt.clouddn.com/tools/shadowsocks/unzip.png" alt="unzip"></p><ol><li><p>打开软件：</p><p>​</p></li></ol><p><img src="http://o7ie0tcjk.bkt.clouddn.com/tools/shadowsocks/open.png" alt="open"></p><ol><li><p>界面如下：</p><p>​</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/tools/shadowsocks/menu.png" alt="menu"></p><p>​</p><p>​</p></li></ol><p>这里需要填一些东西：</p><ol><li>Server IP</li><li>Server Port</li><li>Password</li></ol><p>具体值（sscat.txt）我放在了网盘里，链接：<a href="http://pan.baidu.com/s/1gftCmd1" target="_blank" rel="external">http://pan.baidu.com/s/1gftCmd1</a></p><ol><li><p>启动软件：</p><p>​</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/tools/shadowsocks/start.png" alt="start"></p><p>​</p></li></ol><p>右键这个小飞机图标（可能你的颜色看起来不一样，是暗蓝色），会出现如下界面：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/tools/shadowsocks/setting.png" alt="setting"></p><p>勾选上第一项，然后将鼠标移到第二项上：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/tools/shadowsocks/pac.png" alt="pac"></p><p>选择PAC模式（这个模式会自动检测你所进入的网站是否需要翻墙，所以选择这个模式就可以了，如果不行的话，勾选下面的Global即可）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（Beta版本， 留待以后完善）&lt;/p&gt;&lt;hr&gt;&lt;h1 id=&quot;软件下载&quot;&gt;&lt;a href=&quot;#软件下载&quot; class=&quot;headerlink&quot; title=&quot;软件下载&quot;&gt;&lt;/a&gt;软件下载&lt;/h1&gt;&lt;p&gt;百度网盘链接：&lt;a href=&quot;http://pan.baidu.co
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>python data analysis learning note Ch10</title>
    <link href="http://yoursite.com/2017/03/08/python-data-analysis-learning-note-Ch10/"/>
    <id>http://yoursite.com/2017/03/08/python-data-analysis-learning-note-Ch10/</id>
    <published>2017-03-08T09:16:30.000Z</published>
    <updated>2017-03-08T09:24:48.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">pd.options.display.max_rows = <span class="number">12</span></div><div class="line">np.set_printoptions(precision=<span class="number">4</span>, suppress=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>))</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div></pre></td></tr></table></figure><h2 id="日期和时间数据类型及工具"><a href="#日期和时间数据类型及工具" class="headerlink" title="日期和时间数据类型及工具"></a>日期和时间数据类型及工具</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line">now = datetime.now()</div><div class="line">now</div></pre></td></tr></table></figure><pre><code>datetime.datetime(2017, 3, 8, 14, 47, 50, 32019)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now.year, now.month, now.day</div></pre></td></tr></table></figure><pre><code>(2017, 3, 8)
</code></pre><p>返回值（天数，秒数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">15</span>)</div><div class="line">delta</div></pre></td></tr></table></figure><pre><code>datetime.timedelta(926, 56700)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delta.days</div></pre></td></tr></table></figure><pre><code>926
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delta.seconds</div></pre></td></tr></table></figure><pre><code>56700
</code></pre><p><code>timedelta</code> 天数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</div><div class="line">start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</div><div class="line">start + timedelta(<span class="number">12</span>)</div></pre></td></tr></table></figure><pre><code>datetime.datetime(2011, 1, 19, 0, 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start - <span class="number">2</span> * timedelta(<span class="number">12</span>)</div></pre></td></tr></table></figure><pre><code>datetime.datetime(2010, 12, 14, 0, 0)
</code></pre><h3 id="字符串和datatime的相互转换"><a href="#字符串和datatime的相互转换" class="headerlink" title="字符串和datatime的相互转换"></a>字符串和<code>datatime</code>的相互转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><p>使用<code>str</code>直接转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str(stamp)</div></pre></td></tr></table></figure><pre><code>&#39;2011-01-03 00:00:00&#39;
</code></pre><p>格式化转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp.strftime(<span class="string">'%Y-%m-%d'</span>)</div></pre></td></tr></table></figure><pre><code>&#39;2011-01-03&#39;
</code></pre><p>逆转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value = <span class="string">'2011-01-03'</span></div><div class="line">datetime.strptime(value, <span class="string">'%Y-%m-%d'</span>)</div></pre></td></tr></table></figure><pre><code>datetime.datetime(2011, 1, 3, 0, 0)
</code></pre><p>批量转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">datestrs = [<span class="string">'7/6/2011'</span>, <span class="string">'8/6/2011'</span>]</div><div class="line">[datetime.strptime(x, <span class="string">'%m/%d/%Y'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> datestrs]</div></pre></td></tr></table></figure><pre><code>[datetime.datetime(2011, 7, 6, 0, 0), datetime.datetime(2011, 8, 6, 0, 0)]
</code></pre><p>总是写格式很麻烦，直接调用<code>parser</code>解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</div><div class="line">parse(<span class="string">'2011-01-03'</span>)</div></pre></td></tr></table></figure><pre><code>datetime.datetime(2011, 1, 3, 0, 0)
</code></pre><p>可以解析任意格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parse(<span class="string">'Jan 31, 1997 10:45 PM'</span>)</div></pre></td></tr></table></figure><pre><code>datetime.datetime(1997, 1, 31, 22, 45)
</code></pre><p>指定格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parse(<span class="string">'6/12/2011'</span>, dayfirst=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>datetime.datetime(2011, 12, 6, 0, 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">datestrs</div></pre></td></tr></table></figure><pre><code>[&#39;7/6/2011&#39;, &#39;8/6/2011&#39;]
</code></pre><p><code>pandas</code>的<code>API</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pd.to_datetime(datestrs)</div><div class="line"><span class="comment"># note: output changed (no '00:00:00' anymore)</span></div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2011-07-06&#39;, &#39;2011-08-06&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)
</code></pre><p><code>None</code>也可以转换，只不过会变成缺失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">idx = pd.to_datetime(datestrs + [<span class="keyword">None</span>])</div><div class="line">idx</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2011-07-06&#39;, &#39;2011-08-06&#39;, &#39;NaT&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">idx[<span class="number">2</span>]</div></pre></td></tr></table></figure><pre><code>NaT
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.isnull(idx)</div></pre></td></tr></table></figure><pre><code>array([False, False,  True], dtype=bool)
</code></pre><h2 id="时间序列基础"><a href="#时间序列基础" class="headerlink" title="时间序列基础"></a>时间序列基础</h2><p>将行索引变成时间类型，也就是时间戳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line">dates = [datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">5</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>),</div><div class="line">         datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">8</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">10</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">12</span>)]</div><div class="line">ts = Series(np.random.randn(<span class="number">6</span>), index=dates)</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2011-01-02   -0.296854
2011-01-05   -1.968663
2011-01-07   -0.484492
2011-01-08   -0.517927
2011-01-10   -0.348697
2011-01-12    0.102276
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type(ts)</div><div class="line"><span class="comment"># note: output changed to "pandas.core.series.Series"</span></div></pre></td></tr></table></figure><pre><code>pandas.core.series.Series
</code></pre><p>拥有一个特定的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.index</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;, &#39;2011-01-08&#39;,
               &#39;2011-01-10&#39;, &#39;2011-01-12&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)
</code></pre><p>可以直接进行加法运算，相同的时间戳会进行匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts + ts[::<span class="number">2</span>]</div></pre></td></tr></table></figure><pre><code>2011-01-02   -0.593708
2011-01-05         NaN
2011-01-07   -0.968984
2011-01-08         NaN
2011-01-10   -0.697394
2011-01-12         NaN
dtype: float64
</code></pre><p>以纳秒形式存储时间戳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts.index.dtype</div><div class="line"><span class="comment"># note: output changed from dtype('datetime64[ns]') to dtype('&lt;M8[ns]')</span></div></pre></td></tr></table></figure><pre><code>dtype(&#39;&lt;M8[ns]&#39;)
</code></pre><p>行索引就会变成时间戳类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stamp = ts.index[<span class="number">0</span>]</div><div class="line">stamp</div><div class="line"><span class="comment"># note: output changed from &lt;Timestamp: 2011-01-02 00:00:00&gt; to Timestamp('2011-01-02 00:00:00')</span></div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-01-02 00:00:00&#39;)
</code></pre><h3 id="索引、选取、子集构造"><a href="#索引、选取、子集构造" class="headerlink" title="索引、选取、子集构造"></a>索引、选取、子集构造</h3><p>时间戳索引与正常索引行为一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp = ts.index[<span class="number">2</span>]</div><div class="line">ts[stamp]</div></pre></td></tr></table></figure><pre><code>-0.4844920247591406
</code></pre><p>可以直接通过传入与行索引相匹配的时间戳进行索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[<span class="string">'1/10/2011'</span>]</div></pre></td></tr></table></figure><pre><code>-0.34869693931763396
</code></pre><p>换个格式也可以，会自动转换为<code>datatime</code>，只要最后转换成的时间戳是相同的，任意格式都可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[<span class="string">'20110110'</span>]</div></pre></td></tr></table></figure><pre><code>-0.34869693931763396
</code></pre><p>通过<code>periods</code>参数来指定往后顺延的时间长短</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">longer_ts = Series(np.random.randn(<span class="number">1000</span>),</div><div class="line">                   index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">1000</span>))</div><div class="line">longer_ts</div></pre></td></tr></table></figure><pre><code>2000-01-01    0.871808
2000-01-02   -0.025158
2000-01-03    0.132813
2000-01-04   -2.006494
2000-01-05   -0.988423
2000-01-06    0.775930
                ...   
2002-09-21   -0.186519
2002-09-22    0.881745
2002-09-23   -1.335826
2002-09-24    0.418774
2002-09-25    0.970405
2002-09-26    0.636320
Freq: D, dtype: float64
</code></pre><p>时间戳的特殊之处在于可以进行年份以及月份等的选取，相当于一个多维索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">longer_ts[<span class="string">'2001'</span>]</div></pre></td></tr></table></figure><pre><code>2001-01-01   -1.799866
2001-01-02    0.499890
2001-01-03   -0.409970
2001-01-04   -0.808111
2001-01-05   -1.220433
2001-01-06    0.581235
                ...   
2001-12-26   -0.312186
2001-12-27   -0.804940
2001-12-28   -0.572741
2001-12-29   -0.175605
2001-12-30    0.693675
2001-12-31   -0.196274
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">longer_ts[<span class="string">'2001-05'</span>]</div></pre></td></tr></table></figure><pre><code>2001-05-01   -2.783535
2001-05-02    1.386292
2001-05-03    0.153705
2001-05-04   -0.571590
2001-05-05   -0.933012
2001-05-06    0.579244
                ...   
2001-05-26    0.080809
2001-05-27    0.652650
2001-05-28    0.862616
2001-05-29   -0.967580
2001-05-30    0.907069
2001-05-31    0.551137
Freq: D, dtype: float64
</code></pre><p>同样可以进行切片，只不过是按照时间的先后度量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</div></pre></td></tr></table></figure><pre><code>2011-01-07   -0.484492
2011-01-08   -0.517927
2011-01-10   -0.348697
2011-01-12    0.102276
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2011-01-02   -0.296854
2011-01-05   -1.968663
2011-01-07   -0.484492
2011-01-08   -0.517927
2011-01-10   -0.348697
2011-01-12    0.102276
dtype: float64
</code></pre><p>而且切片不需要进行索引匹配，只需要指定时间范围即可切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[<span class="string">'1/6/2011'</span>:<span class="string">'1/11/2011'</span>]</div></pre></td></tr></table></figure><pre><code>2011-01-07   -0.484492
2011-01-08   -0.517927
2011-01-10   -0.348697
dtype: float64
</code></pre><p>一个可以实现同样功能的内置方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.truncate(after=<span class="string">'1/9/2011'</span>)</div></pre></td></tr></table></figure><pre><code>2011-01-02   -0.296854
2011-01-05   -1.968663
2011-01-07   -0.484492
2011-01-08   -0.517927
dtype: float64
</code></pre><p>这里的<code>freq</code>参数指定了选取的频率，这里的是每一个星期三</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dates = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">100</span>, freq=<span class="string">'W-WED'</span>)</div><div class="line">long_df = DataFrame(np.random.randn(<span class="number">100</span>, <span class="number">4</span>),</div><div class="line">                    index=dates,</div><div class="line">                    columns=[<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</div><div class="line">long_df.ix[<span class="string">'5-2001'</span>]</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2001-05-02</th><td>0.506207</td><td>-1.116218</td><td>0.656575</td><td>0.212606</td></tr><tr><th>2001-05-09</th><td>-1.306963</td><td>-0.054373</td><td>-1.165053</td><td>-1.319361</td></tr><tr><th>2001-05-16</th><td>0.891692</td><td>-0.463900</td><td>1.642267</td><td>0.644972</td></tr><tr><th>2001-05-23</th><td>-0.025283</td><td>2.363886</td><td>-0.367988</td><td>0.827882</td></tr><tr><th>2001-05-30</th><td>-1.501301</td><td>-2.534553</td><td>0.256369</td><td>0.268207</td></tr></tbody></table></div><h3 id="带有重复索引的时间序列"><a href="#带有重复索引的时间序列" class="headerlink" title="带有重复索引的时间序列"></a>带有重复索引的时间序列</h3><p>直接创建时间戳索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dates = pd.DatetimeIndex([<span class="string">'1/1/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>,</div><div class="line">                          <span class="string">'1/3/2000'</span>])</div><div class="line">dup_ts = Series(np.arange(<span class="number">5</span>), index=dates)</div><div class="line">dup_ts</div></pre></td></tr></table></figure><pre><code>2000-01-01    0
2000-01-02    1
2000-01-02    2
2000-01-02    3
2000-01-03    4
dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup_ts.index.is_unique</div></pre></td></tr></table></figure><pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup_ts[<span class="string">'1/3/2000'</span>]  <span class="comment"># not duplicated</span></div></pre></td></tr></table></figure><pre><code>4
</code></pre><p>如果有重复的时间索引，则会将满足条件的全部输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup_ts[<span class="string">'1/2/2000'</span>]  <span class="comment"># duplicated</span></div></pre></td></tr></table></figure><pre><code>2000-01-02    1
2000-01-02    2
2000-01-02    3
dtype: int32
</code></pre><p>因此可以直接根据时间戳进行索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = dup_ts.groupby(level=<span class="number">0</span>)</div><div class="line">grouped.mean()</div></pre></td></tr></table></figure><pre><code>2000-01-01    0
2000-01-02    2
2000-01-03    4
dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.count()</div></pre></td></tr></table></figure><pre><code>2000-01-01    1
2000-01-02    3
2000-01-03    1
dtype: int64
</code></pre><h2 id="日期的范围、频率以及移动"><a href="#日期的范围、频率以及移动" class="headerlink" title="日期的范围、频率以及移动"></a>日期的范围、频率以及移动</h2><p><code>pandas</code>中的时间序列一般被认为是不规则的，也就是说没有固定的频率。但是有时候需要以某种相对固定的频率进行分析，比如每日、每月、每15分钟等（这样自然会在时间序列中引入缺失值）。<code>pandas</code>拥有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2011-01-02   -0.296854
2011-01-05   -1.968663
2011-01-07   -0.484492
2011-01-08   -0.517927
2011-01-10   -0.348697
2011-01-12    0.102276
dtype: float64
</code></pre><p>例如，我们可以将之前那个时间序列转换为一个具有固定频率（每日）的时间序列。只需要调用resample即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'D'</span>).mean()</div></pre></td></tr></table></figure><pre><code>2011-01-02   -0.296854
2011-01-03         NaN
2011-01-04         NaN
2011-01-05   -1.968663
2011-01-06         NaN
2011-01-07   -0.484492
2011-01-08   -0.517927
2011-01-09         NaN
2011-01-10   -0.348697
2011-01-11         NaN
2011-01-12    0.102276
Freq: D, dtype: float64
</code></pre><h3 id="生成日期范围"><a href="#生成日期范围" class="headerlink" title="生成日期范围"></a>生成日期范围</h3><p><code>data_range</code>函数， 指定始末</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">index = pd.date_range(<span class="string">'4/1/2012'</span>, <span class="string">'6/1/2012'</span>)</div><div class="line">index</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-04-01&#39;, &#39;2012-04-02&#39;, &#39;2012-04-03&#39;, &#39;2012-04-04&#39;,
               &#39;2012-04-05&#39;, &#39;2012-04-06&#39;, &#39;2012-04-07&#39;, &#39;2012-04-08&#39;,
               &#39;2012-04-09&#39;, &#39;2012-04-10&#39;, &#39;2012-04-11&#39;, &#39;2012-04-12&#39;,
               &#39;2012-04-13&#39;, &#39;2012-04-14&#39;, &#39;2012-04-15&#39;, &#39;2012-04-16&#39;,
               &#39;2012-04-17&#39;, &#39;2012-04-18&#39;, &#39;2012-04-19&#39;, &#39;2012-04-20&#39;,
               &#39;2012-04-21&#39;, &#39;2012-04-22&#39;, &#39;2012-04-23&#39;, &#39;2012-04-24&#39;,
               &#39;2012-04-25&#39;, &#39;2012-04-26&#39;, &#39;2012-04-27&#39;, &#39;2012-04-28&#39;,
               &#39;2012-04-29&#39;, &#39;2012-04-30&#39;, &#39;2012-05-01&#39;, &#39;2012-05-02&#39;,
               &#39;2012-05-03&#39;, &#39;2012-05-04&#39;, &#39;2012-05-05&#39;, &#39;2012-05-06&#39;,
               &#39;2012-05-07&#39;, &#39;2012-05-08&#39;, &#39;2012-05-09&#39;, &#39;2012-05-10&#39;,
               &#39;2012-05-11&#39;, &#39;2012-05-12&#39;, &#39;2012-05-13&#39;, &#39;2012-05-14&#39;,
               &#39;2012-05-15&#39;, &#39;2012-05-16&#39;, &#39;2012-05-17&#39;, &#39;2012-05-18&#39;,
               &#39;2012-05-19&#39;, &#39;2012-05-20&#39;, &#39;2012-05-21&#39;, &#39;2012-05-22&#39;,
               &#39;2012-05-23&#39;, &#39;2012-05-24&#39;, &#39;2012-05-25&#39;, &#39;2012-05-26&#39;,
               &#39;2012-05-27&#39;, &#39;2012-05-28&#39;, &#39;2012-05-29&#39;, &#39;2012-05-30&#39;,
               &#39;2012-05-31&#39;, &#39;2012-06-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
</code></pre><p>只指定起始， 以及长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(start=<span class="string">'4/1/2012'</span>, periods=<span class="number">20</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-04-01&#39;, &#39;2012-04-02&#39;, &#39;2012-04-03&#39;, &#39;2012-04-04&#39;,
               &#39;2012-04-05&#39;, &#39;2012-04-06&#39;, &#39;2012-04-07&#39;, &#39;2012-04-08&#39;,
               &#39;2012-04-09&#39;, &#39;2012-04-10&#39;, &#39;2012-04-11&#39;, &#39;2012-04-12&#39;,
               &#39;2012-04-13&#39;, &#39;2012-04-14&#39;, &#39;2012-04-15&#39;, &#39;2012-04-16&#39;,
               &#39;2012-04-17&#39;, &#39;2012-04-18&#39;, &#39;2012-04-19&#39;, &#39;2012-04-20&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
</code></pre><p>只指定结尾，以及长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(end=<span class="string">'6/1/2012'</span>, periods=<span class="number">20</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-05-13&#39;, &#39;2012-05-14&#39;, &#39;2012-05-15&#39;, &#39;2012-05-16&#39;,
               &#39;2012-05-17&#39;, &#39;2012-05-18&#39;, &#39;2012-05-19&#39;, &#39;2012-05-20&#39;,
               &#39;2012-05-21&#39;, &#39;2012-05-22&#39;, &#39;2012-05-23&#39;, &#39;2012-05-24&#39;,
               &#39;2012-05-25&#39;, &#39;2012-05-26&#39;, &#39;2012-05-27&#39;, &#39;2012-05-28&#39;,
               &#39;2012-05-29&#39;, &#39;2012-05-30&#39;, &#39;2012-05-31&#39;, &#39;2012-06-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
</code></pre><p>指定始末，以及采样频率， <code>BM = business end of month</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'1/1/2000'</span>, <span class="string">'12/1/2000'</span>, freq=<span class="string">'BM'</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2000-01-31&#39;, &#39;2000-02-29&#39;, &#39;2000-03-31&#39;, &#39;2000-04-28&#39;,
               &#39;2000-05-31&#39;, &#39;2000-06-30&#39;, &#39;2000-07-31&#39;, &#39;2000-08-31&#39;,
               &#39;2000-09-29&#39;, &#39;2000-10-31&#39;, &#39;2000-11-30&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BM&#39;)
</code></pre><p>默认peroids指的是天数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'5/2/2012 12:56:31'</span>, periods=<span class="number">5</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-05-02 12:56:31&#39;, &#39;2012-05-03 12:56:31&#39;,
               &#39;2012-05-04 12:56:31&#39;, &#39;2012-05-05 12:56:31&#39;,
               &#39;2012-05-06 12:56:31&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
</code></pre><p>可以省略时间戳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'5/2/2012 12:56:31'</span>, periods=<span class="number">5</span>, normalize=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-05-02&#39;, &#39;2012-05-03&#39;, &#39;2012-05-04&#39;, &#39;2012-05-05&#39;,
               &#39;2012-05-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
</code></pre><h3 id="频率和日期偏移量"><a href="#频率和日期偏移量" class="headerlink" title="频率和日期偏移量"></a>频率和日期偏移量</h3><p>偏移量可以采用特定单位的时间对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</div><div class="line">hour = Hour()</div><div class="line">hour</div></pre></td></tr></table></figure><pre><code>&lt;Hour&gt;
</code></pre><p>4个小时，简单粗暴</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">four_hours = Hour(<span class="number">4</span>)</div><div class="line">four_hours</div></pre></td></tr></table></figure><pre><code>&lt;4 * Hours&gt;
</code></pre><p>每隔四个小时进行采样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'1/1/2000'</span>, <span class="string">'1/3/2000 23:59'</span>, freq=<span class="string">'4h'</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 04:00:00&#39;,
               &#39;2000-01-01 08:00:00&#39;, &#39;2000-01-01 12:00:00&#39;,
               &#39;2000-01-01 16:00:00&#39;, &#39;2000-01-01 20:00:00&#39;,
               &#39;2000-01-02 00:00:00&#39;, &#39;2000-01-02 04:00:00&#39;,
               &#39;2000-01-02 08:00:00&#39;, &#39;2000-01-02 12:00:00&#39;,
               &#39;2000-01-02 16:00:00&#39;, &#39;2000-01-02 20:00:00&#39;,
               &#39;2000-01-03 00:00:00&#39;, &#39;2000-01-03 04:00:00&#39;,
               &#39;2000-01-03 08:00:00&#39;, &#39;2000-01-03 12:00:00&#39;,
               &#39;2000-01-03 16:00:00&#39;, &#39;2000-01-03 20:00:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;4H&#39;)
</code></pre><p>两个半小时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>)</div></pre></td></tr></table></figure><pre><code>&lt;150 * Minutes&gt;
</code></pre><p>也可以直接使用这种类似于自然语言的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">10</span>, freq=<span class="string">'1h30min'</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2000-01-01 00:00:00&#39;, &#39;2000-01-01 01:30:00&#39;,
               &#39;2000-01-01 03:00:00&#39;, &#39;2000-01-01 04:30:00&#39;,
               &#39;2000-01-01 06:00:00&#39;, &#39;2000-01-01 07:30:00&#39;,
               &#39;2000-01-01 09:00:00&#39;, &#39;2000-01-01 10:30:00&#39;,
               &#39;2000-01-01 12:00:00&#39;, &#39;2000-01-01 13:30:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;90T&#39;)
</code></pre><h4 id="Week-of-month-dates-（WOM日期）"><a href="#Week-of-month-dates-（WOM日期）" class="headerlink" title="Week of month dates （WOM日期）"></a>Week of month dates （WOM日期）</h4><p>每月第三个星期五</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/1/2012'</span>, <span class="string">'9/1/2012'</span>, freq=<span class="string">'WOM-3FRI'</span>)</div><div class="line">list(rng)</div></pre></td></tr></table></figure><pre><code>[Timestamp(&#39;2012-01-20 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;),
 Timestamp(&#39;2012-02-17 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;),
 Timestamp(&#39;2012-03-16 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;),
 Timestamp(&#39;2012-04-20 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;),
 Timestamp(&#39;2012-05-18 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;),
 Timestamp(&#39;2012-06-15 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;),
 Timestamp(&#39;2012-07-20 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;),
 Timestamp(&#39;2012-08-17 00:00:00&#39;, offset=&#39;WOM-3FRI&#39;)]
</code></pre><h3 id="移动（超前或滞后）数据"><a href="#移动（超前或滞后）数据" class="headerlink" title="移动（超前或滞后）数据"></a>移动（超前或滞后）数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ts = Series(np.random.randn(<span class="number">4</span>),</div><div class="line">            index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">4</span>, freq=<span class="string">'M'</span>))</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2000-01-31    1.294798
2000-02-29   -1.907732
2000-03-31   -1.407750
2000-04-30    0.544825
Freq: M, dtype: float64
</code></pre><p>整体数据前移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">2</span>)</div></pre></td></tr></table></figure><pre><code>2000-01-31         NaN
2000-02-29         NaN
2000-03-31    1.294798
2000-04-30   -1.907732
Freq: M, dtype: float64
</code></pre><p>整体数据后移，有点类似于位运算中的移位操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">-2</span>)</div></pre></td></tr></table></figure><pre><code>2000-01-31   -1.407750
2000-02-29    0.544825
2000-03-31         NaN
2000-04-30         NaN
Freq: M, dtype: float64
</code></pre><p>移位之后数据对齐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts / ts.shift(<span class="number">1</span>) - <span class="number">1</span></div></pre></td></tr></table></figure><pre><code>2000-01-31         NaN
2000-02-29   -2.473382
2000-03-31   -0.262082
2000-04-30   -1.387018
Freq: M, dtype: float64
</code></pre><p>加入<code>freq</code>之后就是在行索引上进行时间前移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">2</span>, freq=<span class="string">'M'</span>)</div></pre></td></tr></table></figure><pre><code>2000-03-31    1.294798
2000-04-30   -1.907732
2000-05-31   -1.407750
2000-06-30    0.544825
Freq: M, dtype: float64
</code></pre><p>在天数上进行前移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">3</span>, freq=<span class="string">'D'</span>)</div></pre></td></tr></table></figure><pre><code>2000-02-03    1.294798
2000-03-03   -1.907732
2000-04-03   -1.407750
2000-05-03    0.544825
dtype: float64
</code></pre><p>另一种实现方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">1</span>, freq=<span class="string">'3D'</span>)</div></pre></td></tr></table></figure><pre><code>2000-02-03    1.294798
2000-03-03   -1.907732
2000-04-03   -1.407750
2000-05-03    0.544825
dtype: float64
</code></pre><p>换一个频率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">1</span>, freq=<span class="string">'90T'</span>)</div></pre></td></tr></table></figure><pre><code>2000-01-31 01:30:00    1.294798
2000-02-29 01:30:00   -1.907732
2000-03-31 01:30:00   -1.407750
2000-04-30 01:30:00    0.544825
Freq: M, dtype: float64
</code></pre><h4 id="通过偏移量对日期进行位移"><a href="#通过偏移量对日期进行位移" class="headerlink" title="通过偏移量对日期进行位移"></a>通过偏移量对日期进行位移</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</div><div class="line">now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</div><div class="line">now + <span class="number">3</span> * Day()</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-11-20 00:00:00&#39;)
</code></pre><p>直接移位到月末，是一个相对位移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now + MonthEnd()</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-11-30 00:00:00&#39;)
</code></pre><p>传入的参数表示第几个月的月末</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now + MonthEnd(<span class="number">2</span>)</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-12-31 00:00:00&#39;)
</code></pre><p>换一种方式实现，“主语”不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">offset = MonthEnd()</div><div class="line">offset.rollforward(now)</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-11-30 00:00:00&#39;)
</code></pre><p>往回走，上一个月的月末</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">offset.rollback(now)</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-10-31 00:00:00&#39;)
</code></pre><p>对日期进行移位之后分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ts = Series(np.random.randn(<span class="number">20</span>),</div><div class="line">            index=pd.date_range(<span class="string">'1/15/2000'</span>, periods=<span class="number">20</span>, freq=<span class="string">'4d'</span>))</div><div class="line">ts.groupby(offset.rollforward).mean()</div></pre></td></tr></table></figure><pre><code>2000-01-31   -0.610639
2000-02-29    0.029121
2000-03-31   -0.089587
dtype: float64
</code></pre><p>另一种方式也可以达到相同的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'M'</span>, how=<span class="string">'mean'</span>)</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: how in .resample() is deprecated
the new syntax is .resample(...).mean()
  if __name__ == &#39;__main__&#39;:





2000-01-31   -0.610639
2000-02-29    0.029121
2000-03-31   -0.089587
Freq: M, dtype: float64
</code></pre><h2 id="时区处理"><a href="#时区处理" class="headerlink" title="时区处理"></a>时区处理</h2><p>显示一些时区</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pytz</div><div class="line">pytz.common_timezones[<span class="number">-5</span>:]</div></pre></td></tr></table></figure><pre><code>[&#39;US/Eastern&#39;, &#39;US/Hawaii&#39;, &#39;US/Mountain&#39;, &#39;US/Pacific&#39;, &#39;UTC&#39;]
</code></pre><p>显示某个时区的具体信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tz = pytz.timezone(<span class="string">'US/Eastern'</span>)</div><div class="line">tz</div></pre></td></tr></table></figure><pre><code>&lt;DstTzInfo &#39;US/Eastern&#39; LMT-1 day, 19:04:00 STD&gt;
</code></pre><h3 id="本地化和转换"><a href="#本地化和转换" class="headerlink" title="本地化和转换"></a>本地化和转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">6</span>, freq=<span class="string">'D'</span>)</div><div class="line">ts = Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2012-03-09 09:30:00    0.065144
2012-03-10 09:30:00   -0.391505
2012-03-11 09:30:00    1.207495
2012-03-12 09:30:00    1.516354
2012-03-13 09:30:00   -0.253149
2012-03-14 09:30:00   -0.768138
Freq: D, dtype: float64
</code></pre><p>没有指定时区的时候默认时区为None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(ts.index.tz)</div></pre></td></tr></table></figure><pre><code>None
</code></pre><p>​</p><p>指定时区</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'D'</span>, tz=<span class="string">'UTC'</span>)</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-03-09 09:30:00+00:00&#39;, &#39;2012-03-10 09:30:00+00:00&#39;,
               &#39;2012-03-11 09:30:00+00:00&#39;, &#39;2012-03-12 09:30:00+00:00&#39;,
               &#39;2012-03-13 09:30:00+00:00&#39;, &#39;2012-03-14 09:30:00+00:00&#39;,
               &#39;2012-03-15 09:30:00+00:00&#39;, &#39;2012-03-16 09:30:00+00:00&#39;,
               &#39;2012-03-17 09:30:00+00:00&#39;, &#39;2012-03-18 09:30:00+00:00&#39;],
              dtype=&#39;datetime64[ns, UTC]&#39;, freq=&#39;D&#39;)
</code></pre><p>进行时区的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts_utc = ts.tz_localize(<span class="string">'UTC'</span>)</div><div class="line">ts_utc</div></pre></td></tr></table></figure><pre><code>2012-03-09 09:30:00+00:00    0.065144
2012-03-10 09:30:00+00:00   -0.391505
2012-03-11 09:30:00+00:00    1.207495
2012-03-12 09:30:00+00:00    1.516354
2012-03-13 09:30:00+00:00   -0.253149
2012-03-14 09:30:00+00:00   -0.768138
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts_utc.index</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-03-09 09:30:00+00:00&#39;, &#39;2012-03-10 09:30:00+00:00&#39;,
               &#39;2012-03-11 09:30:00+00:00&#39;, &#39;2012-03-12 09:30:00+00:00&#39;,
               &#39;2012-03-13 09:30:00+00:00&#39;, &#39;2012-03-14 09:30:00+00:00&#39;],
              dtype=&#39;datetime64[ns, UTC]&#39;, freq=&#39;D&#39;)
</code></pre><p>继续转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts_utc.tz_convert(<span class="string">'US/Eastern'</span>)</div></pre></td></tr></table></figure><pre><code>2012-03-09 04:30:00-05:00    0.065144
2012-03-10 04:30:00-05:00   -0.391505
2012-03-11 05:30:00-04:00    1.207495
2012-03-12 05:30:00-04:00    1.516354
2012-03-13 05:30:00-04:00   -0.253149
2012-03-14 05:30:00-04:00   -0.768138
Freq: D, dtype: float64
</code></pre><p>依旧是转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts_eastern = ts.tz_localize(<span class="string">'US/Eastern'</span>)</div><div class="line">ts_eastern.tz_convert(<span class="string">'UTC'</span>)</div></pre></td></tr></table></figure><pre><code>2012-03-09 14:30:00+00:00    0.065144
2012-03-10 14:30:00+00:00   -0.391505
2012-03-11 13:30:00+00:00    1.207495
2012-03-12 13:30:00+00:00    1.516354
2012-03-13 13:30:00+00:00   -0.253149
2012-03-14 13:30:00+00:00   -0.768138
Freq: D, dtype: float64
</code></pre><p>转转转</p><p>ts_eastern.tz_convert(‘Europe/Berlin’)</p><p>转换之前必须要进行本地化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.index.tz_localize(<span class="string">'Asia/Shanghai'</span>)</div></pre></td></tr></table></figure><h3 id="操作时区意识型TimeStamp对象"><a href="#操作时区意识型TimeStamp对象" class="headerlink" title="操作时区意识型TimeStamp对象"></a>操作时区意识型<code>TimeStamp</code>对象</h3><p>初始化时间戳，本地化，时区转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stamp = pd.Timestamp(<span class="string">'2011-03-12 04:00'</span>)</div><div class="line">stamp_utc = stamp.tz_localize(<span class="string">'utc'</span>)</div><div class="line">stamp_utc.tz_convert(<span class="string">'US/Eastern'</span>)</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-03-11 23:00:00-0500&#39;, tz=&#39;US/Eastern&#39;)
</code></pre><p>显式地初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp_moscow = pd.Timestamp(<span class="string">'2011-03-12 04:00'</span>, tz=<span class="string">'Europe/Moscow'</span>)</div><div class="line">stamp_moscow</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2011-03-12 04:00:00+0300&#39;, tz=&#39;Europe/Moscow&#39;)
</code></pre><p>自1970年1月1日起计算的纳秒数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp_utc.value</div></pre></td></tr></table></figure><pre><code>1299902400000000000
</code></pre><p>这个值是绝对的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp_utc.tz_convert(<span class="string">'US/Eastern'</span>).value</div></pre></td></tr></table></figure><pre><code>1299902400000000000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 30 minutes before DST transition</span></div><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour</div><div class="line">stamp = pd.Timestamp(<span class="string">'2012-03-12 01:30'</span>, tz=<span class="string">'US/Eastern'</span>)</div><div class="line">stamp</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2012-03-12 01:30:00-0400&#39;, tz=&#39;US/Eastern&#39;)
</code></pre><p>进行时间的位移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp + Hour()</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2012-03-12 02:30:00-0400&#39;, tz=&#39;US/Eastern&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 90 minutes before DST transition</span></div><div class="line">stamp = pd.Timestamp(<span class="string">'2012-11-04 00:30'</span>, tz=<span class="string">'US/Eastern'</span>)</div><div class="line">stamp</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2012-11-04 00:30:00-0400&#39;, tz=&#39;US/Eastern&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp + <span class="number">2</span> * Hour()</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2012-11-04 01:30:00-0500&#39;, tz=&#39;US/Eastern&#39;)
</code></pre><h3 id="不同时区之间的运算"><a href="#不同时区之间的运算" class="headerlink" title="不同时区之间的运算"></a>不同时区之间的运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'3/7/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'B'</span>)</div><div class="line">ts = Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2012-03-07 09:30:00   -0.461750
2012-03-08 09:30:00    0.947394
2012-03-09 09:30:00    0.703239
2012-03-12 09:30:00    0.266519
2012-03-13 09:30:00    0.302334
2012-03-14 09:30:00   -0.000725
2012-03-15 09:30:00    0.305446
2012-03-16 09:30:00   -1.605358
2012-03-19 09:30:00    1.306474
2012-03-20 09:30:00    0.865511
Freq: B, dtype: float64
</code></pre><p>最终结果会变成<code>UTC</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">'Europe/London'</span>)</div><div class="line">ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">'Europe/Moscow'</span>)</div><div class="line">result = ts1 + ts2</div><div class="line">result.index</div></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2012-03-07 09:30:00+00:00&#39;, &#39;2012-03-08 09:30:00+00:00&#39;,
               &#39;2012-03-09 09:30:00+00:00&#39;, &#39;2012-03-12 09:30:00+00:00&#39;,
               &#39;2012-03-13 09:30:00+00:00&#39;, &#39;2012-03-14 09:30:00+00:00&#39;,
               &#39;2012-03-15 09:30:00+00:00&#39;],
              dtype=&#39;datetime64[ns, UTC]&#39;, freq=&#39;B&#39;)
</code></pre><h2 id="时期及其算术运算"><a href="#时期及其算术运算" class="headerlink" title="时期及其算术运算"></a>时期及其算术运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="number">2007</span>, freq=<span class="string">'A-DEC'</span>)</div><div class="line">p</div></pre></td></tr></table></figure><pre><code>Period(&#39;2007&#39;, &#39;A-DEC&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p + <span class="number">5</span></div></pre></td></tr></table></figure><pre><code>Period(&#39;2012&#39;, &#39;A-DEC&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p - <span class="number">2</span></div></pre></td></tr></table></figure><pre><code>Period(&#39;2005&#39;, &#39;A-DEC&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.Period(<span class="string">'2014'</span>, freq=<span class="string">'A-DEC'</span>) - p</div></pre></td></tr></table></figure><pre><code>7
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rng = pd.period_range(<span class="string">'1/1/2000'</span>, <span class="string">'6/30/2000'</span>, freq=<span class="string">'M'</span>)</div><div class="line">rng</div></pre></td></tr></table></figure><pre><code>PeriodIndex([&#39;2000-01&#39;, &#39;2000-02&#39;, &#39;2000-03&#39;, &#39;2000-04&#39;, &#39;2000-05&#39;, &#39;2000-06&#39;], dtype=&#39;int64&#39;, freq=&#39;M&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Series(np.random.randn(<span class="number">6</span>), index=rng)</div></pre></td></tr></table></figure><pre><code>2000-01    0.061389
2000-02    0.059265
2000-03    0.779627
2000-04   -0.068995
2000-05   -0.451276
2000-06   -1.531821
Freq: M, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">values = [<span class="string">'2001Q3'</span>, <span class="string">'2002Q2'</span>, <span class="string">'2003Q1'</span>]</div><div class="line">index = pd.PeriodIndex(values, freq=<span class="string">'Q-DEC'</span>)</div><div class="line">index</div></pre></td></tr></table></figure><pre><code>PeriodIndex([&#39;2001Q3&#39;, &#39;2002Q2&#39;, &#39;2003Q1&#39;], dtype=&#39;int64&#39;, freq=&#39;Q-DEC&#39;)
</code></pre><h3 id="时区的频率转换"><a href="#时区的频率转换" class="headerlink" title="时区的频率转换"></a>时区的频率转换</h3><p>以十二月为结尾的一个年时期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-DEC'</span>)</div><div class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)</div></pre></td></tr></table></figure><pre><code>Period(&#39;2007-01&#39;, &#39;M&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'end'</span>)</div></pre></td></tr></table></figure><pre><code>Period(&#39;2007-12&#39;, &#39;M&#39;)
</code></pre><p>以六月份结尾的一个年时期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-JUN'</span>)</div><div class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'start'</span>)</div></pre></td></tr></table></figure><pre><code>Period(&#39;2006-07&#39;, &#39;M&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'end'</span>)</div></pre></td></tr></table></figure><pre><code>Period(&#39;2007-06&#39;, &#39;M&#39;)
</code></pre><p>2007年8月是属于以六月结尾的2008年的时期中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="string">'Aug-2007'</span>, <span class="string">'M'</span>)</div><div class="line">p.asfreq(<span class="string">'A-JUN'</span>)</div></pre></td></tr></table></figure><pre><code>Period(&#39;2008&#39;, &#39;A-JUN&#39;)
</code></pre><p>相当于一个批量操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.period_range(<span class="string">'2006'</span>, <span class="string">'2009'</span>, freq=<span class="string">'A-DEC'</span>)</div><div class="line">ts = Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2006    0.634252
2007   -0.738716
2008    0.398145
2009   -1.226529
Freq: A-DEC, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)</div></pre></td></tr></table></figure><pre><code>2006-01    0.634252
2007-01   -0.738716
2008-01    0.398145
2009-01   -1.226529
Freq: M, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.asfreq(<span class="string">'B'</span>, how=<span class="string">'end'</span>)</div></pre></td></tr></table></figure><pre><code>2006-12-29    0.634252
2007-12-31   -0.738716
2008-12-31    0.398145
2009-12-31   -1.226529
Freq: B, dtype: float64
</code></pre><h3 id="按季度计算的时间频率"><a href="#按季度计算的时间频率" class="headerlink" title="按季度计算的时间频率"></a>按季度计算的时间频率</h3><p>以一月为截止的第四个季度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="string">'2012Q4'</span>, freq=<span class="string">'Q-JAN'</span>)</div><div class="line">p</div></pre></td></tr></table></figure><pre><code>Period(&#39;2012Q4&#39;, &#39;Q-JAN&#39;)
</code></pre><p>第四个季度的起始日</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'start'</span>)</div></pre></td></tr></table></figure><pre><code>Period(&#39;2011-11-01&#39;, &#39;D&#39;)
</code></pre><p>结束日</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'end'</span>)</div></pre></td></tr></table></figure><pre><code>Period(&#39;2012-01-31&#39;, &#39;D&#39;)
</code></pre><p>截止日前一天的下午四点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p4pm = (p.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span></div><div class="line">p4pm</div></pre></td></tr></table></figure><pre><code>Period(&#39;2012-01-30 16:00&#39;, &#39;T&#39;)
</code></pre><p>转化成时间戳对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p4pm.to_timestamp()</div></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2012-01-30 16:00:00&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.period_range(<span class="string">'2011Q3'</span>, <span class="string">'2012Q4'</span>, freq=<span class="string">'Q-JAN'</span>)</div><div class="line">ts = Series(np.arange(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2011Q3    0
2011Q4    1
2012Q1    2
2012Q2    3
2012Q3    4
2012Q4    5
Freq: Q-JAN, dtype: int32
</code></pre><p>批量转化为时间戳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new_rng = (rng.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span></div><div class="line">ts.index = new_rng.to_timestamp()</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2010-10-28 16:00:00    0
2011-01-28 16:00:00    1
2011-04-28 16:00:00    2
2011-07-28 16:00:00    3
2011-10-28 16:00:00    4
2012-01-30 16:00:00    5
dtype: int32
</code></pre><h3 id="将时间戳转化为时期（以及其逆过程）"><a href="#将时间戳转化为时期（以及其逆过程）" class="headerlink" title="将时间戳转化为时期（以及其逆过程）"></a>将时间戳转化为时期（以及其逆过程）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">3</span>, freq=<span class="string">'M'</span>)</div><div class="line">ts = Series(randn(<span class="number">3</span>), index=rng)</div><div class="line">pts = ts.to_period()</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2000-01-31    0.239752
2000-02-29   -0.469201
2000-03-31    2.835243
Freq: M, dtype: float64
</code></pre><p>默认以月份为单位进行转化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pts</div></pre></td></tr></table></figure><pre><code>2000-01    0.239752
2000-02   -0.469201
2000-03    2.835243
Freq: M, dtype: float64
</code></pre><p>转化为月份为单位的时期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/29/2000'</span>, periods=<span class="number">6</span>, freq=<span class="string">'D'</span>)</div><div class="line">ts2 = Series(randn(<span class="number">6</span>), index=rng)</div><div class="line">ts2.to_period(<span class="string">'M'</span>)</div></pre></td></tr></table></figure><pre><code>2000-01    1.126773
2000-01   -0.979309
2000-01   -0.784376
2000-02   -1.490820
2000-02    1.125043
2000-02    0.421830
Freq: M, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pts = ts.to_period()</div><div class="line">pts</div></pre></td></tr></table></figure><pre><code>2000-01    0.239752
2000-02   -0.469201
2000-03    2.835243
Freq: M, dtype: float64
</code></pre><p>逆向转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pts.to_timestamp(how=<span class="string">'end'</span>)</div></pre></td></tr></table></figure><pre><code>2000-01-31    0.239752
2000-02-29   -0.469201
2000-03-31    2.835243
Freq: M, dtype: float64
</code></pre><h3 id="通过数组创建PeriodIndex"><a href="#通过数组创建PeriodIndex" class="headerlink" title="通过数组创建PeriodIndex"></a>通过数组创建<code>PeriodIndex</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.read_csv(<span class="string">'ch08/macrodata.csv'</span>)</div><div class="line">data.year</div></pre></td></tr></table></figure><pre><code>0      1959.0
1      1959.0
2      1959.0
3      1959.0
4      1960.0
5      1960.0
        ...  
197    2008.0
198    2008.0
199    2008.0
200    2009.0
201    2009.0
202    2009.0
Name: year, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.quarter</div></pre></td></tr></table></figure><pre><code>0      1.0
1      2.0
2      3.0
3      4.0
4      1.0
5      2.0
      ... 
197    2.0
198    3.0
199    4.0
200    1.0
201    2.0
202    3.0
Name: quarter, dtype: float64
</code></pre><p>将年份和季度数据统一起来转化为时期索引数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">index = pd.PeriodIndex(year=data.year, quarter=data.quarter, freq=<span class="string">'Q-DEC'</span>)</div><div class="line">index</div></pre></td></tr></table></figure><pre><code>PeriodIndex([&#39;1959Q1&#39;, &#39;1959Q2&#39;, &#39;1959Q3&#39;, &#39;1959Q4&#39;, &#39;1960Q1&#39;, &#39;1960Q2&#39;,
             &#39;1960Q3&#39;, &#39;1960Q4&#39;, &#39;1961Q1&#39;, &#39;1961Q2&#39;,
             ...
             &#39;2007Q2&#39;, &#39;2007Q3&#39;, &#39;2007Q4&#39;, &#39;2008Q1&#39;, &#39;2008Q2&#39;, &#39;2008Q3&#39;,
             &#39;2008Q4&#39;, &#39;2009Q1&#39;, &#39;2009Q2&#39;, &#39;2009Q3&#39;],
            dtype=&#39;int64&#39;, length=203, freq=&#39;Q-DEC&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data.index = index</div><div class="line">data.infl</div></pre></td></tr></table></figure><pre><code>1959Q1    0.00
1959Q2    2.34
1959Q3    2.74
1959Q4    0.27
1960Q1    2.31
1960Q2    0.14
          ... 
2008Q2    8.53
2008Q3   -3.16
2008Q4   -8.79
2009Q1    0.94
2009Q2    3.37
2009Q3    3.56
Freq: Q-DEC, Name: infl, dtype: float64
</code></pre><h2 id="重采样以及频率转换"><a href="#重采样以及频率转换" class="headerlink" title="重采样以及频率转换"></a>重采样以及频率转换</h2><p>相当于进行了一次分组操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">100</span>, freq=<span class="string">'D'</span>)</div><div class="line">ts = Series(randn(len(rng)), index=rng)</div><div class="line">ts.resample(<span class="string">'M'</span>, how=<span class="string">'mean'</span>)</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:3: FutureWarning: how in .resample() is deprecated
the new syntax is .resample(...).mean()
  app.launch_new_instance()





2000-01-31   -0.055153
2000-02-29    0.189412
2000-03-31   -0.075940
2000-04-30   -0.239036
Freq: M, dtype: float64
</code></pre><p>换个索引的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'M'</span>, how=<span class="string">'mean'</span>, kind=<span class="string">'period'</span>)</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: how in .resample() is deprecated
the new syntax is .resample(...).mean()
  if __name__ == &#39;__main__&#39;:





2000-01   -0.055153
2000-02    0.189412
2000-03   -0.075940
2000-04   -0.239036
Freq: M, dtype: float64
</code></pre><h3 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h3><p>按照分钟进行采样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">12</span>, freq=<span class="string">'T'</span>)</div><div class="line">ts = Series(np.arange(<span class="number">12</span>), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2000-01-01 00:00:00     0
2000-01-01 00:01:00     1
2000-01-01 00:02:00     2
2000-01-01 00:03:00     3
2000-01-01 00:04:00     4
2000-01-01 00:05:00     5
2000-01-01 00:06:00     6
2000-01-01 00:07:00     7
2000-01-01 00:08:00     8
2000-01-01 00:09:00     9
2000-01-01 00:10:00    10
2000-01-01 00:11:00    11
Freq: T, dtype: int32
</code></pre><p>每5分钟降采样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>).sum()</div><div class="line"><span class="comment"># note: output changed (as the default changed from closed='right', label='right' to closed='left', label='left'</span></div></pre></td></tr></table></figure><pre><code>2000-01-01 00:00:00    10
2000-01-01 00:05:00    35
2000-01-01 00:10:00    21
Freq: 5T, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'left'</span>).sum()</div></pre></td></tr></table></figure><pre><code>2000-01-01 00:00:00    10
2000-01-01 00:05:00    35
2000-01-01 00:10:00    21
Freq: 5T, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'left'</span>, label=<span class="string">'left'</span>).sum()</div></pre></td></tr></table></figure><pre><code>2000-01-01 00:00:00    10
2000-01-01 00:05:00    35
2000-01-01 00:10:00    21
Freq: 5T, dtype: int32
</code></pre><p>加了个时间的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, loffset=<span class="string">'-1s'</span>).sum()</div></pre></td></tr></table></figure><pre><code>1999-12-31 23:59:59    10
2000-01-01 00:04:59    35
2000-01-01 00:09:59    21
Freq: 5T, dtype: int32
</code></pre><h4 id="Open-High-Low-Close-OHLC-降采样"><a href="#Open-High-Low-Close-OHLC-降采样" class="headerlink" title="Open-High-Low-Close (OHLC) 降采样"></a>Open-High-Low-Close (OHLC) 降采样</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2000-01-01 00:00:00     0
2000-01-01 00:01:00     1
2000-01-01 00:02:00     2
2000-01-01 00:03:00     3
2000-01-01 00:04:00     4
2000-01-01 00:05:00     5
2000-01-01 00:06:00     6
2000-01-01 00:07:00     7
2000-01-01 00:08:00     8
2000-01-01 00:09:00     9
2000-01-01 00:10:00    10
2000-01-01 00:11:00    11
Freq: T, dtype: int32
</code></pre><p>以5分钟为单位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>).ohlc()</div><div class="line"><span class="comment"># note: output changed because of changed defaults</span></div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>open</th><th>high</th><th>low</th><th>close</th></tr></thead><tbody><tr><th>2000-01-01 00:00:00</th><td>0</td><td>4</td><td>0</td><td>4</td></tr><tr><th>2000-01-01 00:05:00</th><td>5</td><td>9</td><td>5</td><td>9</td></tr><tr><th>2000-01-01 00:10:00</th><td>10</td><td>11</td><td>10</td><td>11</td></tr></tbody></table></div><h4 id="通过GroupBy进行重采样"><a href="#通过GroupBy进行重采样" class="headerlink" title="通过GroupBy进行重采样"></a>通过GroupBy进行重采样</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">100</span>, freq=<span class="string">'D'</span>)</div><div class="line">ts = Series(np.arange(<span class="number">100</span>), index=rng)</div><div class="line">ts.groupby(<span class="keyword">lambda</span> x: x.month).mean()</div></pre></td></tr></table></figure><pre><code>1    15
2    45
3    75
4    95
dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.groupby(<span class="keyword">lambda</span> x: x.weekday).mean()</div></pre></td></tr></table></figure><pre><code>0    47.5
1    48.5
2    49.5
3    50.5
4    51.5
5    49.0
6    50.0
dtype: float64
</code></pre><h3 id="升采样和插值"><a href="#升采样和插值" class="headerlink" title="升采样和插值"></a>升采样和插值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame = DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">4</span>),</div><div class="line">                  index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">2</span>, freq=<span class="string">'W-WED'</span>),</div><div class="line">                  columns=[<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</div><div class="line">frame</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000-01-05</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-12</th><td>-0.587124</td><td>0.612993</td><td>-0.796000</td><td>-0.341138</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df_daily = frame.resample(<span class="string">'D'</span>).mean()</div><div class="line">df_daily</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000-01-05</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-06</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-07</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-08</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-09</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-10</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-11</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-12</th><td>-0.587124</td><td>0.612993</td><td>-0.796000</td><td>-0.341138</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.resample(<span class="string">'D'</span>).ffill()</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000-01-05</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-06</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-07</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-08</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-09</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-10</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-11</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-12</th><td>-0.587124</td><td>0.612993</td><td>-0.796000</td><td>-0.341138</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.resample(<span class="string">'D'</span>).ffill(limit=<span class="number">2</span>)</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000-01-05</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-06</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-07</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-08</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-09</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-10</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-11</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2000-01-12</th><td>-0.587124</td><td>0.612993</td><td>-0.796000</td><td>-0.341138</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.resample(<span class="string">'W-THU'</span>).ffill()</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000-01-06</th><td>0.360773</td><td>0.506429</td><td>1.166424</td><td>1.402336</td></tr><tr><th>2000-01-13</th><td>-0.587124</td><td>0.612993</td><td>-0.796000</td><td>-0.341138</td></tr></tbody></table></div><h3 id="通过时期进行重采样"><a href="#通过时期进行重采样" class="headerlink" title="通过时期进行重采样"></a>通过时期进行重采样</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame = DataFrame(np.random.randn(<span class="number">24</span>, <span class="number">4</span>),</div><div class="line">                  index=pd.period_range(<span class="string">'1-2000'</span>, <span class="string">'12-2001'</span>, freq=<span class="string">'M'</span>),</div><div class="line">                  columns=[<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</div><div class="line">frame[:<span class="number">5</span>]</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000-01</th><td>-0.254340</td><td>0.401110</td><td>-0.931350</td><td>-0.872552</td></tr><tr><th>2000-02</th><td>0.390968</td><td>-0.815357</td><td>-1.656213</td><td>-2.251621</td></tr><tr><th>2000-03</th><td>0.206297</td><td>0.197394</td><td>0.927518</td><td>-0.657257</td></tr><tr><th>2000-04</th><td>-0.451709</td><td>0.908598</td><td>-0.187902</td><td>-0.498082</td></tr><tr><th>2000-05</th><td>-0.215150</td><td>-0.042141</td><td>-0.738733</td><td>2.499246</td></tr></tbody></table></div><p>以年为单位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">annual_frame = frame.resample(<span class="string">'A-DEC'</span>).mean()</div><div class="line">annual_frame</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2001</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr></tbody></table></div><p>以季度为单位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Q-DEC: Quarterly, year ending in December</span></div><div class="line">annual_frame.resample(<span class="string">'Q-DEC'</span>).ffill()</div><div class="line"><span class="comment"># note: output changed, default value changed from convention='end' to convention='start' + 'start' changed to span-like</span></div><div class="line"><span class="comment"># also the following cells</span></div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000Q1</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2000Q2</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2000Q3</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2000Q4</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2001Q1</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2001Q2</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2001Q3</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2001Q4</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">annual_frame.resample(<span class="string">'Q-DEC'</span>, fill_method=<span class="string">'ffill'</span>, convention=<span class="string">'start'</span>)</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: fill_method is deprecated to .resample()
the new syntax is .resample(...).ffill()
  if __name__ == &#39;__main__&#39;:
</code></pre><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000Q1</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2000Q2</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2000Q3</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2000Q4</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2001Q1</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2001Q2</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2001Q3</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2001Q4</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">annual_frame.resample(<span class="string">'Q-MAR'</span>, fill_method=<span class="string">'ffill'</span>)</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: fill_method is deprecated to .resample()
the new syntax is .resample(...).ffill()
  if __name__ == &#39;__main__&#39;:
</code></pre><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Colorado</th><th>Texas</th><th>New York</th><th>Ohio</th></tr></thead><tbody><tr><th>2000Q4</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2001Q1</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2001Q2</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2001Q3</th><td>-0.049383</td><td>0.037021</td><td>-0.272851</td><td>-0.140984</td></tr><tr><th>2001Q4</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2002Q1</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2002Q2</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr><tr><th>2002Q3</th><td>-0.183766</td><td>-0.291993</td><td>0.340941</td><td>0.209276</td></tr></tbody></table></div><h2 id="时间序列绘图"><a href="#时间序列绘图" class="headerlink" title="时间序列绘图"></a>时间序列绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">close_px_all = pd.read_csv(<span class="string">'ch09/stock_px.csv'</span>, parse_dates=<span class="keyword">True</span>, index_col=<span class="number">0</span>)</div><div class="line">close_px = close_px_all[[<span class="string">'AAPL'</span>, <span class="string">'MSFT'</span>, <span class="string">'XOM'</span>]]</div><div class="line">close_px = close_px.resample(<span class="string">'B'</span>, fill_method=<span class="string">'ffill'</span>)</div><div class="line">close_px.info()</div></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
DatetimeIndex: 2292 entries, 2003-01-02 to 2011-10-14
Freq: B
Data columns (total 3 columns):
AAPL    2292 non-null float64
MSFT    2292 non-null float64
XOM     2292 non-null float64
dtypes: float64(3)
memory usage: 71.6 KB


C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:3: FutureWarning: fill_method is deprecated to .resample()
the new syntax is .resample(...).ffill()
  app.launch_new_instance()
</code></pre><p>按年绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px[<span class="string">'AAPL'</span>].plot()</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb1f85a080&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_270_1.png" alt="png"></p><p>按月绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px.ix[<span class="string">'2009'</span>].plot()</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb20c4d550&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_272_1.png" alt="png"></p><p>按天绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px[<span class="string">'AAPL'</span>].ix[<span class="string">'01-2011'</span>:<span class="string">'03-2011'</span>].plot()</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb21235668&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_274_1.png" alt="png"></p><p>按季度绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">appl_q = close_px[<span class="string">'AAPL'</span>].resample(<span class="string">'Q-DEC'</span>, fill_method=<span class="string">'ffill'</span>)</div><div class="line">appl_q.ix[<span class="string">'2009'</span>:].plot()</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: fill_method is deprecated to .resample()
the new syntax is .resample(...).ffill()
  if __name__ == &#39;__main__&#39;:





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb21346c50&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_276_2.png" alt="png"></p><h2 id="移动窗口函数"><a href="#移动窗口函数" class="headerlink" title="移动窗口函数"></a>移动窗口函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px = close_px.asfreq(<span class="string">'B'</span>).fillna(method=<span class="string">'ffill'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close_px.AAPL.plot()</div><div class="line">pd.rolling_mean(close_px.AAPL, <span class="number">250</span>).plot()</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb213b95f8&gt;



C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:2: FutureWarning: pd.rolling_mean is deprecated for Series and will be removed in a future version, replace with 
    Series.rolling(window=250,center=False).mean()
  from ipykernel import kernelapp as app





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb213b95f8&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_279_3.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.figure()</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.figure.Figure at 0x1fb212fb550&gt;




&lt;matplotlib.figure.Figure at 0x1fb212fb550&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">appl_std250 = pd.rolling_std(close_px.AAPL, <span class="number">250</span>, min_periods=<span class="number">10</span>)</div><div class="line">appl_std250[<span class="number">5</span>:<span class="number">12</span>]</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: pd.rolling_std is deprecated for Series and will be removed in a future version, replace with 
    Series.rolling(window=250,min_periods=10,center=False).std()
  if __name__ == &#39;__main__&#39;:





2003-01-09         NaN
2003-01-10         NaN
2003-01-13         NaN
2003-01-14         NaN
2003-01-15    0.077496
2003-01-16    0.074760
2003-01-17    0.112368
Freq: B, Name: AAPL, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appl_std250.plot()</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb21466ba8&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_282_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Define expanding mean in terms of rolling_mean</span></div><div class="line">expanding_mean = <span class="keyword">lambda</span> x: rolling_mean(x, len(x), min_periods=<span class="number">1</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.rolling_mean(close_px, <span class="number">60</span>).plot(logy=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: pd.rolling_mean is deprecated for DataFrame and will be removed in a future version, replace with 
    DataFrame.rolling(window=60,center=False).mean()
  if __name__ == &#39;__main__&#39;:





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb21571208&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_284_2.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.close(<span class="string">'all'</span>)</div></pre></td></tr></table></figure><h3 id="指数加权函数"><a href="#指数加权函数" class="headerlink" title="指数加权函数"></a>指数加权函数</h3><p>更好的拟合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">1</span>, sharex=<span class="keyword">True</span>, sharey=<span class="keyword">True</span>,</div><div class="line">                         figsize=(<span class="number">12</span>, <span class="number">7</span>))</div><div class="line"></div><div class="line">aapl_px = close_px.AAPL[<span class="string">'2005'</span>:<span class="string">'2009'</span>]</div><div class="line"></div><div class="line">ma60 = pd.rolling_mean(aapl_px, <span class="number">60</span>, min_periods=<span class="number">50</span>)</div><div class="line">ewma60 = pd.ewma(aapl_px, span=<span class="number">60</span>)</div><div class="line"></div><div class="line">aapl_px.plot(style=<span class="string">'k-'</span>, ax=axes[<span class="number">0</span>])</div><div class="line">ma60.plot(style=<span class="string">'k--'</span>, ax=axes[<span class="number">0</span>])</div><div class="line">aapl_px.plot(style=<span class="string">'k-'</span>, ax=axes[<span class="number">1</span>])</div><div class="line">ewma60.plot(style=<span class="string">'k--'</span>, ax=axes[<span class="number">1</span>])</div><div class="line">axes[<span class="number">0</span>].set_title(<span class="string">'Simple MA'</span>)</div><div class="line">axes[<span class="number">1</span>].set_title(<span class="string">'Exponentially-weighted MA'</span>)</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:6: FutureWarning: pd.rolling_mean is deprecated for Series and will be removed in a future version, replace with 
    Series.rolling(window=60,min_periods=50,center=False).mean()
C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:7: FutureWarning: pd.ewm_mean is deprecated for Series and will be removed in a future version, replace with 
    Series.ewm(span=60,ignore_na=False,min_periods=0,adjust=True).mean()





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb21983b70&gt;






&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb21983b70&gt;






&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb219c9a20&gt;






&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb219c9a20&gt;






&lt;matplotlib.text.Text at 0x1fb219b10b8&gt;






&lt;matplotlib.text.Text at 0x1fb219efcc0&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_288_7.png" alt="png"></p><h3 id="二元移动窗口函数"><a href="#二元移动窗口函数" class="headerlink" title="二元移动窗口函数"></a>二元移动窗口函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close_px</div><div class="line">spx_px = close_px_all[<span class="string">'SPX'</span>]</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>AAPL</th><th>MSFT</th><th>XOM</th></tr></thead><tbody><tr><th>2003-01-02</th><td>7.40</td><td>21.11</td><td>29.22</td></tr><tr><th>2003-01-03</th><td>7.45</td><td>21.14</td><td>29.24</td></tr><tr><th>2003-01-06</th><td>7.45</td><td>21.52</td><td>29.96</td></tr><tr><th>2003-01-07</th><td>7.43</td><td>21.93</td><td>28.95</td></tr><tr><th>2003-01-08</th><td>7.28</td><td>21.31</td><td>28.83</td></tr><tr><th>2003-01-09</th><td>7.34</td><td>21.93</td><td>29.44</td></tr><tr><th>...</th><td>...</td><td>...</td><td>...</td></tr><tr><th>2011-10-07</th><td>369.80</td><td>26.25</td><td>73.56</td></tr><tr><th>2011-10-10</th><td>388.81</td><td>26.94</td><td>76.28</td></tr><tr><th>2011-10-11</th><td>400.29</td><td>27.00</td><td>76.27</td></tr><tr><th>2011-10-12</th><td>402.19</td><td>26.96</td><td>77.16</td></tr><tr><th>2011-10-13</th><td>408.43</td><td>27.18</td><td>76.37</td></tr><tr><th>2011-10-14</th><td>422.00</td><td>27.27</td><td>78.11</td></tr></tbody></table><p>2292 rows × 3 columns</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spx_rets = spx_px / spx_px.shift(<span class="number">1</span>) - <span class="number">1</span></div><div class="line">returns = close_px.pct_change()</div><div class="line">corr = pd.rolling_corr(returns.AAPL, spx_rets, <span class="number">125</span>, min_periods=<span class="number">100</span>)</div><div class="line">corr.plot()</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:3: FutureWarning: pd.rolling_corr is deprecated for Series and will be removed in a future version, replace with 
    Series.rolling(window=125,min_periods=100).corr(other=&lt;Series&gt;)
  app.launch_new_instance()





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb21a93438&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_291_2.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">corr = pd.rolling_corr(returns, spx_rets, <span class="number">125</span>, min_periods=<span class="number">100</span>)</div><div class="line">corr.plot()</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: pd.rolling_corr is deprecated for DataFrame and will be removed in a future version, replace with 
    DataFrame.rolling(window=125,min_periods=100).corr(other=&lt;Series&gt;)
  if __name__ == &#39;__main__&#39;:





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb22b21438&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_292_2.png" alt="png"></p><h3 id="用户自定义移动窗口函数"><a href="#用户自定义移动窗口函数" class="headerlink" title="用户自定义移动窗口函数"></a>用户自定义移动窗口函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> percentileofscore</div><div class="line">score_at_2percent = <span class="keyword">lambda</span> x: percentileofscore(x, <span class="number">0.02</span>)</div><div class="line">result = pd.rolling_apply(returns.AAPL, <span class="number">250</span>, score_at_2percent)</div><div class="line">result.plot()</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\lib\site-packages\ipykernel\__main__.py:3: FutureWarning: pd.rolling_apply is deprecated for Series and will be removed in a future version, replace with 
    Series.rolling(window=250,center=False).apply(kwargs=&lt;dict&gt;,args=&lt;tuple&gt;,func=&lt;function&gt;)
  app.launch_new_instance()





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb3dbdd2e8&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch10/output_294_2.png" alt="png"></p><h2 id="性能和内存使用方面的注意事项"><a href="#性能和内存使用方面的注意事项" class="headerlink" title="性能和内存使用方面的注意事项"></a>性能和内存使用方面的注意事项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">10000000</span>, freq=<span class="string">'10ms'</span>)</div><div class="line">ts = Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure><pre><code>2000-01-01 00:00:00.000   -0.428577
2000-01-01 00:00:00.010    1.650203
2000-01-01 00:00:00.020   -0.064777
2000-01-01 00:00:00.030   -0.219433
2000-01-01 00:00:00.040    1.907433
2000-01-01 00:00:00.050    0.103347
                             ...   
2000-01-02 03:46:39.940    0.989446
2000-01-02 03:46:39.950    2.333137
2000-01-02 03:46:39.960    0.354455
2000-01-02 03:46:39.970    0.353224
2000-01-02 03:46:39.980   -0.862868
2000-01-02 03:46:39.990    2.007468
Freq: 10L, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'15min'</span>).ohlc().info()</div></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
DatetimeIndex: 11112 entries, 2000-01-01 00:00:00 to 2000-04-25 17:45:00
Freq: 15T
Data columns (total 4 columns):
open     11112 non-null float64
high     11112 non-null float64
low      11112 non-null float64
close    11112 non-null float64
dtypes: float64(4)
memory usage: 434.1 KB
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%timeit ts.resample(<span class="string">'15min'</span>).ohlc()</div></pre></td></tr></table></figure><pre><code>10 loops, best of 3: 123 ms per loop
</code></pre><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">10000000</span>, freq=<span class="string">'1s'</span>)</div><div class="line">ts = Series(np.random.randn(len(rng)), index=rng)</div><div class="line">%timeit ts.resample(<span class="string">'15s'</span>).ohlc()</div></pre></td></tr></table></figure><pre><code>1 loop, best of 3: 192 ms per loop
</code></pre><p>​</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;时间序列&quot;&gt;&lt;a href=&quot;#时间序列&quot; class=&quot;headerlink&quot; title=&quot;时间序列&quot;&gt;&lt;/a&gt;时间序列&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>cs231n Assignment#1 two layer net</title>
    <link href="http://yoursite.com/2017/03/08/cs231n-Assignment-1-two-layer-net/"/>
    <id>http://yoursite.com/2017/03/08/cs231n-Assignment-1-two-layer-net/</id>
    <published>2017-03-08T08:03:35.000Z</published>
    <updated>2017-03-08T08:15:07.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Implementing-a-Neural-Network"><a href="#Implementing-a-Neural-Network" class="headerlink" title="Implementing a Neural Network"></a>Implementing a Neural Network</h1><p>In this exercise we will develop a neural network with fully-connected layers to perform classification, and test it out on the CIFAR-10 dataset.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A bit of setup</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="keyword">from</span> cs231n.classifiers.neural_net <span class="keyword">import</span> TwoLayerNet</div><div class="line"></div><div class="line">%matplotlib inline</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line"><span class="comment"># for auto-reloading external modules</span></div><div class="line"><span class="comment"># see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython</span></div><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rel_error</span><span class="params">(x, y)</span>:</span></div><div class="line">  <span class="string">""" returns relative error """</span></div><div class="line">  <span class="keyword">return</span> np.max(np.abs(x - y) / (np.maximum(<span class="number">1e-8</span>, np.abs(x) + np.abs(y))))</div></pre></td></tr></table></figure><p>We will use the class <code>TwoLayerNet</code> in the file <code>cs231n/classifiers/neural_net.py</code> to represent instances of our network. The network parameters are stored in the instance variable <code>self.params</code> where keys are string parameter names and values are numpy arrays. Below, we initialize toy data and a toy model that we will use to develop your implementation.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Create a small net and some toy data to check your implementations.</span></div><div class="line"><span class="comment"># Note that we set the random seed for repeatable experiments.</span></div><div class="line"></div><div class="line">input_size = <span class="number">4</span></div><div class="line">hidden_size = <span class="number">10</span></div><div class="line">num_classes = <span class="number">3</span></div><div class="line">num_inputs = <span class="number">5</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_toy_model</span><span class="params">()</span>:</span></div><div class="line">  np.random.seed(<span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span> TwoLayerNet(input_size, hidden_size, num_classes, std=<span class="number">1e-1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_toy_data</span><span class="params">()</span>:</span></div><div class="line">  np.random.seed(<span class="number">1</span>)</div><div class="line">  X = <span class="number">10</span> * np.random.randn(num_inputs, input_size)</div><div class="line">  y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])</div><div class="line">  <span class="keyword">return</span> X, y</div><div class="line"></div><div class="line">net = init_toy_model()</div><div class="line">X, y = init_toy_data()</div></pre></td></tr></table></figure><h1 id="Forward-pass-compute-scores"><a href="#Forward-pass-compute-scores" class="headerlink" title="Forward pass: compute scores"></a>Forward pass: compute scores</h1><p>Open the file <code>cs231n/classifiers/neural_net.py</code> and look at the method <code>TwoLayerNet.loss</code>. This function is very similar to the loss functions you have written for the SVM and Softmax exercises: It takes the data and weights and computes the class scores, the loss, and the gradients on the parameters.</p><p>Implement the first part of the forward pass which uses the weights and biases to compute the scores for all inputs.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">scores = net.loss(X)</div><div class="line"><span class="keyword">print</span> <span class="string">'Your scores:'</span></div><div class="line"><span class="keyword">print</span> scores</div><div class="line"><span class="keyword">print</span></div><div class="line"><span class="keyword">print</span> <span class="string">'correct scores:'</span></div><div class="line">correct_scores = np.asarray([</div><div class="line">  [<span class="number">-0.81233741</span>, <span class="number">-1.27654624</span>, <span class="number">-0.70335995</span>],</div><div class="line">  [<span class="number">-0.17129677</span>, <span class="number">-1.18803311</span>, <span class="number">-0.47310444</span>],</div><div class="line">  [<span class="number">-0.51590475</span>, <span class="number">-1.01354314</span>, <span class="number">-0.8504215</span> ],</div><div class="line">  [<span class="number">-0.15419291</span>, <span class="number">-0.48629638</span>, <span class="number">-0.52901952</span>],</div><div class="line">  [<span class="number">-0.00618733</span>, <span class="number">-0.12435261</span>, <span class="number">-0.15226949</span>]])</div><div class="line"><span class="keyword">print</span> correct_scores</div><div class="line"><span class="keyword">print</span></div><div class="line"></div><div class="line"><span class="comment"># The difference should be very small. We get &lt; 1e-7</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Difference between your scores and correct scores:'</span></div><div class="line"><span class="keyword">print</span> np.sum(np.abs(scores - correct_scores))</div></pre></td></tr></table></figure><pre><code>Your scores:
[[-0.81233741 -1.27654624 -0.70335995]
 [-0.17129677 -1.18803311 -0.47310444]
 [-0.51590475 -1.01354314 -0.8504215 ]
 [-0.15419291 -0.48629638 -0.52901952]
 [-0.00618733 -0.12435261 -0.15226949]]

correct scores:
[[-0.81233741 -1.27654624 -0.70335995]
 [-0.17129677 -1.18803311 -0.47310444]
 [-0.51590475 -1.01354314 -0.8504215 ]
 [-0.15419291 -0.48629638 -0.52901952]
 [-0.00618733 -0.12435261 -0.15226949]]

Difference between your scores and correct scores:
3.68027204961e-08
</code></pre><h1 id="Forward-pass-compute-loss"><a href="#Forward-pass-compute-loss" class="headerlink" title="Forward pass: compute loss"></a>Forward pass: compute loss</h1><p>In the same function, implement the second part that computes the data and regularizaion loss.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">loss, _ = net.loss(X, y, reg=<span class="number">0.1</span>)</div><div class="line">correct_loss = <span class="number">1.30378789133</span></div><div class="line"></div><div class="line"><span class="comment"># should be very small, we get &lt; 1e-12</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Difference between your loss and correct loss:'</span></div><div class="line"><span class="keyword">print</span> np.sum(np.abs(loss - correct_loss))</div></pre></td></tr></table></figure><pre><code>Difference between your loss and correct loss:
1.79412040779e-13
</code></pre><h1 id="Backward-pass"><a href="#Backward-pass" class="headerlink" title="Backward pass"></a>Backward pass</h1><p>Implement the rest of the function. This will compute the gradient of the loss with respect to the variables <code>W1</code>, <code>b1</code>, <code>W2</code>, and <code>b2</code>. Now that you (hopefully!) have a correctly implemented forward pass, you can debug your backward pass using a numeric gradient check:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> cs231n.gradient_check <span class="keyword">import</span> eval_numerical_gradient</div><div class="line"></div><div class="line"><span class="comment"># Use numeric gradient checking to check your implementation of the backward pass.</span></div><div class="line"><span class="comment"># If your implementation is correct, the difference between the numeric and</span></div><div class="line"><span class="comment"># analytic gradients should be less than 1e-8 for each of W1, W2, b1, and b2.</span></div><div class="line"></div><div class="line">loss, grads = net.loss(X, y, reg=<span class="number">0.1</span>)</div><div class="line"></div><div class="line"><span class="comment"># these should all be less than 1e-8 or so</span></div><div class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> grads:</div><div class="line">  f = <span class="keyword">lambda</span> W: net.loss(X, y, reg=<span class="number">0.1</span>)[<span class="number">0</span>]</div><div class="line">  param_grad_num = eval_numerical_gradient(f, net.params[param_name], verbose=<span class="keyword">False</span>)</div><div class="line">  <span class="keyword">print</span> <span class="string">'%s max relative error: %e'</span> % (param_name, rel_error(param_grad_num, grads[param_name]))</div></pre></td></tr></table></figure><pre><code>W1 max relative error: 3.669858e-09
W2 max relative error: 3.440708e-09
b2 max relative error: 3.865028e-11
b1 max relative error: 2.738422e-09
</code></pre><h1 id="Train-the-network"><a href="#Train-the-network" class="headerlink" title="Train the network"></a>Train the network</h1><p>To train the network we will use stochastic gradient descent (SGD), similar to the SVM and Softmax classifiers. Look at the function <code>TwoLayerNet.train</code> and fill in the missing sections to implement the training procedure. This should be very similar to the training procedure you used for the SVM and Softmax classifiers. You will also have to implement <code>TwoLayerNet.predict</code>, as the training process periodically performs prediction to keep track of accuracy over time while the network trains.</p><p>Once you have implemented the method, run the code below to train a two-layer network on toy data. You should achieve a training loss less than 0.2.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">net = init_toy_model()</div><div class="line">stats = net.train(X, y, X, y,</div><div class="line">            learning_rate=<span class="number">1e-1</span>, reg=<span class="number">1e-5</span>,</div><div class="line">            num_iters=<span class="number">100</span>, verbose=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'Final training loss: '</span>, stats[<span class="string">'loss_history'</span>][<span class="number">-1</span>]</div><div class="line"></div><div class="line"><span class="comment"># plot the loss history</span></div><div class="line">plt.plot(stats[<span class="string">'loss_history'</span>])</div><div class="line">plt.xlabel(<span class="string">'iteration'</span>)</div><div class="line">plt.ylabel(<span class="string">'training loss'</span>)</div><div class="line">plt.title(<span class="string">'Training Loss history'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><pre><code>Final training loss:  0.0171496079387
</code></pre><p>​</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/two_layer_net/output_11_1.png" alt="png"></p><h1 id="Load-the-data"><a href="#Load-the-data" class="headerlink" title="Load the data"></a>Load the data</h1><p>Now that you have implemented a two-layer network that passes gradient checks and works on toy data, it’s time to load up our favorite CIFAR-10 data so we can use it to train a classifier on a real dataset.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> cs231n.data_utils <span class="keyword">import</span> load_CIFAR10</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_CIFAR10_data</span><span class="params">(num_training=<span class="number">49000</span>, num_validation=<span class="number">1000</span>, num_test=<span class="number">1000</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Load the CIFAR-10 dataset from disk and perform preprocessing to prepare</div><div class="line">    it for the two-layer neural net classifier. These are the same steps as</div><div class="line">    we used for the SVM, but condensed to a single function.  </div><div class="line">    """</div><div class="line">    <span class="comment"># Load the raw CIFAR-10 data</span></div><div class="line">    cifar10_dir = <span class="string">'cs231n/datasets/cifar-10-batches-py'</span></div><div class="line">    X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)</div><div class="line">        </div><div class="line">    <span class="comment"># Subsample the data</span></div><div class="line">    mask = range(num_training, num_training + num_validation)</div><div class="line">    X_val = X_train[mask]</div><div class="line">    y_val = y_train[mask]</div><div class="line">    mask = range(num_training)</div><div class="line">    X_train = X_train[mask]</div><div class="line">    y_train = y_train[mask]</div><div class="line">    mask = range(num_test)</div><div class="line">    X_test = X_test[mask]</div><div class="line">    y_test = y_test[mask]</div><div class="line"></div><div class="line">    <span class="comment"># Normalize the data: subtract the mean image</span></div><div class="line">    mean_image = np.mean(X_train, axis=<span class="number">0</span>)</div><div class="line">    X_train -= mean_image</div><div class="line">    X_val -= mean_image</div><div class="line">    X_test -= mean_image</div><div class="line"></div><div class="line">    <span class="comment"># Reshape data to rows</span></div><div class="line">    X_train = X_train.reshape(num_training, <span class="number">-1</span>)</div><div class="line">    X_val = X_val.reshape(num_validation, <span class="number">-1</span>)</div><div class="line">    X_test = X_test.reshape(num_test, <span class="number">-1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> X_train, y_train, X_val, y_val, X_test, y_test</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Invoke the above function to get our data.</span></div><div class="line">X_train, y_train, X_val, y_val, X_test, y_test = get_CIFAR10_data()</div><div class="line"><span class="keyword">print</span> <span class="string">'Train data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Train labels shape: '</span>, y_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation data shape: '</span>, X_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation labels shape: '</span>, y_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test labels shape: '</span>, y_test.shape</div></pre></td></tr></table></figure><pre><code>Train data shape:  (49000L, 3072L)
Train labels shape:  (49000L,)
Validation data shape:  (1000L, 3072L)
Validation labels shape:  (1000L,)
Test data shape:  (1000L, 3072L)
Test labels shape:  (1000L,)
</code></pre><h1 id="Train-a-network"><a href="#Train-a-network" class="headerlink" title="Train a network"></a>Train a network</h1><p>To train our network we will use SGD with momentum. In addition, we will adjust the learning rate with an exponential learning rate schedule as optimization proceeds; after each epoch, we will reduce the learning rate by multiplying it by a decay rate.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">input_size = <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span></div><div class="line">hidden_size = <span class="number">50</span></div><div class="line">num_classes = <span class="number">10</span></div><div class="line">net = TwoLayerNet(input_size, hidden_size, num_classes)</div><div class="line"></div><div class="line"><span class="comment"># Train the network</span></div><div class="line">stats = net.train(X_train, y_train, X_val, y_val,</div><div class="line">            num_iters=<span class="number">1000</span>, batch_size=<span class="number">200</span>,</div><div class="line">            learning_rate=<span class="number">1e-4</span>, learning_rate_decay=<span class="number">0.95</span>,</div><div class="line">            reg=<span class="number">0.5</span>, verbose=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># Predict on the validation set</span></div><div class="line">val_acc = (net.predict(X_val) == y_val).mean()</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation accuracy: '</span>, val_acc</div></pre></td></tr></table></figure><pre><code>iteration 0 / 1000: loss 2.302954
iteration 100 / 1000: loss 2.302550
iteration 200 / 1000: loss 2.297648
iteration 300 / 1000: loss 2.259602
iteration 400 / 1000: loss 2.204170
iteration 500 / 1000: loss 2.118565
iteration 600 / 1000: loss 2.051535
iteration 700 / 1000: loss 1.988466
iteration 800 / 1000: loss 2.006591
iteration 900 / 1000: loss 1.951473
Validation accuracy:  0.287
</code></pre><h1 id="Debug-the-training"><a href="#Debug-the-training" class="headerlink" title="Debug the training"></a>Debug the training</h1><p>With the default parameters we provided above, you should get a validation accuracy of about 0.29 on the validation set. This isn’t very good.</p><p>One strategy for getting insight into what’s wrong is to plot the loss function and the accuracies on the training and validation sets during optimization.</p><p>Another strategy is to visualize the weights that were learned in the first layer of the network. In most neural networks trained on visual data, the first layer weights typically show some visible structure when visualized.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Plot the loss function and train / validation accuracies</span></div><div class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">plt.plot(stats[<span class="string">'loss_history'</span>])</div><div class="line">plt.title(<span class="string">'Loss history'</span>)</div><div class="line">plt.xlabel(<span class="string">'Iteration'</span>)</div><div class="line">plt.ylabel(<span class="string">'Loss'</span>)</div><div class="line"></div><div class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>)</div><div class="line">plt.plot(stats[<span class="string">'train_acc_history'</span>], label=<span class="string">'train'</span>)</div><div class="line">plt.plot(stats[<span class="string">'val_acc_history'</span>], label=<span class="string">'val'</span>)</div><div class="line">plt.title(<span class="string">'Classification accuracy history'</span>)</div><div class="line">plt.xlabel(<span class="string">'Epoch'</span>)</div><div class="line">plt.ylabel(<span class="string">'Clasification accuracy'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/two_layer_net/output_17_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> cs231n.vis_utils <span class="keyword">import</span> visualize_grid</div><div class="line"></div><div class="line"><span class="comment"># Visualize the weights of the network</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_net_weights</span><span class="params">(net)</span>:</span></div><div class="line">  W1 = net.params[<span class="string">'W1'</span>]</div><div class="line">  W1 = W1.reshape(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">-1</span>).transpose(<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">  plt.imshow(visualize_grid(W1, padding=<span class="number">3</span>).astype(<span class="string">'uint8'</span>))</div><div class="line">  plt.gca().axis(<span class="string">'off'</span>)</div><div class="line">  plt.show()</div><div class="line"></div><div class="line">show_net_weights(net)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/two_layer_net/output_18_0.png" alt="png"></p><h1 id="Tune-your-hyperparameters"><a href="#Tune-your-hyperparameters" class="headerlink" title="Tune your hyperparameters"></a>Tune your hyperparameters</h1><p><strong>What’s wrong?</strong>. Looking at the visualizations above, we see that the loss is decreasing more or less linearly, which seems to suggest that the learning rate may be too low. Moreover, there is no gap between the training and validation accuracy, suggesting that the model we used has low capacity, and that we should increase its size. On the other hand, with a very large model we would expect to see more overfitting, which would manifest itself as a very large gap between the training and validation accuracy.</p><p><strong>Tuning</strong>. Tuning the hyperparameters and developing intuition for how they affect the final performance is a large part of using Neural Networks, so we want you to get a lot of practice. Below, you should experiment with different values of the various hyperparameters, including hidden layer size, learning rate, numer of training epochs, and regularization strength. You might also consider tuning the learning rate decay, but you should be able to get good performance using the default value.</p><p><strong>Approximate results</strong>. You should be aim to achieve a classification accuracy of greater than 48% on the validation set. Our best network gets over 52% on the validation set.</p><p><strong>Experiment</strong>: You goal in this exercise is to get as good of a result on CIFAR-10 as you can, with a fully-connected Neural Network. For every 1% above 52% on the Test set we will award you with one extra bonus point. Feel free implement your own techniques (e.g. PCA to reduce dimensionality, or adding dropout, or adding features to the solver, etc.).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">best_net = <span class="keyword">None</span> <span class="comment"># store the best model into this </span></div><div class="line"></div><div class="line"><span class="comment">#################################################################################</span></div><div class="line"><span class="comment"># <span class="doctag">TODO:</span> Tune hyperparameters using the validation set. Store your best trained  #</span></div><div class="line"><span class="comment"># model in best_net.                                                            #</span></div><div class="line"><span class="comment">#                                                                               #</span></div><div class="line"><span class="comment"># To help debug your network, it may help to use visualizations similar to the  #</span></div><div class="line"><span class="comment"># ones we used above; these visualizations will have significant qualitative    #</span></div><div class="line"><span class="comment"># differences from the ones we saw above for the poorly tuned network.          #</span></div><div class="line"><span class="comment">#                                                                               #</span></div><div class="line"><span class="comment"># Tweaking hyperparameters by hand can be fun, but you might find it useful to  #</span></div><div class="line"><span class="comment"># write code to sweep through possible combinations of hyperparameters          #</span></div><div class="line"><span class="comment"># automatically like we did on the previous exercises.                          #</span></div><div class="line"><span class="comment">#################################################################################</span></div><div class="line">best_val = <span class="number">-1</span></div><div class="line">best_stats = <span class="keyword">None</span></div><div class="line">learning_rates = [<span class="number">1e-1</span>, <span class="number">1e-2</span>, <span class="number">1e-3</span>, <span class="number">1e-4</span>]</div><div class="line">regularization_strengths = [<span class="number">1e-1</span>, <span class="number">1e-2</span>, <span class="number">1e-3</span>, <span class="number">1e-4</span>]</div><div class="line">batch_sizes = [<span class="number">200</span>, <span class="number">400</span>, <span class="number">800</span>]</div><div class="line">hidden_sizes = [<span class="number">80</span>, <span class="number">160</span>, <span class="number">320</span>]</div><div class="line">results = &#123;&#125;</div><div class="line">iters = <span class="number">2000</span></div><div class="line">total_size = <span class="number">144</span></div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> learning_rates:</div><div class="line">    <span class="keyword">for</span> rs <span class="keyword">in</span> regularization_strengths:</div><div class="line">        <span class="keyword">for</span> bs <span class="keyword">in</span> batch_sizes:</div><div class="line">            <span class="keyword">for</span> hs <span class="keyword">in</span> hidden_sizes:</div><div class="line">                i += <span class="number">1</span></div><div class="line">                <span class="keyword">print</span> i, <span class="string">'/'</span>, total_size</div><div class="line">                net = TwoLayerNet(input_size, hs, num_classes)</div><div class="line"></div><div class="line">                <span class="comment"># Train the network</span></div><div class="line">                stats = net.train(X_train, y_train, X_val, y_val,</div><div class="line">                            num_iters=iters, batch_size=bs,</div><div class="line">                            learning_rate=lr, learning_rate_decay=<span class="number">0.95</span>,</div><div class="line">                            reg=rs)</div><div class="line"></div><div class="line">                y_train_pred = net.predict(X_train)</div><div class="line">                acc_train = np.mean(y_train == y_train_pred)</div><div class="line">                y_val_pred = net.predict(X_val)</div><div class="line">                acc_val = np.mean(y_val == y_val_pred)</div><div class="line"></div><div class="line">                results[(lr, rs, bs, hs)] = (acc_train, acc_val)</div><div class="line"></div><div class="line">                <span class="keyword">if</span> best_val &lt; acc_val:</div><div class="line">                    best_stats = stats</div><div class="line">                    best_val = acc_val</div><div class="line">                    best_net = net</div><div class="line"></div><div class="line"><span class="comment"># Print out results.</span></div><div class="line"><span class="comment"># for lr, reg, bs, hs in sorted(results):</span></div><div class="line"><span class="comment">#     train_accuracy, val_accuracy = results[(lr, reg, bs, hs)]</span></div><div class="line"><span class="comment">#     print 'lr %e reg %e bs %e hs %e train accuracy: %f val accuracy: %f' % (</span></div><div class="line"><span class="comment">#                 lr, reg, bs, hs, train_accuracy, val_accuracy)</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'best validation accuracy achieved during cross-validation: %f'</span> % best_val</div><div class="line"><span class="comment">#################################################################################</span></div><div class="line"><span class="comment">#                               END OF YOUR CODE                                #</span></div><div class="line"><span class="comment">#################################################################################</span></div></pre></td></tr></table></figure><pre><code>1 / 144
</code></pre><p>​</p><pre><code>cs231n\classifiers\neural_net.py:104: RuntimeWarning: overflow encountered in exp
  exp_scores = np.exp(scores)
cs231n\classifiers\neural_net.py:105: RuntimeWarning: invalid value encountered in divide
  a2 = exp_scores / np.sum(exp_scores, axis=1, keepdims=True)
cs231n\classifiers\neural_net.py:107: RuntimeWarning: divide by zero encountered in log
  correct_log_probs = -np.log(a2[range(N), y])
cs231n\classifiers\neural_net.py:81: RuntimeWarning: invalid value encountered in maximum
  a1 = np.maximum(0, z1)
cs231n\classifiers\neural_net.py:131: RuntimeWarning: invalid value encountered in less_equal
  dhidden[z1 &lt;= 0] = 0
cs231n\classifiers\neural_net.py:247: RuntimeWarning: invalid value encountered in maximum
  a1 = np.maximum(0, z1)  # pass through ReLU activation function


2 / 144
3 / 144
4 / 144
5 / 144
6 / 144
7 / 144
8 / 144
9 / 144
10 / 144
11 / 144
12 / 144
13 / 144
14 / 144
15 / 144
16 / 144
17 / 144
18 / 144
19 / 144
20 / 144
21 / 144
22 / 144
23 / 144
24 / 144
25 / 144
26 / 144
27 / 144
28 / 144
29 / 144
30 / 144
31 / 144
32 / 144
33 / 144
34 / 144
35 / 144
36 / 144
37 / 144
38 / 144
39 / 144
40 / 144
41 / 144
42 / 144
43 / 144
44 / 144
45 / 144
46 / 144
47 / 144
48 / 144
49 / 144
50 / 144
51 / 144
52 / 144
53 / 144
54 / 144
55 / 144
56 / 144
57 / 144
58 / 144
59 / 144
60 / 144
61 / 144
62 / 144
63 / 144
64 / 144
65 / 144
66 / 144
67 / 144
68 / 144
69 / 144
70 / 144
71 / 144
72 / 144
73 / 144
74 / 144
75 / 144
76 / 144
77 / 144
78 / 144
79 / 144
80 / 144
81 / 144
82 / 144
83 / 144
84 / 144
85 / 144
86 / 144
87 / 144
88 / 144
89 / 144
90 / 144
91 / 144
92 / 144
93 / 144
94 / 144
95 / 144
96 / 144
97 / 144
98 / 144
99 / 144
100 / 144
101 / 144
102 / 144
103 / 144
104 / 144
105 / 144
106 / 144
107 / 144
108 / 144
109 / 144
110 / 144
111 / 144
112 / 144
113 / 144
114 / 144
115 / 144
116 / 144
117 / 144
118 / 144
119 / 144
120 / 144
121 / 144
122 / 144
123 / 144
124 / 144
125 / 144
126 / 144
127 / 144
128 / 144
129 / 144
130 / 144
131 / 144
132 / 144
133 / 144
134 / 144
135 / 144
136 / 144
137 / 144
138 / 144
139 / 144
140 / 144
141 / 144
142 / 144
143 / 144
144 / 144
best validation accuracy achieved during cross-validation: 0.540000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># visualize the weights of the best network</span></div><div class="line">show_net_weights(best_net)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/two_layer_net/output_21_0.png" alt="png"></p><h1 id="Run-on-the-test-set"><a href="#Run-on-the-test-set" class="headerlink" title="Run on the test set"></a>Run on the test set</h1><p>When you are done experimenting, you should evaluate your final trained network on the test set; you should get above 48%.</p><p><strong>We will give you extra bonus point for every 1% of accuracy above 52%.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test_acc = (best_net.predict(X_test) == y_test).mean()</div><div class="line"><span class="keyword">print</span> <span class="string">'Test accuracy: '</span>, test_acc</div></pre></td></tr></table></figure><pre><code>Test accuracy:  0.531
</code></pre><p>​</p><h1 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLayerNet</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    A two-layer fully-connected neural network. The net has an input dimension of</div><div class="line">    N, a hidden layer dimension of H, and performs classification over C classes.</div><div class="line">    We train the network with a softmax loss function and L2 regularization on the</div><div class="line">    weight matrices. The network uses a ReLU nonlinearity after the first fully</div><div class="line">    connected layer.</div><div class="line"></div><div class="line">    In other words, the network has the following architecture:</div><div class="line"></div><div class="line">    input - fully connected layer - ReLU - fully connected layer - softmax</div><div class="line"></div><div class="line">    The outputs of the second fully-connected layer are the scores for each class.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, std=<span class="number">1e-4</span>)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Initialize the model. Weights are initialized to small random values and</div><div class="line">        biases are initialized to zero. Weights and biases are stored in the</div><div class="line">        variable self.params, which is a dictionary with the following keys:</div><div class="line"></div><div class="line">        W1: First layer weights; has shape (D, H)</div><div class="line">        b1: First layer biases; has shape (H,)</div><div class="line">        W2: Second layer weights; has shape (H, C)</div><div class="line">        b2: Second layer biases; has shape (C,)</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - input_size: The dimension D of the input data.</div><div class="line">        - hidden_size: The number of neurons H in the hidden layer.</div><div class="line">        - output_size: The number of classes C.</div><div class="line">        """</div><div class="line">        self.params = &#123;&#125;</div><div class="line">        self.params[<span class="string">'W1'</span>] = std * np.random.randn(input_size, hidden_size)</div><div class="line">        self.params[<span class="string">'b1'</span>] = np.zeros(hidden_size)</div><div class="line">        self.params[<span class="string">'W2'</span>] = std * np.random.randn(hidden_size, output_size)</div><div class="line">        self.params[<span class="string">'b2'</span>] = np.zeros(output_size)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X, y=None, reg=<span class="number">0.0</span>)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Compute the loss and gradients for a two layer fully connected neural</div><div class="line">        network.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: Input data of shape (N, D). Each X[i] is a training sample.</div><div class="line">        - y: Vector of training labels. y[i] is the label for X[i], and each y[i] is</div><div class="line">          an integer in the range 0 &lt;= y[i] &lt; C. This parameter is optional; if it</div><div class="line">          is not passed then we only return scores, and if it is passed then we</div><div class="line">          instead return the loss and gradients.</div><div class="line">        - reg: Regularization strength.</div><div class="line"></div><div class="line">        Returns:</div><div class="line">        If y is None, return a matrix scores of shape (N, C) where scores[i, c] is</div><div class="line">        the score for class c on input X[i].</div><div class="line"></div><div class="line">        If y is not None, instead return a tuple of:</div><div class="line">        - loss: Loss (data loss and regularization loss) for this batch of training</div><div class="line">          samples.</div><div class="line">        - grads: Dictionary mapping parameter names to gradients of those parameters</div><div class="line">          with respect to the loss function; has the same keys as self.params.</div><div class="line">        """</div><div class="line">        <span class="comment"># Unpack variables from the params dictionary</span></div><div class="line">        W1, b1 = self.params[<span class="string">'W1'</span>], self.params[<span class="string">'b1'</span>]</div><div class="line">        W2, b2 = self.params[<span class="string">'W2'</span>], self.params[<span class="string">'b2'</span>]</div><div class="line">        N, D = X.shape</div><div class="line"></div><div class="line">        <span class="comment"># Compute the forward pass</span></div><div class="line">        scores = <span class="keyword">None</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span> Perform the forward pass, computing the class scores for the input. #</span></div><div class="line">        <span class="comment"># Store the result in the scores variable, which should be an array of      #</span></div><div class="line">        <span class="comment"># shape (N,C).                                                             #</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        <span class="comment"># First layer pre-activation</span></div><div class="line">        z1 = X.dot(W1) + b1</div><div class="line"></div><div class="line">        <span class="comment"># First layer activation</span></div><div class="line">        a1 = np.maximum(<span class="number">0</span>, z1)</div><div class="line"></div><div class="line">        <span class="comment"># Second layer pre-activation</span></div><div class="line">        z2 = a1.dot(W2) + b2</div><div class="line"></div><div class="line">        scores = z2</div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        <span class="comment">#                              END OF YOUR CODE                             #</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">        <span class="comment"># If the targets are not given then jump out, we're done</span></div><div class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> scores</div><div class="line"></div><div class="line">        <span class="comment"># Compute the loss</span></div><div class="line">        loss = <span class="keyword">None</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span> Finish the forward pass, and compute the loss. This should include  #</span></div><div class="line">        <span class="comment"># both the data loss and L2 regularization for W1 and W2. Store the result  #</span></div><div class="line">        <span class="comment"># in the variable loss, which should be a scalar. Use the Softmax           #</span></div><div class="line">        <span class="comment"># classifier loss. So that your results match ours, multiply the            #</span></div><div class="line">        <span class="comment"># regularization loss by 0.5                                                #</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        exp_scores = np.exp(scores)</div><div class="line">        a2 = exp_scores / np.sum(exp_scores, axis=<span class="number">1</span>, keepdims=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">        correct_log_probs = -np.log(a2[range(N), y])</div><div class="line">        data_loss = np.sum(correct_log_probs) / N</div><div class="line">        reg_loss = <span class="number">0.5</span> * reg * (np.sum(W1 * W1) + np.sum(W2 * W2))</div><div class="line"></div><div class="line">        loss = data_loss + reg_loss</div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        <span class="comment">#                              END OF YOUR CODE                             #</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">        <span class="comment"># Backward pass: compute gradients</span></div><div class="line">        grads = &#123;&#125;</div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span> Compute the backward pass, computing the derivatives of the weights #</span></div><div class="line">        <span class="comment"># and biases. Store the results in the grads dictionary. For example,       #</span></div><div class="line">        <span class="comment"># grads['W1'] should store the gradient on W1, and be a matrix of same size #</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        dscores = a2</div><div class="line">        dscores[range(N), y] -= <span class="number">1</span></div><div class="line">        dscores /= N</div><div class="line"></div><div class="line">        grads[<span class="string">'W2'</span>] = np.dot(a1.T, dscores)</div><div class="line">        grads[<span class="string">'b2'</span>] = np.sum(dscores, axis=<span class="number">0</span>)</div><div class="line"></div><div class="line">        dhidden = np.dot(dscores, W2.T)</div><div class="line">        dhidden[z1 &lt;= <span class="number">0</span>] = <span class="number">0</span></div><div class="line"></div><div class="line">        grads[<span class="string">'W1'</span>] = np.dot(X.T, dhidden)</div><div class="line">        grads[<span class="string">'b1'</span>] = np.sum(dhidden, axis=<span class="number">0</span>)</div><div class="line"></div><div class="line">        grads[<span class="string">'W2'</span>] += reg * W2</div><div class="line">        grads[<span class="string">'W1'</span>] += reg * W1</div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line">        <span class="comment">#                              END OF YOUR CODE                             #</span></div><div class="line">        <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> loss, grads</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y, X_val, y_val,</span></span></div><div class="line">              learning_rate=<span class="number">1e-3</span>, learning_rate_decay=<span class="number">0.95</span>,</div><div class="line">              reg=<span class="number">1e-5</span>, num_iters=<span class="number">100</span>,</div><div class="line">              batch_size=<span class="number">200</span>, verbose=False):</div><div class="line">        <span class="string">"""</span></div><div class="line">        Train this neural network using stochastic gradient descent.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: A numpy array of shape (N, D) giving training data.</div><div class="line">        - y: A numpy array f shape (N,) giving training labels; y[i] = c means that</div><div class="line">          X[i] has label c, where 0 &lt;= c &lt; C.</div><div class="line">        - X_val: A numpy array of shape (N_val, D) giving validation data.</div><div class="line">        - y_val: A numpy array of shape (N_val,) giving validation labels.</div><div class="line">        - learning_rate: Scalar giving learning rate for optimization.</div><div class="line">        - learning_rate_decay: Scalar giving factor used to decay the learning rate</div><div class="line">          after each epoch.</div><div class="line">        - reg: Scalar giving regularization strength.</div><div class="line">        - num_iters: Number of steps to take when optimizing.</div><div class="line">        - batch_size: Number of training examples to use per step.</div><div class="line">        - verbose: boolean; if true print progress during optimization.</div><div class="line">        """</div><div class="line">        num_train = X.shape[<span class="number">0</span>]</div><div class="line">        iterations_per_epoch = max(num_train / batch_size, <span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="comment"># Use SGD to optimize the parameters in self.model</span></div><div class="line">        loss_history = []</div><div class="line">        train_acc_history = []</div><div class="line">        val_acc_history = []</div><div class="line"></div><div class="line">        <span class="keyword">for</span> it <span class="keyword">in</span> xrange(num_iters):</div><div class="line">            X_batch = <span class="keyword">None</span></div><div class="line">            y_batch = <span class="keyword">None</span></div><div class="line"></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span> Create a random minibatch of training data and labels, storing  #</span></div><div class="line">            <span class="comment"># them in X_batch and y_batch respectively.                             #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            sample_indices = np.random.choice(num_train, batch_size)</div><div class="line">            X_batch = X[sample_indices]</div><div class="line">            y_batch = y[sample_indices]</div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment">#                             END OF YOUR CODE                          #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line"></div><div class="line">            <span class="comment"># Compute loss and gradients using the current minibatch</span></div><div class="line">            loss, grads = self.loss(X_batch, y=y_batch, reg=reg)</div><div class="line">            loss_history.append(loss)</div><div class="line"></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span> Use the gradients in the grads dictionary to update the         #</span></div><div class="line">            <span class="comment"># parameters of the network (stored in the dictionary self.params)      #</span></div><div class="line">            <span class="comment"># using stochastic gradient descent. You'll need to use the gradients   #</span></div><div class="line">            <span class="comment"># stored in the grads dictionary defined above.                         #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            self.params[<span class="string">'W1'</span>] += -learning_rate * grads[<span class="string">'W1'</span>]</div><div class="line">            self.params[<span class="string">'b1'</span>] += -learning_rate * grads[<span class="string">'b1'</span>]</div><div class="line">            self.params[<span class="string">'W2'</span>] += -learning_rate * grads[<span class="string">'W2'</span>]</div><div class="line">            self.params[<span class="string">'b2'</span>] += -learning_rate * grads[<span class="string">'b2'</span>]</div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment">#                             END OF YOUR CODE                          #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> it % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'iteration %d / %d: loss %f'</span> % (it, num_iters, loss)</div><div class="line"></div><div class="line">            <span class="comment"># Every epoch, check train and val accuracy and decay learning rate.</span></div><div class="line">            <span class="keyword">if</span> it % iterations_per_epoch == <span class="number">0</span>:</div><div class="line">                <span class="comment"># Check accuracy</span></div><div class="line">                train_acc = (self.predict(X_batch) == y_batch).mean()</div><div class="line">                val_acc = (self.predict(X_val) == y_val).mean()</div><div class="line">                train_acc_history.append(train_acc)</div><div class="line">                val_acc_history.append(val_acc)</div><div class="line"></div><div class="line">                <span class="comment"># Decay learning rate</span></div><div class="line">                learning_rate *= learning_rate_decay</div><div class="line"></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="string">'loss_history'</span>: loss_history,</div><div class="line">            <span class="string">'train_acc_history'</span>: train_acc_history,</div><div class="line">            <span class="string">'val_acc_history'</span>: val_acc_history,</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Use the trained weights of this two-layer network to predict labels for</div><div class="line">        data points. For each data point we predict scores for each of the C</div><div class="line">        classes, and assign each data point to the class with the highest score.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: A numpy array of shape (N, D) giving N D-dimensional data points to</div><div class="line">          classify.</div><div class="line"></div><div class="line">        Returns:</div><div class="line">        - y_pred: A numpy array of shape (N,) giving predicted labels for each of</div><div class="line">          the elements of X. For all i, y_pred[i] = c means that X[i] is predicted</div><div class="line">          to have class c, where 0 &lt;= c &lt; C.</div><div class="line">        """</div><div class="line">        y_pred = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span> Implement this function; it should be VERY simple!                #</span></div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        z1 = X.dot(self.params[<span class="string">'W1'</span>]) + self.params[<span class="string">'b1'</span>]</div><div class="line">        a1 = np.maximum(<span class="number">0</span>, z1)  <span class="comment"># pass through ReLU activation function</span></div><div class="line">        scores = a1.dot(self.params[<span class="string">'W2'</span>]) + self.params[<span class="string">'b2'</span>]</div><div class="line">        y_pred = np.argmax(scores, axis=<span class="number">1</span>)</div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="comment">#                              END OF YOUR CODE                           #</span></div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> y_pred</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Implementing-a-Neural-Network&quot;&gt;&lt;a href=&quot;#Implementing-a-Neural-Network&quot; class=&quot;headerlink&quot; title=&quot;Implementing a Neural Network&quot;&gt;&lt;/a
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>python data analysis learning note 09</title>
    <link href="http://yoursite.com/2017/03/07/python-data-analysis-learning-note-09/"/>
    <id>http://yoursite.com/2017/03/07/python-data-analysis-learning-note-09/</id>
    <published>2017-03-07T07:37:24.000Z</published>
    <updated>2017-03-07T07:50:31.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据聚合与分组运算"><a href="#数据聚合与分组运算" class="headerlink" title="数据聚合与分组运算"></a>数据聚合与分组运算</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">np.random.seed(<span class="number">12345</span>)</div><div class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">np.set_printoptions(precision=<span class="number">4</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pd.options.display.notebook_repr_html = <span class="keyword">False</span></div><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div></pre></td></tr></table></figure><h2 id="GroupBy-机制"><a href="#GroupBy-机制" class="headerlink" title="GroupBy 机制"></a>GroupBy 机制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df = DataFrame(&#123;<span class="string">'key1'</span> : [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>],</div><div class="line">                <span class="string">'key2'</span> : [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</div><div class="line">                <span class="string">'data1'</span> : np.random.randn(<span class="number">5</span>),</div><div class="line">                <span class="string">'data2'</span> : np.random.randn(<span class="number">5</span>)&#125;)</div><div class="line">df</div></pre></td></tr></table></figure><pre><code>      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
4  1.965781  1.246435    a  one
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</div><div class="line">grouped</div></pre></td></tr></table></figure><pre><code>&lt;pandas.core.groupby.SeriesGroupBy object at 0x0000000008BAFA90&gt;
</code></pre><p>变量<code>groupby</code>是一个<code>GroupBy</code>对象。它实际还没有进行任何计算，只有进行计算之后才能显示结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.mean()</div></pre></td></tr></table></figure><pre><code>key1
a    0.746672
b   -0.537585
Name: data1, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">means = df[<span class="string">'data1'</span>].groupby([df[<span class="string">'key1'</span>], df[<span class="string">'key2'</span>]]).mean()</div><div class="line">means</div></pre></td></tr></table></figure><pre><code>key1  key2
a     one     0.880536
      two     0.478943
b     one    -0.519439
      two    -0.555730
Name: data1, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">means.unstack()</div></pre></td></tr></table></figure><pre><code>key2       one       two
key1                    
a     0.880536  0.478943
b    -0.519439 -0.555730
</code></pre><p>只要长度相同即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">states = np.array([<span class="string">'Ohio'</span>, <span class="string">'California'</span>, <span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>])</div><div class="line">years = np.array([<span class="number">2005</span>, <span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</div><div class="line">df[<span class="string">'data1'</span>].groupby([states, years]).mean()</div></pre></td></tr></table></figure><pre><code>California  2005    0.478943
            2006   -0.519439
Ohio        2005   -0.380219
            2006    1.965781
Name: data1, dtype: float64
</code></pre><p>只要数值型数据才会出现在结果中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>).mean()</div></pre></td></tr></table></figure><pre><code>         data1     data2
key1                    
a     0.746672  0.910916
b    -0.537585  0.525384
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).mean()</div></pre></td></tr></table></figure><pre><code>              data1     data2
key1 key2                    
a    one   0.880536  1.319920
     two   0.478943  0.092908
b    one  -0.519439  0.281746
     two  -0.555730  0.769023
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).size()</div></pre></td></tr></table></figure><pre><code>key1  key2
a     one     2
      two     1
b     one     1
      two     1
dtype: int64
</code></pre><h3 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h3><p>显示分组数据（要通过这种迭代的方式才能显示）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>)</div></pre></td></tr></table></figure><pre><code>&lt;pandas.core.groupby.DataFrameGroupBy object at 0x0000000034BC8CF8&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df</div><div class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> df.groupby(<span class="string">'key1'</span>):</div><div class="line">    print(name)</div><div class="line">    print(group)</div></pre></td></tr></table></figure><pre><code>      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
4  1.965781  1.246435    a  one



a
      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
4  1.965781  1.246435    a  one
b
      data1     data2 key1 key2
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
</code></pre><p>同样进行迭代才能显示结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (k1, k2), group <span class="keyword">in</span> df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]):</div><div class="line">    print((k1, k2))</div><div class="line">    print(group)</div></pre></td></tr></table></figure><pre><code>(&#39;a&#39;, &#39;one&#39;)
      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
4  1.965781  1.246435    a  one
(&#39;a&#39;, &#39;two&#39;)
      data1     data2 key1 key2
1  0.478943  0.092908    a  two
(&#39;b&#39;, &#39;one&#39;)
      data1     data2 key1 key2
2 -0.519439  0.281746    b  one
(&#39;b&#39;, &#39;two&#39;)
     data1     data2 key1 key2
3 -0.55573  0.769023    b  two
</code></pre><p>将分组结果转化成一个字典（要先转化为一个列表）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pieces = dict(list(df.groupby(<span class="string">'key1'</span>)))</div><div class="line">pieces[<span class="string">'b'</span>]</div></pre></td></tr></table></figure><pre><code>      data1     data2 key1 key2
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
</code></pre><p>显示每一项的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure><pre><code>data1    float64
data2    float64
key1      object
key2      object
dtype: object
</code></pre><p>对列进行分组…按照数据类型来？！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = df.groupby(df.dtypes, axis=<span class="number">1</span>)</div><div class="line">dict(list(grouped))</div></pre></td></tr></table></figure><pre><code>{dtype(&#39;float64&#39;):       data1     data2
 0 -0.204708  1.393406
 1  0.478943  0.092908
 2 -0.519439  0.281746
 3 -0.555730  0.769023
 4  1.965781  1.246435, dtype(&#39;O&#39;):   key1 key2
 0    a  one
 1    a  two
 2    b  one
 3    b  two
 4    a  one}
</code></pre><h3 id="选择一列或一组列"><a href="#选择一列或一组列" class="headerlink" title="选择一列或一组列"></a>选择一列或一组列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>)[<span class="string">'data1'</span>]</div><div class="line">df.groupby(<span class="string">'key1'</span>)[[<span class="string">'data2'</span>]]</div></pre></td></tr></table></figure><pre><code>&lt;pandas.core.groupby.SeriesGroupBy object at 0x0000000034BDC2E8&gt;






&lt;pandas.core.groupby.DataFrameGroupBy object at 0x0000000015EDF2B0&gt;
</code></pre><p>上述代码是以下代码的语法糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</div><div class="line">df[[<span class="string">'data2'</span>]].groupby(df[<span class="string">'key1'</span>])</div></pre></td></tr></table></figure><pre><code>&lt;pandas.core.groupby.SeriesGroupBy object at 0x0000000034BDC8D0&gt;






&lt;pandas.core.groupby.DataFrameGroupBy object at 0x0000000034BDC898&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>])[[<span class="string">'data2'</span>]].mean()</div></pre></td></tr></table></figure><pre><code>              data2
key1 key2          
a    one   1.319920
     two   0.092908
b    one   0.281746
     two   0.769023
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s_grouped = df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>])[<span class="string">'data2'</span>]</div><div class="line">s_grouped</div></pre></td></tr></table></figure><pre><code>&lt;pandas.core.groupby.SeriesGroupBy object at 0x0000000034BDC6A0&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s_grouped.mean()</div></pre></td></tr></table></figure><pre><code>key1  key2
a     one     1.319920
      two     0.092908
b     one     0.281746
      two     0.769023
Name: data2, dtype: float64
</code></pre><h3 id="通过字典或Series进行分组"><a href="#通过字典或Series进行分组" class="headerlink" title="通过字典或Series进行分组"></a>通过字典或Series进行分组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">people = DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</div><div class="line">                   columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>],</div><div class="line">                   index=[<span class="string">'Joe'</span>, <span class="string">'Steve'</span>, <span class="string">'Wes'</span>, <span class="string">'Jim'</span>, <span class="string">'Travis'</span>])</div><div class="line">people.ix[<span class="number">2</span>:<span class="number">3</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>]] = np.nan <span class="comment"># Add a few NA values</span></div><div class="line">people</div></pre></td></tr></table></figure><pre><code>               a         b         c         d         e
Joe     1.007189 -1.296221  0.274992  0.228913  1.352917
Steve   0.886429 -2.001637 -0.371843  1.669025 -0.438570
Wes    -0.539741       NaN       NaN -1.021228 -0.577087
Jim     0.124121  0.302614  0.523772  0.000940  1.343810
Travis -0.713544 -0.831154 -2.370232 -1.860761 -0.860757
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mapping = &#123;<span class="string">'a'</span>: <span class="string">'red'</span>, <span class="string">'b'</span>: <span class="string">'red'</span>, <span class="string">'c'</span>: <span class="string">'blue'</span>,</div><div class="line">           <span class="string">'d'</span>: <span class="string">'blue'</span>, <span class="string">'e'</span>: <span class="string">'red'</span>, <span class="string">'f'</span> : <span class="string">'orange'</span>&#125;</div></pre></td></tr></table></figure><p>会跳过NA值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">by_column = people.groupby(mapping, axis=<span class="number">1</span>)</div><div class="line">by_column.sum()</div></pre></td></tr></table></figure><pre><code>            blue       red
Joe     0.503905  1.063885
Steve   1.297183 -1.553778
Wes    -1.021228 -1.116829
Jim     0.524712  1.770545
Travis -4.230992 -2.405455
</code></pre><p>上述功能同样可以通过Series实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">map_series = Series(mapping)</div><div class="line">map_series</div></pre></td></tr></table></figure><pre><code>a       red
b       red
c      blue
d      blue
e       red
f    orange
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.groupby(map_series, axis=<span class="number">1</span>).count()</div></pre></td></tr></table></figure><pre><code>        blue  red
Joe        2    3
Steve      2    3
Wes        1    2
Jim        2    3
Travis     2    3
</code></pre><h3 id="通过函数进行分组"><a href="#通过函数进行分组" class="headerlink" title="通过函数进行分组"></a>通过函数进行分组</h3><p>根据人名长度进行分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.groupby(len).sum()</div></pre></td></tr></table></figure><pre><code>          a         b         c         d         e
3  0.591569 -0.993608  0.798764 -0.791374  2.119639
5  0.886429 -2.001637 -0.371843  1.669025 -0.438570
6 -0.713544 -0.831154 -2.370232 -1.860761 -0.860757
</code></pre><p>再加一个分组度量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key_list = [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>]</div><div class="line">people.groupby([len, key_list]).min()</div></pre></td></tr></table></figure><pre><code>              a         b         c         d         e
3 one -0.539741 -1.296221  0.274992 -1.021228 -0.577087
  two  0.124121  0.302614  0.523772  0.000940  1.343810
5 one  0.886429 -2.001637 -0.371843  1.669025 -0.438570
6 two -0.713544 -0.831154 -2.370232 -1.860761 -0.860757
</code></pre><h3 id="根据索引级别分组"><a href="#根据索引级别分组" class="headerlink" title="根据索引级别分组"></a>根据索引级别分组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">columns = pd.MultiIndex.from_arrays([[<span class="string">'US'</span>, <span class="string">'US'</span>, <span class="string">'US'</span>, <span class="string">'JP'</span>, <span class="string">'JP'</span>],</div><div class="line">                                    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]], names=[<span class="string">'cty'</span>, <span class="string">'tenor'</span>])</div><div class="line">hier_df = DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">5</span>), columns=columns)</div><div class="line">hier_df</div></pre></td></tr></table></figure><pre><code>cty          US                            JP          
tenor         1         3         5         1         3
0      0.560145 -1.265934  0.119827 -1.063512  0.332883
1     -2.359419 -0.199543 -1.541996 -0.970736 -1.307030
2      0.286350  0.377984 -0.753887  0.331286  1.349742
3      0.069877  0.246674 -0.011862  1.004812  1.327195
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hier_df.groupby(level=<span class="string">'cty'</span>, axis=<span class="number">1</span>).count()</div></pre></td></tr></table></figure><pre><code>cty  JP  US
0     2   3
1     2   3
2     2   3
3     2   3
</code></pre><h2 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df</div></pre></td></tr></table></figure><pre><code>      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
4  1.965781  1.246435    a  one
</code></pre><p>对分组后的数据进行相应操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = df.groupby(<span class="string">'key1'</span>)</div><div class="line">grouped[<span class="string">'data1'</span>].quantile(<span class="number">0.9</span>)</div></pre></td></tr></table></figure><pre><code>key1
a    1.668413
b   -0.523068
Name: data1, dtype: float64
</code></pre><p>通过函数进行聚合操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">return</span> arr.max() - arr.min()</div><div class="line">grouped.agg(peak_to_peak)</div></pre></td></tr></table></figure><pre><code>         data1     data2
key1                    
a     2.170488  1.300498
b     0.036292  0.487276
</code></pre><p>列出分组后数据的一些常用属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.describe()</div></pre></td></tr></table></figure><pre><code>               data1     data2
key1                          
a    count  3.000000  3.000000
     mean   0.746672  0.910916
     std    1.109736  0.712217
     min   -0.204708  0.092908
     25%    0.137118  0.669671
     50%    0.478943  1.246435
     75%    1.222362  1.319920
     max    1.965781  1.393406
b    count  2.000000  2.000000
     mean  -0.537585  0.525384
     std    0.025662  0.344556
     min   -0.555730  0.281746
     25%   -0.546657  0.403565
     50%   -0.537585  0.525384
     75%   -0.528512  0.647203
     max   -0.519439  0.769023
</code></pre><p>导入一个数据集用于接下来更加高级的聚合操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tips = pd.read_csv(<span class="string">'ch08/tips.csv'</span>)</div><div class="line"><span class="comment"># Add tip percentage of total bill</span></div><div class="line">tips[<span class="string">'tip_pct'</span>] = tips[<span class="string">'tip'</span>] / tips[<span class="string">'total_bill'</span>]</div><div class="line">tips[:<span class="number">6</span>]</div></pre></td></tr></table></figure><pre><code>   total_bill   tip     sex smoker  day    time  size_   tip_pct
0       16.99  1.01  Female     No  Sun  Dinner      2  0.059447
1       10.34  1.66    Male     No  Sun  Dinner      3  0.160542
2       21.01  3.50    Male     No  Sun  Dinner      3  0.166587
3       23.68  3.31    Male     No  Sun  Dinner      2  0.139780
4       24.59  3.61  Female     No  Sun  Dinner      4  0.146808
5       25.29  4.71    Male     No  Sun  Dinner      4  0.186240
</code></pre><h3 id="面向列的多函数应用"><a href="#面向列的多函数应用" class="headerlink" title="面向列的多函数应用"></a>面向列的多函数应用</h3><p>根据性别以及是否吸烟进行分类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped = tips.groupby([<span class="string">'sex'</span>, <span class="string">'smoker'</span>])</div></pre></td></tr></table></figure><p>算出不同类型的顾客所给的小费占总花费的比例的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped_pct = grouped[<span class="string">'tip_pct'</span>]</div><div class="line">grouped_pct.agg(<span class="string">'mean'</span>)</div></pre></td></tr></table></figure><pre><code>sex     smoker
Female  No        0.156921
        Yes       0.182150
Male    No        0.160669
        Yes       0.152771
Name: tip_pct, dtype: float64
</code></pre><p>同时算出比例的均值、标准差以及范围大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped_pct.agg([<span class="string">'mean'</span>, <span class="string">'std'</span>, peak_to_peak])</div></pre></td></tr></table></figure><pre><code>                   mean       std  peak_to_peak
sex    smoker                                  
Female No      0.156921  0.036421      0.195876
       Yes     0.182150  0.071595      0.360233
Male   No      0.160669  0.041849      0.220186
       Yes     0.152771  0.090588      0.674707
</code></pre><p>起一个别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped_pct.agg([(<span class="string">'foo'</span>, <span class="string">'mean'</span>), (<span class="string">'bar'</span>, np.std)])</div></pre></td></tr></table></figure><pre><code>                    foo       bar
sex    smoker                    
Female No      0.156921  0.036421
       Yes     0.182150  0.071595
Male   No      0.160669  0.041849
       Yes     0.152771  0.090588
</code></pre><p>对分组后的数据的两个属性分别做三个不同的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">functions = [<span class="string">'count'</span>, <span class="string">'mean'</span>, <span class="string">'max'</span>]</div><div class="line">result = grouped[<span class="string">'tip_pct'</span>, <span class="string">'total_bill'</span>].agg(functions)</div><div class="line">result</div></pre></td></tr></table></figure><pre><code>              tip_pct                     total_bill                  
                count      mean       max      count       mean    max
sex    smoker                                                         
Female No          54  0.156921  0.252672         54  18.105185  35.83
       Yes         33  0.182150  0.416667         33  17.977879  44.30
Male   No          97  0.160669  0.291990         97  19.791237  48.33
       Yes         60  0.152771  0.710345         60  22.284500  50.81
</code></pre><p>提取出上述两个属性中的一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result[<span class="string">'tip_pct'</span>]</div></pre></td></tr></table></figure><pre><code>               count      mean       max
sex    smoker                           
Female No         54  0.156921  0.252672
       Yes        33  0.182150  0.416667
Male   No         97  0.160669  0.291990
       Yes        60  0.152771  0.710345
</code></pre><p>对多个属性进行多个操作的同时进行起别名的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ftuples = [(<span class="string">'Durchschnitt'</span>, <span class="string">'mean'</span>), (<span class="string">'Abweichung'</span>, np.var)]</div><div class="line">grouped[<span class="string">'tip_pct'</span>, <span class="string">'total_bill'</span>].agg(ftuples)</div></pre></td></tr></table></figure><pre><code>                   tip_pct              total_bill           
              Durchschnitt Abweichung Durchschnitt Abweichung
sex    smoker                                                
Female No         0.156921   0.001327    18.105185  53.092422
       Yes        0.182150   0.005126    17.977879  84.451517
Male   No         0.160669   0.001751    19.791237  76.152961
       Yes        0.152771   0.008206    22.284500  98.244673
</code></pre><p>对不同的列进行不同的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.agg(&#123;<span class="string">'tip'</span> : np.max, <span class="string">'size_'</span> : <span class="string">'sum'</span>&#125;)</div></pre></td></tr></table></figure><pre><code>               size_   tip
sex    smoker             
Female No        140   5.2
       Yes        74   6.5
Male   No        263   9.0
       Yes       150  10.0
</code></pre><p>对不同的列进行数量不同类型不同的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped.agg(&#123;<span class="string">'tip_pct'</span> : [<span class="string">'min'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>, <span class="string">'std'</span>],</div><div class="line">             <span class="string">'size_'</span> : <span class="string">'sum'</span>&#125;)</div></pre></td></tr></table></figure><pre><code>                tip_pct                               size_
                    min       max      mean       std   sum
sex    smoker                                              
Female No      0.056797  0.252672  0.156921  0.036421   140
       Yes     0.056433  0.416667  0.182150  0.071595    74
Male   No      0.071804  0.291990  0.160669  0.041849   263
       Yes     0.035638  0.710345  0.152771  0.090588   150
</code></pre><h3 id="以无索引的形式返回聚合数据"><a href="#以无索引的形式返回聚合数据" class="headerlink" title="以无索引的形式返回聚合数据"></a>以无索引的形式返回聚合数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby([<span class="string">'sex'</span>, <span class="string">'smoker'</span>], as_index=<span class="keyword">False</span>).mean()</div></pre></td></tr></table></figure><pre><code>      sex smoker  total_bill       tip     size_   tip_pct
0  Female     No   18.105185  2.773519  2.592593  0.156921
1  Female    Yes   17.977879  2.931515  2.242424  0.182150
2    Male     No   19.791237  3.113402  2.711340  0.160669
3    Male    Yes   22.284500  3.051167  2.500000  0.152771
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby([<span class="string">'sex'</span>, <span class="string">'smoker'</span>], as_index=<span class="keyword">True</span>).mean()</div></pre></td></tr></table></figure><pre><code>               total_bill       tip     size_   tip_pct
sex    smoker                                          
Female No       18.105185  2.773519  2.592593  0.156921
       Yes      17.977879  2.931515  2.242424  0.182150
Male   No       19.791237  3.113402  2.711340  0.160669
       Yes      22.284500  3.051167  2.500000  0.152771
</code></pre><h2 id="分组级运算和转换"><a href="#分组级运算和转换" class="headerlink" title="分组级运算和转换"></a>分组级运算和转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df</div></pre></td></tr></table></figure><pre><code>      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
4  1.965781  1.246435    a  one
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">k1_means = df.groupby(<span class="string">'key1'</span>).mean().add_prefix(<span class="string">'mean_'</span>)</div><div class="line">k1_means</div></pre></td></tr></table></figure><pre><code>      mean_data1  mean_data2
key1                        
a       0.746672    0.910916
b      -0.537585    0.525384
</code></pre><p>保留原索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(df, k1_means, left_on=<span class="string">'key1'</span>, right_index=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>      data1     data2 key1 key2  mean_data1  mean_data2
0 -0.204708  1.393406    a  one    0.746672    0.910916
1  0.478943  0.092908    a  two    0.746672    0.910916
4  1.965781  1.246435    a  one    0.746672    0.910916
2 -0.519439  0.281746    b  one   -0.537585    0.525384
3 -0.555730  0.769023    b  two   -0.537585    0.525384
</code></pre><p>另一个例子，以更简洁的方式实现上述功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people</div></pre></td></tr></table></figure><pre><code>               a         b         c         d         e
Joe     1.007189 -1.296221  0.274992  0.228913  1.352917
Steve   0.886429 -2.001637 -0.371843  1.669025 -0.438570
Wes    -0.539741       NaN       NaN -1.021228 -0.577087
Jim     0.124121  0.302614  0.523772  0.000940  1.343810
Travis -0.713544 -0.831154 -2.370232 -1.860761 -0.860757
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>]</div><div class="line">people.groupby(key).mean()</div></pre></td></tr></table></figure><pre><code>            a         b         c         d         e
one -0.082032 -1.063687 -1.047620 -0.884358 -0.028309
two  0.505275 -0.849512  0.075965  0.834983  0.452620
</code></pre><p>将聚合后的结果放回原来数据中合适的位置（标量进行广播）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.groupby(key).transform(np.mean)</div></pre></td></tr></table></figure><pre><code>               a         b         c         d         e
Joe    -0.082032 -1.063687 -1.047620 -0.884358 -0.028309
Steve   0.505275 -0.849512  0.075965  0.834983  0.452620
Wes    -0.082032 -1.063687 -1.047620 -0.884358 -0.028309
Jim     0.505275 -0.849512  0.075965  0.834983  0.452620
Travis -0.082032 -1.063687 -1.047620 -0.884358 -0.028309
</code></pre><p>同时减去均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demean</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">return</span> arr - arr.mean()</div><div class="line">demeaned = people.groupby(key).transform(demean)</div><div class="line">demeaned</div></pre></td></tr></table></figure><pre><code>               a         b         c         d         e
Joe     1.089221 -0.232534  1.322612  1.113271  1.381226
Steve   0.381154 -1.152125 -0.447807  0.834043 -0.891190
Wes    -0.457709       NaN       NaN -0.136869 -0.548778
Jim    -0.381154  1.152125  0.447807 -0.834043  0.891190
Travis -0.631512  0.232534 -1.322612 -0.976402 -0.832448
</code></pre><p>检验一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demeaned.groupby(key).mean()</div></pre></td></tr></table></figure><pre><code>                a             b    c             d    e
one  0.000000e+00 -1.110223e-16  0.0  7.401487e-17  0.0
two -2.775558e-17  0.000000e+00  0.0  0.000000e+00  0.0
</code></pre><h3 id="Apply-一般性的-“拆分-应用-合并”"><a href="#Apply-一般性的-“拆分-应用-合并”" class="headerlink" title="Apply: 一般性的 “拆分-应用-合并”"></a>Apply: 一般性的 “拆分-应用-合并”</h3><p>小费数据，根据某一个属性从大到小进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(df, n=<span class="number">5</span>, column=<span class="string">'tip_pct'</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> df.sort_values(by=column)[-n:]</div><div class="line">top(tips, n=<span class="number">6</span>)</div></pre></td></tr></table></figure><pre><code>     total_bill   tip     sex smoker  day    time  size_   tip_pct
109       14.31  4.00  Female    Yes  Sat  Dinner      2  0.279525
183       23.17  6.50    Male    Yes  Sun  Dinner      4  0.280535
232       11.61  3.39    Male     No  Sat  Dinner      2  0.291990
67         3.07  1.00  Female    Yes  Sat  Dinner      1  0.325733
178        9.60  4.00  Female    Yes  Sun  Dinner      2  0.416667
172        7.25  5.15    Male    Yes  Sun  Dinner      2  0.710345
</code></pre><p>在分组后的数据集上进行上述排序操作，说明分组后的每一组都是一个DataFrame对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby(<span class="string">'smoker'</span>).apply(top)</div></pre></td></tr></table></figure><pre><code>            total_bill   tip     sex smoker   day    time  size_   tip_pct
smoker                                                                    
No     88        24.71  5.85    Male     No  Thur   Lunch      2  0.236746
       185       20.69  5.00    Male     No   Sun  Dinner      5  0.241663
       51        10.29  2.60  Female     No   Sun  Dinner      2  0.252672
       149        7.51  2.00    Male     No  Thur   Lunch      2  0.266312
       232       11.61  3.39    Male     No   Sat  Dinner      2  0.291990
Yes    109       14.31  4.00  Female    Yes   Sat  Dinner      2  0.279525
       183       23.17  6.50    Male    Yes   Sun  Dinner      4  0.280535
       67         3.07  1.00  Female    Yes   Sat  Dinner      1  0.325733
       178        9.60  4.00  Female    Yes   Sun  Dinner      2  0.416667
       172        7.25  5.15    Male    Yes   Sun  Dinner      2  0.710345
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby([<span class="string">'smoker'</span>, <span class="string">'day'</span>]).apply(top, n=<span class="number">1</span>, column=<span class="string">'total_bill'</span>)</div></pre></td></tr></table></figure><pre><code>                 total_bill    tip     sex smoker   day    time  size_  \
smoker day                                                               
No     Fri  94        22.75   3.25  Female     No   Fri  Dinner      2   
       Sat  212       48.33   9.00    Male     No   Sat  Dinner      4   
       Sun  156       48.17   5.00    Male     No   Sun  Dinner      6   
       Thur 142       41.19   5.00    Male     No  Thur   Lunch      5   
Yes    Fri  95        40.17   4.73    Male    Yes   Fri  Dinner      4   
       Sat  170       50.81  10.00    Male    Yes   Sat  Dinner      3   
       Sun  182       45.35   3.50    Male    Yes   Sun  Dinner      3   
       Thur 197       43.11   5.00  Female    Yes  Thur   Lunch      4   

                  tip_pct  
smoker day                 
No     Fri  94   0.142857  
       Sat  212  0.186220  
       Sun  156  0.103799  
       Thur 142  0.121389  
Yes    Fri  95   0.117750  
       Sat  170  0.196812  
       Sun  182  0.077178  
       Thur 197  0.115982  
</code></pre><p>获取分组后数据某一列的统计数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = tips.groupby(<span class="string">'smoker'</span>)[<span class="string">'tip_pct'</span>].describe()</div><div class="line">result</div></pre></td></tr></table></figure><pre><code>smoker       
No      count    151.000000
        mean       0.159328
        std        0.039910
        min        0.056797
        25%        0.136906
        50%        0.155625
        75%        0.185014
        max        0.291990
Yes     count     93.000000
        mean       0.163196
        std        0.085119
        min        0.035638
        25%        0.106771
        50%        0.153846
        75%        0.195059
        max        0.710345
Name: tip_pct, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.unstack(<span class="string">'smoker'</span>)</div></pre></td></tr></table></figure><pre><code>smoker          No        Yes
count   151.000000  93.000000
mean      0.159328   0.163196
std       0.039910   0.085119
min       0.056797   0.035638
25%       0.136906   0.106771
50%       0.155625   0.153846
75%       0.185014   0.195059
max       0.291990   0.710345
</code></pre><p>grouped 根据性别以及是否吸烟进行分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = <span class="keyword">lambda</span> x: x.describe()</div><div class="line">grouped.apply(f)</div></pre></td></tr></table></figure><pre><code>                     total_bill        tip      size_    tip_pct
sex    smoker                                                   
Female No     count   54.000000  54.000000  54.000000  54.000000
              mean    18.105185   2.773519   2.592593   0.156921
              std      7.286455   1.128425   1.073146   0.036421
              min      7.250000   1.000000   1.000000   0.056797
              25%     12.650000   2.000000   2.000000   0.139708
              50%     16.690000   2.680000   2.000000   0.149691
              75%     20.862500   3.437500   3.000000   0.181630
              max     35.830000   5.200000   6.000000   0.252672
       Yes    count   33.000000  33.000000  33.000000  33.000000
              mean    17.977879   2.931515   2.242424   0.182150
              std      9.189751   1.219916   0.613917   0.071595
              min      3.070000   1.000000   1.000000   0.056433
              25%     12.760000   2.000000   2.000000   0.152439
              50%     16.270000   2.880000   2.000000   0.173913
              75%     22.120000   3.500000   2.000000   0.198216
              max     44.300000   6.500000   4.000000   0.416667
Male   No     count   97.000000  97.000000  97.000000  97.000000
              mean    19.791237   3.113402   2.711340   0.160669
              std      8.726566   1.489559   0.989094   0.041849
              min      7.510000   1.250000   2.000000   0.071804
              25%     13.810000   2.000000   2.000000   0.131810
              50%     18.240000   2.740000   2.000000   0.157604
              75%     22.820000   3.710000   3.000000   0.186220
              max     48.330000   9.000000   6.000000   0.291990
       Yes    count   60.000000  60.000000  60.000000  60.000000
              mean    22.284500   3.051167   2.500000   0.152771
              std      9.911845   1.500120   0.892530   0.090588
              min      7.250000   1.000000   1.000000   0.035638
              25%     15.272500   2.000000   2.000000   0.101845
              50%     20.390000   3.000000   2.000000   0.141015
              75%     28.572500   3.820000   3.000000   0.191697
              max     50.810000  10.000000   5.000000   0.710345
</code></pre><h4 id="禁止分组键"><a href="#禁止分组键" class="headerlink" title="禁止分组键"></a>禁止分组键</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby(<span class="string">'smoker'</span>, group_keys=<span class="keyword">True</span>).apply(top)</div></pre></td></tr></table></figure><pre><code>            total_bill   tip     sex smoker   day    time  size_   tip_pct
smoker                                                                    
No     88        24.71  5.85    Male     No  Thur   Lunch      2  0.236746
       185       20.69  5.00    Male     No   Sun  Dinner      5  0.241663
       51        10.29  2.60  Female     No   Sun  Dinner      2  0.252672
       149        7.51  2.00    Male     No  Thur   Lunch      2  0.266312
       232       11.61  3.39    Male     No   Sat  Dinner      2  0.291990
Yes    109       14.31  4.00  Female    Yes   Sat  Dinner      2  0.279525
       183       23.17  6.50    Male    Yes   Sun  Dinner      4  0.280535
       67         3.07  1.00  Female    Yes   Sat  Dinner      1  0.325733
       178        9.60  4.00  Female    Yes   Sun  Dinner      2  0.416667
       172        7.25  5.15    Male    Yes   Sun  Dinner      2  0.710345
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby(<span class="string">'smoker'</span>, group_keys=<span class="keyword">False</span>).apply(top)</div></pre></td></tr></table></figure><pre><code>     total_bill   tip     sex smoker   day    time  size_   tip_pct
88        24.71  5.85    Male     No  Thur   Lunch      2  0.236746
185       20.69  5.00    Male     No   Sun  Dinner      5  0.241663
51        10.29  2.60  Female     No   Sun  Dinner      2  0.252672
149        7.51  2.00    Male     No  Thur   Lunch      2  0.266312
232       11.61  3.39    Male     No   Sat  Dinner      2  0.291990
109       14.31  4.00  Female    Yes   Sat  Dinner      2  0.279525
183       23.17  6.50    Male    Yes   Sun  Dinner      4  0.280535
67         3.07  1.00  Female    Yes   Sat  Dinner      1  0.325733
178        9.60  4.00  Female    Yes   Sun  Dinner      2  0.416667
172        7.25  5.15    Male    Yes   Sun  Dinner      2  0.710345
</code></pre><h3 id="分位数与桶分析"><a href="#分位数与桶分析" class="headerlink" title="分位数与桶分析"></a>分位数与桶分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame = DataFrame(&#123;<span class="string">'data1'</span>: np.random.randn(<span class="number">1000</span>),</div><div class="line">                   <span class="string">'data2'</span>: np.random.randn(<span class="number">1000</span>)&#125;)</div><div class="line">factor = pd.cut(frame.data1, <span class="number">4</span>)</div><div class="line">factor[:<span class="number">10</span>]</div></pre></td></tr></table></figure><pre><code>0     (-1.23, 0.489]
1    (-2.956, -1.23]
2     (-1.23, 0.489]
3     (0.489, 2.208]
4     (-1.23, 0.489]
5     (0.489, 2.208]
6     (-1.23, 0.489]
7     (-1.23, 0.489]
8     (0.489, 2.208]
9     (0.489, 2.208]
Name: data1, dtype: category
Categories (4, object): [(-2.956, -1.23] &lt; (-1.23, 0.489] &lt; (0.489, 2.208] &lt; (2.208, 3.928]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stats</span><span class="params">(group)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'min'</span>: group.min(), <span class="string">'max'</span>: group.max(),</div><div class="line">            <span class="string">'count'</span>: group.count(), <span class="string">'mean'</span>: group.mean()&#125;</div><div class="line"></div><div class="line">grouped = frame.data2.groupby(factor)</div><div class="line">grouped.apply(get_stats).unstack()</div><div class="line"></div><div class="line"><span class="comment">#ADAPT the output is not sorted in the book while this is the case now (swap first two lines)</span></div></pre></td></tr></table></figure><pre><code>                 count       max      mean       min
data1                                               
(-2.956, -1.23]   95.0  1.670835 -0.039521 -3.399312
(-1.23, 0.489]   598.0  3.260383 -0.002051 -2.989741
(0.489, 2.208]   297.0  2.954439  0.081822 -3.745356
(2.208, 3.928]    10.0  1.765640  0.024750 -1.929776
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Return quantile numbers</span></div><div class="line">grouping = pd.qcut(frame.data1, <span class="number">10</span>, labels=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">grouped = frame.data2.groupby(grouping)</div><div class="line">grouped.apply(get_stats).unstack()</div></pre></td></tr></table></figure><pre><code>       count       max      mean       min
data1                                     
0      100.0  1.670835 -0.049902 -3.399312
1      100.0  2.628441  0.030989 -1.950098
2      100.0  2.527939 -0.067179 -2.925113
3      100.0  3.260383  0.065713 -2.315555
4      100.0  2.074345 -0.111653 -2.047939
5      100.0  2.184810  0.052130 -2.989741
6      100.0  2.458842 -0.021489 -2.223506
7      100.0  2.954439 -0.026459 -3.056990
8      100.0  2.735527  0.103406 -3.745356
9      100.0  2.377020  0.220122 -2.064111
</code></pre><h3 id="Example-用特定分组的值填充缺失值"><a href="#Example-用特定分组的值填充缺失值" class="headerlink" title="Example: 用特定分组的值填充缺失值"></a>Example: 用特定分组的值填充缺失值</h3><p>填一些缺失值进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = Series(np.random.randn(<span class="number">6</span>))</div><div class="line">s[::<span class="number">2</span>] = np.nan</div><div class="line">s</div></pre></td></tr></table></figure><pre><code>0         NaN
1   -0.125921
2         NaN
3   -0.884475
4         NaN
5    0.227290
dtype: float64
</code></pre><p>用均值填充缺失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.fillna(s.mean())</div></pre></td></tr></table></figure><pre><code>0   -0.261035
1   -0.125921
2   -0.261035
3   -0.884475
4   -0.261035
5    0.227290
dtype: float64
</code></pre><p>同样，填一些缺失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">states = [<span class="string">'Ohio'</span>, <span class="string">'New York'</span>, <span class="string">'Vermont'</span>, <span class="string">'Florida'</span>,</div><div class="line">          <span class="string">'Oregon'</span>, <span class="string">'Nevada'</span>, <span class="string">'California'</span>, <span class="string">'Idaho'</span>]</div><div class="line">group_key = [<span class="string">'East'</span>] * <span class="number">4</span> + [<span class="string">'West'</span>] * <span class="number">4</span></div><div class="line">data = Series(np.random.randn(<span class="number">8</span>), index=states)</div><div class="line">data[[<span class="string">'Vermont'</span>, <span class="string">'Nevada'</span>, <span class="string">'Idaho'</span>]] = np.nan</div><div class="line">data</div></pre></td></tr></table></figure><pre><code>Ohio          0.922264
New York     -2.153545
Vermont            NaN
Florida      -0.375842
Oregon        0.329939
Nevada             NaN
California    1.105913
Idaho              NaN
dtype: float64
</code></pre><p>计算分组均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.groupby(group_key).mean()</div></pre></td></tr></table></figure><pre><code>East   -0.535707
West    0.717926
dtype: float64
</code></pre><p>这里的<code>g</code>指代调用<code>apply</code>的主体，也就是<code>data.groupby(group_key)</code>分组后的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fill_mean = <span class="keyword">lambda</span> g: g.fillna(g.mean())</div><div class="line">data.groupby(group_key).apply(fill_mean)</div></pre></td></tr></table></figure><pre><code>Ohio          0.922264
New York     -2.153545
Vermont      -0.535707
Florida      -0.375842
Oregon        0.329939
Nevada        0.717926
California    1.105913
Idaho         0.717926
dtype: float64
</code></pre><p>由于<code>groupby</code>操作后得到的结果类似于一个字典，字典<code>key</code>是组名，<code>value</code>是一个<code>DataFrame Object</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fill_values = &#123;<span class="string">'East'</span>: <span class="number">0.5</span>, <span class="string">'West'</span>: <span class="number">-1</span>&#125;</div><div class="line">fill_func = <span class="keyword">lambda</span> g: g.fillna(fill_values[g.name])</div><div class="line"></div><div class="line">data.groupby(group_key).apply(fill_func)</div></pre></td></tr></table></figure><pre><code>Ohio          0.922264
New York     -2.153545
Vermont       0.500000
Florida      -0.375842
Oregon        0.329939
Nevada       -1.000000
California    1.105913
Idaho        -1.000000
dtype: float64
</code></pre><h3 id="Example-随机采样和排列"><a href="#Example-随机采样和排列" class="headerlink" title="Example: 随机采样和排列"></a>Example: 随机采样和排列</h3><p>构造扑克牌</p><p>红桃<code>Hearts</code>, 黑桃<code>Spades</code>, 梅花<code>Clubs</code>, 方片<code>Diamonds</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Hearts, Spades, Clubs, Diamonds</span></div><div class="line">suits = [<span class="string">'H'</span>, <span class="string">'S'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>]</div><div class="line">card_val = (list(range(<span class="number">1</span>, <span class="number">11</span>)) + [<span class="number">10</span>] * <span class="number">3</span>) * <span class="number">4</span></div><div class="line">base_names = [<span class="string">'A'</span>] + range(<span class="number">2</span>, <span class="number">11</span>) + [<span class="string">'J'</span>, <span class="string">'K'</span>, <span class="string">'Q'</span>]</div><div class="line">cards = []</div><div class="line"><span class="keyword">for</span> suit <span class="keyword">in</span> [<span class="string">'H'</span>, <span class="string">'S'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>]:</div><div class="line">    cards.extend(str(num) + suit <span class="keyword">for</span> num <span class="keyword">in</span> base_names)</div><div class="line"></div><div class="line">deck = Series(card_val, index=cards)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deck[:<span class="number">13</span>]</div></pre></td></tr></table></figure><pre><code>AH      1
2H      2
3H      3
4H      4
5H      5
6H      6
7H      7
8H      8
9H      9
10H    10
JH     10
KH     10
QH     10
dtype: int64
</code></pre><p>随机抽牌</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(deck, n=<span class="number">5</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> deck.take(np.random.permutation(len(deck))[:n])</div><div class="line">draw(deck)</div></pre></td></tr></table></figure><pre><code>AD     1
8C     8
5H     5
KC    10
2C     2
dtype: int64
</code></pre><p>分类抽牌</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">get_suit = <span class="keyword">lambda</span> card: card[<span class="number">-1</span>] <span class="comment"># last letter is suit</span></div><div class="line">deck.groupby(get_suit).apply(draw, n=<span class="number">2</span>)</div></pre></td></tr></table></figure><pre><code>C  2C     2
   3C     3
D  KD    10
   8D     8
H  KH    10
   3H     3
S  2S     2
   4S     4
dtype: int64
</code></pre><p>去掉分组键</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># alternatively</span></div><div class="line">deck.groupby(get_suit, group_keys=<span class="keyword">False</span>).apply(draw, n=<span class="number">2</span>)</div></pre></td></tr></table></figure><pre><code>KC    10
JC    10
AD     1
5D     5
5H     5
6H     6
7S     7
KS    10
dtype: int64
</code></pre><h3 id="Example-分组加权平均数和相关系数"><a href="#Example-分组加权平均数和相关系数" class="headerlink" title="Example: 分组加权平均数和相关系数"></a>Example: 分组加权平均数和相关系数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df = DataFrame(&#123;<span class="string">'category'</span>: [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>],</div><div class="line">                <span class="string">'data'</span>: np.random.randn(<span class="number">8</span>),</div><div class="line">                <span class="string">'weights'</span>: np.random.rand(<span class="number">8</span>)&#125;)</div><div class="line">df</div></pre></td></tr></table></figure><pre><code>  category      data   weights
0        a  1.561587  0.957515
1        a  1.219984  0.347267
2        a -0.482239  0.581362
3        a  0.315667  0.217091
4        b -0.047852  0.894406
5        b -0.454145  0.918564
6        b -0.556774  0.277825
7        b  0.253321  0.955905
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grouped = df.groupby(<span class="string">'category'</span>)</div><div class="line">get_wavg = <span class="keyword">lambda</span> g: np.average(g[<span class="string">'data'</span>], weights=g[<span class="string">'weights'</span>])</div><div class="line">grouped.apply(get_wavg)</div></pre></td></tr></table></figure><pre><code>category
a    0.811643
b   -0.122262
dtype: float64
</code></pre><p><code>stock</code>数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close_px = pd.read_csv(<span class="string">'ch09/stock_px.csv'</span>, parse_dates=<span class="keyword">True</span>, index_col=<span class="number">0</span>)</div><div class="line">close_px.info()</div></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
DatetimeIndex: 2214 entries, 2003-01-02 to 2011-10-14
Data columns (total 4 columns):
AAPL    2214 non-null float64
MSFT    2214 non-null float64
XOM     2214 non-null float64
SPX     2214 non-null float64
dtypes: float64(4)
memory usage: 86.5 KB
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px[<span class="number">-4</span>:]</div></pre></td></tr></table></figure><pre><code>              AAPL   MSFT    XOM      SPX
2011-10-11  400.29  27.00  76.27  1195.54
2011-10-12  402.19  26.96  77.16  1207.25
2011-10-13  408.43  27.18  76.37  1203.66
2011-10-14  422.00  27.27  78.11  1224.58
</code></pre><p>计算相关系数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rets = close_px.pct_change().dropna()</div><div class="line">spx_corr = <span class="keyword">lambda</span> x: x.corrwith(x[<span class="string">'SPX'</span>])</div><div class="line">by_year = rets.groupby(<span class="keyword">lambda</span> x: x.year)</div><div class="line">by_year.apply(spx_corr)</div></pre></td></tr></table></figure><pre><code>          AAPL      MSFT       XOM  SPX
2003  0.541124  0.745174  0.661265  1.0
2004  0.374283  0.588531  0.557742  1.0
2005  0.467540  0.562374  0.631010  1.0
2006  0.428267  0.406126  0.518514  1.0
2007  0.508118  0.658770  0.786264  1.0
2008  0.681434  0.804626  0.828303  1.0
2009  0.707103  0.654902  0.797921  1.0
2010  0.710105  0.730118  0.839057  1.0
2011  0.691931  0.800996  0.859975  1.0
</code></pre><p><code>lambda</code>看来有很大用处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Annual correlation of Apple with Microsoft</span></div><div class="line">by_year.apply(<span class="keyword">lambda</span> g: g[<span class="string">'AAPL'</span>].corr(g[<span class="string">'MSFT'</span>]))</div></pre></td></tr></table></figure><pre><code>2003    0.480868
2004    0.259024
2005    0.300093
2006    0.161735
2007    0.417738
2008    0.611901
2009    0.432738
2010    0.571946
2011    0.581987
dtype: float64
</code></pre><h3 id="Example-分组级线型回归"><a href="#Example-分组级线型回归" class="headerlink" title="Example: 分组级线型回归"></a>Example: 分组级线型回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">regress</span><span class="params">(data, yvar, xvars)</span>:</span></div><div class="line">    Y = data[yvar]</div><div class="line">    X = data[xvars]</div><div class="line">    X[<span class="string">'intercept'</span>] = <span class="number">1.</span></div><div class="line">    result = sm.OLS(Y, X).fit()</div><div class="line">    <span class="keyword">return</span> result.params</div></pre></td></tr></table></figure><p>这样传参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">by_year.apply(regress, <span class="string">'AAPL'</span>, [<span class="string">'SPX'</span>])</div></pre></td></tr></table></figure><pre><code>           SPX  intercept
2003  1.195406   0.000710
2004  1.363463   0.004201
2005  1.766415   0.003246
2006  1.645496   0.000080
2007  1.198761   0.003438
2008  0.968016  -0.001110
2009  0.879103   0.002954
2010  1.052608   0.001261
2011  0.806605   0.001514
</code></pre><h2 id="透视表和交叉表"><a href="#透视表和交叉表" class="headerlink" title="透视表和交叉表"></a>透视表和交叉表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips[:<span class="number">10</span>]</div></pre></td></tr></table></figure><pre><code>   total_bill   tip     sex smoker  day    time  size_   tip_pct
0       16.99  1.01  Female     No  Sun  Dinner      2  0.059447
1       10.34  1.66    Male     No  Sun  Dinner      3  0.160542
2       21.01  3.50    Male     No  Sun  Dinner      3  0.166587
3       23.68  3.31    Male     No  Sun  Dinner      2  0.139780
4       24.59  3.61  Female     No  Sun  Dinner      4  0.146808
5       25.29  4.71    Male     No  Sun  Dinner      4  0.186240
6        8.77  2.00    Male     No  Sun  Dinner      2  0.228050
7       26.88  3.12    Male     No  Sun  Dinner      4  0.116071
8       15.04  1.96    Male     No  Sun  Dinner      2  0.130319
9       14.78  3.23    Male     No  Sun  Dinner      2  0.218539
</code></pre><p><code>pivot_table</code>默认情况相当于分组后进行<code>mean()</code>操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table(index=[<span class="string">'sex'</span>, <span class="string">'smoker'</span>])</div></pre></td></tr></table></figure><pre><code>                  size_       tip   tip_pct  total_bill
sex    smoker                                          
Female No      2.592593  2.773519  0.156921   18.105185
       Yes     2.242424  2.931515  0.182150   17.977879
Male   No      2.711340  3.113402  0.160669   19.791237
       Yes     2.500000  3.051167  0.152771   22.284500
</code></pre><p>指定分组度量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table([<span class="string">'tip_pct'</span>, <span class="string">'size_'</span>], index=[<span class="string">'sex'</span>, <span class="string">'day'</span>],</div><div class="line">                 columns=<span class="string">'smoker'</span>)</div></pre></td></tr></table></figure><pre><code>              tip_pct               size_          
smoker             No       Yes        No       Yes
sex    day                                         
Female Fri   0.165296  0.209129  2.500000  2.000000
       Sat   0.147993  0.163817  2.307692  2.200000
       Sun   0.165710  0.237075  3.071429  2.500000
       Thur  0.155971  0.163073  2.480000  2.428571
Male   Fri   0.138005  0.144730  2.000000  2.125000
       Sat   0.162132  0.139067  2.656250  2.629630
       Sun   0.158291  0.173964  2.883721  2.600000
       Thur  0.165706  0.164417  2.500000  2.300000
</code></pre><p>增加ALL列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table([<span class="string">'tip_pct'</span>, <span class="string">'size_'</span>], index=[<span class="string">'sex'</span>, <span class="string">'day'</span>],</div><div class="line">                 columns=<span class="string">'smoker'</span>, margins=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>              tip_pct                         size_                    
smoker             No       Yes       All        No       Yes       All
sex    day                                                             
Female Fri   0.165296  0.209129  0.199388  2.500000  2.000000  2.111111
       Sat   0.147993  0.163817  0.156470  2.307692  2.200000  2.250000
       Sun   0.165710  0.237075  0.181569  3.071429  2.500000  2.944444
       Thur  0.155971  0.163073  0.157525  2.480000  2.428571  2.468750
Male   Fri   0.138005  0.144730  0.143385  2.000000  2.125000  2.100000
       Sat   0.162132  0.139067  0.151577  2.656250  2.629630  2.644068
       Sun   0.158291  0.173964  0.162344  2.883721  2.600000  2.810345
       Thur  0.165706  0.164417  0.165276  2.500000  2.300000  2.433333
All          0.159328  0.163196  0.160803  2.668874  2.408602  2.569672
</code></pre><p>更换一个分组度量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table(<span class="string">'tip_pct'</span>, index=[<span class="string">'sex'</span>, <span class="string">'smoker'</span>], columns=<span class="string">'day'</span>,</div><div class="line">                 aggfunc=len, margins=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>day             Fri   Sat   Sun  Thur    All
sex    smoker                               
Female No       2.0  13.0  14.0  25.0   54.0
       Yes      7.0  15.0   4.0   7.0   33.0
Male   No       2.0  32.0  43.0  20.0   97.0
       Yes      8.0  27.0  15.0  10.0   60.0
All            19.0  87.0  76.0  62.0  244.0
</code></pre><p>分组计数并填充（可能存在空组合）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table(<span class="string">'size_'</span>, index=[<span class="string">'time'</span>, <span class="string">'sex'</span>, <span class="string">'smoker'</span>],</div><div class="line">                 columns=<span class="string">'day'</span>, aggfunc=<span class="string">'sum'</span>, fill_value=<span class="number">0</span>)</div></pre></td></tr></table></figure><pre><code>day                   Fri  Sat  Sun  Thur
time   sex    smoker                     
Dinner Female No        2   30   43     2
              Yes       8   33   10     0
       Male   No        4   85  124     0
              Yes      12   71   39     0
Lunch  Female No        3    0    0    60
              Yes       6    0    0    17
       Male   No        0    0    0    50
              Yes       5    0    0    23
</code></pre><h3 id="交叉表-crosstab"><a href="#交叉表-crosstab" class="headerlink" title="交叉表: crosstab"></a>交叉表: crosstab</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</div><div class="line">data = <span class="string">"""\</span></div><div class="line">Sample    Gender    Handedness</div><div class="line">1    Female    Right-handed</div><div class="line">2    Male    Left-handed</div><div class="line">3    Female    Right-handed</div><div class="line">4    Male    Right-handed</div><div class="line">5    Male    Left-handed</div><div class="line">6    Male    Right-handed</div><div class="line">7    Female    Right-handed</div><div class="line">8    Female    Left-handed</div><div class="line">9    Male    Right-handed</div><div class="line">10    Female    Right-handed"""</div><div class="line">data = pd.read_table(StringIO(data), sep=<span class="string">'\s+'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data</div></pre></td></tr></table></figure><pre><code>   Sample  Gender    Handedness
0       1  Female  Right-handed
1       2    Male   Left-handed
2       3  Female  Right-handed
3       4    Male  Right-handed
4       5    Male   Left-handed
5       6    Male  Right-handed
6       7  Female  Right-handed
7       8  Female   Left-handed
8       9    Male  Right-handed
9      10  Female  Right-handed
</code></pre><p>交叉表就是在…计数…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.crosstab(data.Gender, data.Handedness, margins=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>Handedness  Left-handed  Right-handed  All
Gender                                    
Female                1             4    5
Male                  2             3    5
All                   3             7   10
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.crosstab([tips.time, tips.day], tips.smoker, margins=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>smoker        No  Yes  All
time   day                
Dinner Fri     3    9   12
       Sat    45   42   87
       Sun    57   19   76
       Thur    1    0    1
Lunch  Fri     1    6    7
       Thur   44   17   61
All          151   93  244
</code></pre><h2 id="Example-2012-联邦选举委员会数据库"><a href="#Example-2012-联邦选举委员会数据库" class="headerlink" title="Example: 2012 联邦选举委员会数据库"></a>Example: 2012 联邦选举委员会数据库</h2><p>这个数据库包括赞助人的姓名，职业、雇主、地址以及出资额等信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec = pd.read_csv(<span class="string">'ch09/P00000001-ALL.csv'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec.info()</div></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 1001731 entries, 0 to 1001730
Data columns (total 16 columns):
cmte_id              1001731 non-null object
cand_id              1001731 non-null object
cand_nm              1001731 non-null object
contbr_nm            1001731 non-null object
contbr_city          1001712 non-null object
contbr_st            1001727 non-null object
contbr_zip           1001620 non-null object
contbr_employer      988002 non-null object
contbr_occupation    993301 non-null object
contb_receipt_amt    1001731 non-null float64
contb_receipt_dt     1001731 non-null object
receipt_desc         14166 non-null object
memo_cd              92482 non-null object
memo_text            97770 non-null object
form_tp              1001731 non-null object
file_num             1001731 non-null int64
dtypes: float64(1), int64(1), object(14)
memory usage: 122.3+ MB
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec.ix[<span class="number">123456</span>]</div></pre></td></tr></table></figure><pre><code>cmte_id                             C00431445
cand_id                             P80003338
cand_nm                         Obama, Barack
contbr_nm                         ELLMAN, IRA
contbr_city                             TEMPE
contbr_st                                  AZ
contbr_zip                          852816719
contbr_employer      ARIZONA STATE UNIVERSITY
contbr_occupation                   PROFESSOR
contb_receipt_amt                          50
contb_receipt_dt                    01-DEC-11
receipt_desc                              NaN
memo_cd                                   NaN
memo_text                                 NaN
form_tp                                 SA17A
file_num                               772372
Name: 123456, dtype: object
</code></pre><p>输出全部候选人名单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unique_cands = fec.cand_nm.unique()</div><div class="line">unique_cands</div></pre></td></tr></table></figure><pre><code>array([&#39;Bachmann, Michelle&#39;, &#39;Romney, Mitt&#39;, &#39;Obama, Barack&#39;,
       &quot;Roemer, Charles E. &#39;Buddy&#39; III&quot;, &#39;Pawlenty, Timothy&#39;,
       &#39;Johnson, Gary Earl&#39;, &#39;Paul, Ron&#39;, &#39;Santorum, Rick&#39;, &#39;Cain, Herman&#39;,
       &#39;Gingrich, Newt&#39;, &#39;McCotter, Thaddeus G&#39;, &#39;Huntsman, Jon&#39;,
       &#39;Perry, Rick&#39;], dtype=object)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unique_cands[<span class="number">2</span>]</div></pre></td></tr></table></figure><pre><code>&#39;Obama, Barack&#39;
</code></pre><p>政党映射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">parties = &#123;<span class="string">'Bachmann, Michelle'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Cain, Herman'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Gingrich, Newt'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Huntsman, Jon'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Johnson, Gary Earl'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'McCotter, Thaddeus G'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Obama, Barack'</span>: <span class="string">'Democrat'</span>,</div><div class="line">           <span class="string">'Paul, Ron'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Pawlenty, Timothy'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Perry, Rick'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">"Roemer, Charles E. 'Buddy' III"</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Romney, Mitt'</span>: <span class="string">'Republican'</span>,</div><div class="line">           <span class="string">'Santorum, Rick'</span>: <span class="string">'Republican'</span>&#125;</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec.cand_nm[<span class="number">123456</span>:<span class="number">123461</span>]</div></pre></td></tr></table></figure><pre><code>123456    Obama, Barack
123457    Obama, Barack
123458    Obama, Barack
123459    Obama, Barack
123460    Obama, Barack
Name: cand_nm, dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec.cand_nm[<span class="number">123456</span>:<span class="number">123461</span>].map(parties)</div></pre></td></tr></table></figure><pre><code>123456    Democrat
123457    Democrat
123458    Democrat
123459    Democrat
123460    Democrat
Name: cand_nm, dtype: object
</code></pre><p>根据以上创建的映射，在原数据集中添加一列<code>party</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Add it as a column</span></div><div class="line">fec[<span class="string">'party'</span>] = fec.cand_nm.map(parties)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec[<span class="string">'party'</span>].value_counts()</div></pre></td></tr></table></figure><pre><code>Democrat      593746
Republican    407985
Name: party, dtype: int64
</code></pre><p>看看出资额是正是负</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(fec.contb_receipt_amt &gt; <span class="number">0</span>).value_counts()</div></pre></td></tr></table></figure><pre><code>True     991475
False     10256
Name: contb_receipt_amt, dtype: int64
</code></pre><p>调整出资额为正</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec = fec[fec.contb_receipt_amt &gt; <span class="number">0</span>]</div></pre></td></tr></table></figure><p>筛选候选人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec_mrbo = fec[fec.cand_nm.isin([<span class="string">'Obama, Barack'</span>, <span class="string">'Romney, Mitt'</span>])]</div></pre></td></tr></table></figure><h3 id="根据职业和雇主统计赞助信息"><a href="#根据职业和雇主统计赞助信息" class="headerlink" title="根据职业和雇主统计赞助信息"></a>根据职业和雇主统计赞助信息</h3><p>统计职业信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fec.contbr_occupation.value_counts()[:<span class="number">10</span>]</div></pre></td></tr></table></figure><pre><code>RETIRED                                   233990
INFORMATION REQUESTED                      35107
ATTORNEY                                   34286
HOMEMAKER                                  29931
PHYSICIAN                                  23432
INFORMATION REQUESTED PER BEST EFFORTS     21138
ENGINEER                                   14334
TEACHER                                    13990
CONSULTANT                                 13273
PROFESSOR                                  12555
Name: contbr_occupation, dtype: int64
</code></pre><p>筛选出一些不符合规格的信息映射到正常信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">occ_mapping = &#123;</div><div class="line">   <span class="string">'INFORMATION REQUESTED PER BEST EFFORTS'</span> : <span class="string">'NOT PROVIDED'</span>,</div><div class="line">   <span class="string">'INFORMATION REQUESTED'</span> : <span class="string">'NOT PROVIDED'</span>,</div><div class="line">   <span class="string">'INFORMATION REQUESTED (BEST EFFORTS)'</span> : <span class="string">'NOT PROVIDED'</span>,</div><div class="line">   <span class="string">'C.E.O.'</span>: <span class="string">'CEO'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># If no mapping provided, return x</span></div><div class="line">f = <span class="keyword">lambda</span> x: occ_mapping.get(x, x)</div><div class="line">fec.contbr_occupation = fec.contbr_occupation.map(f)</div></pre></td></tr></table></figure><p>以上巧妙运用了get方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">emp_mapping = &#123;</div><div class="line">   <span class="string">'INFORMATION REQUESTED PER BEST EFFORTS'</span> : <span class="string">'NOT PROVIDED'</span>,</div><div class="line">   <span class="string">'INFORMATION REQUESTED'</span> : <span class="string">'NOT PROVIDED'</span>,</div><div class="line">   <span class="string">'SELF'</span> : <span class="string">'SELF-EMPLOYED'</span>,</div><div class="line">   <span class="string">'SELF EMPLOYED'</span> : <span class="string">'SELF-EMPLOYED'</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># If no mapping provided, return x</span></div><div class="line">f = <span class="keyword">lambda</span> x: emp_mapping.get(x, x)</div><div class="line">fec.contbr_employer = fec.contbr_employer.map(f)</div></pre></td></tr></table></figure><p>根据职业以及候选人政党分组，统计出资额总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">by_occupation = fec.pivot_table(<span class="string">'contb_receipt_amt'</span>,</div><div class="line">                                index=<span class="string">'contbr_occupation'</span>,</div><div class="line">                                columns=<span class="string">'party'</span>, aggfunc=<span class="string">'sum'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">over_2mm = by_occupation[by_occupation.sum(<span class="number">1</span>) &gt; <span class="number">2000000</span>]</div><div class="line">over_2mm</div></pre></td></tr></table></figure><pre><code>party                 Democrat    Republican
contbr_occupation                           
ATTORNEY           11141982.97  7.477194e+06
CEO                 2074974.79  4.211041e+06
CONSULTANT          2459912.71  2.544725e+06
ENGINEER             951525.55  1.818374e+06
EXECUTIVE           1355161.05  4.138850e+06
HOMEMAKER           4248875.80  1.363428e+07
INVESTOR             884133.00  2.431769e+06
LAWYER              3160478.87  3.912243e+05
MANAGER              762883.22  1.444532e+06
NOT PROVIDED        4866973.96  2.056547e+07
OWNER               1001567.36  2.408287e+06
PHYSICIAN           3735124.94  3.594320e+06
PRESIDENT           1878509.95  4.720924e+06
PROFESSOR           2165071.08  2.967027e+05
REAL ESTATE          528902.09  1.625902e+06
RETIRED            25305116.38  2.356124e+07
SELF-EMPLOYED        672393.40  1.640253e+06
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">over_2mm.plot(kind=<span class="string">'barh'</span>)</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x340fb4e0&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch09/output_202_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_top_amounts</span><span class="params">(group, key, n=<span class="number">5</span>)</span>:</span></div><div class="line">    totals = group.groupby(key)[<span class="string">'contb_receipt_amt'</span>].sum()</div><div class="line"></div><div class="line">    <span class="comment"># Order totals by key in descending order</span></div><div class="line">    <span class="keyword">return</span> totals.sort_values()[-n:]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = fec_mrbo.groupby(<span class="string">'cand_nm'</span>)</div><div class="line">grouped.apply(get_top_amounts, <span class="string">'contbr_occupation'</span>, n=<span class="number">7</span>)</div></pre></td></tr></table></figure><pre><code>cand_nm        contbr_occupation                     
Obama, Barack  CONSULTANT                                 2459912.71
               LAWYER                                     3160478.87
               PHYSICIAN                                  3735124.94
               HOMEMAKER                                  4248875.80
               INFORMATION REQUESTED                      4866973.96
               ATTORNEY                                  11141982.97
               RETIRED                                   25305116.38
Romney, Mitt   C.E.O.                                     1968386.11
               EXECUTIVE                                  2300947.03
               PRESIDENT                                  2491244.89
               ATTORNEY                                   5364718.82
               HOMEMAKER                                  8147446.22
               INFORMATION REQUESTED PER BEST EFFORTS    11396894.84
               RETIRED                                   11508473.59
Name: contb_receipt_amt, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.apply(get_top_amounts, <span class="string">'contbr_employer'</span>, n=<span class="number">10</span>)</div></pre></td></tr></table></figure><pre><code>cand_nm        contbr_employer                       
Obama, Barack  MICROSOFT                                   215585.36
               VOLUNTEER                                   257104.00
               STUDENT                                     318831.45
               SELF EMPLOYED                               469290.00
               SELF                                       1076531.20
               HOMEMAKER                                  2605408.54
               INFORMATION REQUESTED                      5053480.37
               NOT EMPLOYED                               8586308.70
               SELF-EMPLOYED                             17080985.96
               RETIRED                                   22694358.85
Romney, Mitt   H.I.G. CAPITAL                              139500.00
               BARCLAYS CAPITAL                            162750.00
               GOLDMAN SACH &amp; CO.                          238250.00
               MORGAN STANLEY                              267266.00
               CREDIT SUISSE                               281150.00
               STUDENT                                     496490.94
               SELF-EMPLOYED                              7409860.98
               HOMEMAKER                                  8147196.22
               RETIRED                                   11506225.71
               INFORMATION REQUESTED PER BEST EFFORTS    12059527.24
Name: contb_receipt_amt, dtype: float64
</code></pre><h3 id="根据出资额分组"><a href="#根据出资额分组" class="headerlink" title="根据出资额分组"></a>根据出资额分组</h3><p>不出意外果然要用到桶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bins = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>])</div><div class="line">labels = pd.cut(fec_mrbo.contb_receipt_amt, bins)</div><div class="line">labels[:<span class="number">10</span>]</div></pre></td></tr></table></figure><pre><code>411      (10, 100]
412    (100, 1000]
413    (100, 1000]
414      (10, 100]
415      (10, 100]
416      (10, 100]
417    (100, 1000]
418      (10, 100]
419    (100, 1000]
420      (10, 100]
Name: contb_receipt_amt, dtype: category
Categories (8, object): [(0, 1] &lt; (1, 10] &lt; (10, 100] &lt; (100, 1000] &lt; (1000, 10000] &lt; (10000, 100000] &lt; (100000, 1000000] &lt; (1000000, 10000000]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = fec_mrbo.groupby([<span class="string">'cand_nm'</span>, labels])</div><div class="line">grouped.size().unstack(<span class="number">0</span>)</div></pre></td></tr></table></figure><pre><code>cand_nm              Obama, Barack  Romney, Mitt
contb_receipt_amt                               
(0, 1]                       493.0          77.0
(1, 10]                    40070.0        3681.0
(10, 100]                 372280.0       31853.0
(100, 1000]               153991.0       43357.0
(1000, 10000]              22284.0       26186.0
(10000, 100000]                2.0           1.0
(100000, 1000000]              3.0           NaN
(1000000, 10000000]            4.0           NaN
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bucket_sums = grouped.contb_receipt_amt.sum().unstack(<span class="number">0</span>)</div><div class="line">bucket_sums</div></pre></td></tr></table></figure><pre><code>cand_nm              Obama, Barack  Romney, Mitt
contb_receipt_amt                               
(0, 1]                      318.24         77.00
(1, 10]                  337267.62      29819.66
(10, 100]              20288981.41    1987783.76
(100, 1000]            54798531.46   22363381.69
(1000, 10000]          51753705.67   63942145.42
(10000, 100000]           59100.00      12700.00
(100000, 1000000]       1490683.08           NaN
(1000000, 10000000]     7148839.76           NaN
</code></pre><p>计算比例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">normed_sums = bucket_sums.div(bucket_sums.sum(axis=<span class="number">1</span>), axis=<span class="number">0</span>)</div><div class="line">normed_sums</div></pre></td></tr></table></figure><pre><code>cand_nm              Obama, Barack  Romney, Mitt
contb_receipt_amt                               
(0, 1]                    0.805182      0.194818
(1, 10]                   0.918767      0.081233
(10, 100]                 0.910769      0.089231
(100, 1000]               0.710176      0.289824
(1000, 10000]             0.447326      0.552674
(10000, 100000]           0.823120      0.176880
(100000, 1000000]         1.000000           NaN
(1000000, 10000000]       1.000000           NaN
</code></pre><p>画个图看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">normed_sums[:<span class="number">-2</span>].plot(kind=<span class="string">'barh'</span>, stacked=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x14c4db00&gt;
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch09/output_214_1.png" alt="png"></p><h3 id="根据州统计赞助信息"><a href="#根据州统计赞助信息" class="headerlink" title="根据州统计赞助信息"></a>根据州统计赞助信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grouped = fec_mrbo.groupby([<span class="string">'cand_nm'</span>, <span class="string">'contbr_st'</span>])</div><div class="line">totals = grouped.contb_receipt_amt.sum().unstack(<span class="number">0</span>).fillna(<span class="number">0</span>)</div><div class="line">totals = totals[totals.sum(<span class="number">1</span>) &gt; <span class="number">100000</span>]</div><div class="line">totals[:<span class="number">10</span>]</div></pre></td></tr></table></figure><pre><code>cand_nm    Obama, Barack  Romney, Mitt
contbr_st                             
AK             281840.15      86204.24
AL             543123.48     527303.51
AR             359247.28     105556.00
AZ            1506476.98    1888436.23
CA           23824984.24   11237636.60
CO            2132429.49    1506714.12
CT            2068291.26    3499475.45
DC            4373538.80    1025137.50
DE             336669.14      82712.00
FL            7318178.58    8338458.81
</code></pre><p><code>Mitt is so...poorly...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">percent = totals.div(totals.sum(<span class="number">1</span>), axis=<span class="number">0</span>)</div><div class="line">percent[:<span class="number">10</span>]</div></pre></td></tr></table></figure><pre><code>cand_nm    Obama, Barack  Romney, Mitt
contbr_st                             
AK              0.765778      0.234222
AL              0.507390      0.492610
AR              0.772902      0.227098
AZ              0.443745      0.556255
CA              0.679498      0.320502
CO              0.585970      0.414030
CT              0.371476      0.628524
DC              0.810113      0.189887
DE              0.802776      0.197224
FL              0.467417      0.532583
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据聚合与分组运算&quot;&gt;&lt;a href=&quot;#数据聚合与分组运算&quot; class=&quot;headerlink&quot; title=&quot;数据聚合与分组运算&quot;&gt;&lt;/a&gt;数据聚合与分组运算&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>cs231n Lecture4 note</title>
    <link href="http://yoursite.com/2017/03/06/cs231n-Lecture4-note/"/>
    <id>http://yoursite.com/2017/03/06/cs231n-Lecture4-note/</id>
    <published>2017-03-06T10:58:31.000Z</published>
    <updated>2017-03-07T14:18:11.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BackProp"><a href="#BackProp" class="headerlink" title="BackProp"></a>BackProp</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Motivation</strong>. In this section we will develop expertise with an intuitive understanding of <strong>backpropagation</strong>, which is a way of computing gradients of expressions through recursive application of <strong>chain rule</strong>. Understanding of this process and its subtleties is critical for you to understand, and effectively develop, design and debug Neural Networks.</p><p><strong>Problem statement</strong>. The core problem studied in this section is as follows: We are given some function $f(x)$ where $x$ is a vector of inputs and we are interested in computing the gradient of $f$ at $x$ (i.e. $\Delta f(x)$ ).</p><h2 id="Modularity-Sigmoid-example"><a href="#Modularity-Sigmoid-example" class="headerlink" title="Modularity: Sigmoid example"></a>Modularity: Sigmoid example</h2><script type="math/tex;mode=display">f(w,x) = \frac{1}{1+e^{-(w_0x_0 + w_1x_1 + w_2)}}</script><p>The function is made up of multiple gates. In addition to the ones described already above (add, mul, max), there are four more:</p><script type="math/tex;mode=display">f(x) = \frac{1}{x} 
\hspace{1in} \rightarrow \hspace{1in} 
\frac{df}{dx} = -1/x^2 
\\\\
f_c(x) = c + x
\hspace{1in} \rightarrow \hspace{1in} 
\frac{df}{dx} = 1 
\\\\
f(x) = e^x
\hspace{1in} \rightarrow \hspace{1in} 
\frac{df}{dx} = e^x
\\\\
f_a(x) = ax
\hspace{1in} \rightarrow \hspace{1in} 
\frac{df}{dx} = a</script><p>The full circuit then looks as follows:</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-note/04/circuit.png" alt="circuit"></p><p>In the example above, we see a long chain of function applications that operates on the result of the dot product between <strong>w,x</strong>. The function that these operations implement is called the <em>sigmoid function</em> $\sigma (x)$. It turns out that the derivative of the sigmoid function with respect to its input simplifies if you perform the derivation (after a fun tricky part where we add and subtract a 1 in the numerator):</p><script type="math/tex;mode=display">\sigma(x) = \frac{1}{1+e^{-x}} \\\\
\rightarrow \hspace{0.3in} \frac{d\sigma(x)}{dx} = \frac{e^{-x}}{(1+e^{-x})^2} = \left( \frac{1 + e^{-x} - 1}{1 + e^{-x}} \right) \left( \frac{1}{1+e^{-x}} \right) 
= \left( 1 - \sigma(x) \right) \sigma(x)</script><p>As we see, the gradient turns out to simplify and becomes surprisingly simple. For example, the sigmoid expression receives the input 1.0 and computes the output 0.73 during the forward pass. The derivation above shows that the <em>local</em> gradient would simply be (1 - 0.73) * 0.73 ~= 0.2, as the circuit computed before (see the image above), except this way it would be done with a single, simple and efficient expression (and with less numerical issues). Therefore, in any real practical application it would be very useful to group these operations into a single gate. Lets see the backprop for this neuron in code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">w = [<span class="number">2</span>,<span class="number">-3</span>,<span class="number">-3</span>] <span class="comment"># assume some random weights and data</span></div><div class="line">x = [<span class="number">-1</span>, <span class="number">-2</span>]</div><div class="line"></div><div class="line"><span class="comment"># forward pass</span></div><div class="line">dot = w[<span class="number">0</span>]*x[<span class="number">0</span>] + w[<span class="number">1</span>]*x[<span class="number">1</span>] + w[<span class="number">2</span>]</div><div class="line">f = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-dot)) <span class="comment"># sigmoid function</span></div><div class="line"></div><div class="line"><span class="comment"># backward pass through the neuron (backpropagation)</span></div><div class="line">ddot = (<span class="number">1</span> - f) * f <span class="comment"># gradient on dot variable, using the sigmoid gradient derivation</span></div><div class="line">dx = [w[<span class="number">0</span>] * ddot, w[<span class="number">1</span>] * ddot] <span class="comment"># backprop into x</span></div><div class="line">dw = [x[<span class="number">0</span>] * ddot, x[<span class="number">1</span>] * ddot, <span class="number">1.0</span> * ddot] <span class="comment"># backprop into w</span></div><div class="line"><span class="comment"># we're done! we have the gradients on the inputs to the circuit</span></div></pre></td></tr></table></figure><p><strong>Implementation protip: staged backpropagation</strong>. As shown in the code above, in practice it is always helpful to break down the forward pass into stages that are easily backpropped through. For example here we created an intermediate variable <code>dot</code> which holds the output of the dot product between <code>w</code> and <code>x</code>. During backward pass we then successively compute (in reverse order) the corresponding variables (e.g. <code>ddot</code>, and ultimately <code>dw, dx</code>) that hold the gradients of those variables.</p><h2 id="Backprop-in-practice-Staged-computation"><a href="#Backprop-in-practice-Staged-computation" class="headerlink" title="Backprop in practice: Staged computation"></a>Backprop in practice: Staged computation</h2><p>Suppose that we have a function of the form:</p><script type="math/tex;mode=display">f(x,y) = \frac{x + \sigma(y)}{\sigma(x) + (x+y)^2}</script><p>Here is how we would structure the forward pass of such expression:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">3</span> <span class="comment"># example values</span></div><div class="line">y = <span class="number">-4</span></div><div class="line"></div><div class="line"><span class="comment"># forward pass</span></div><div class="line">sigy = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-y)) <span class="comment"># sigmoid in numerator   #(1)</span></div><div class="line">num = x + sigy <span class="comment"># numerator                               #(2)</span></div><div class="line">sigx = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-x)) <span class="comment"># sigmoid in denominator #(3)</span></div><div class="line">xpy = x + y                                              <span class="comment">#(4)</span></div><div class="line">xpysqr = xpy**<span class="number">2</span>                                          <span class="comment">#(5)</span></div><div class="line">den = sigx + xpysqr <span class="comment"># denominator                        #(6)</span></div><div class="line">invden = <span class="number">1.0</span> / den                                       <span class="comment">#(7)</span></div><div class="line">f = num * invden <span class="comment"># done!                                 #(8)</span></div></pre></td></tr></table></figure><p>For each row, we also highlight which part of the forward pass it refers to:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># backprop f = num * invden</span></div><div class="line">dnum = invden <span class="comment"># gradient on numerator                             #(8)</span></div><div class="line">dinvden = num                                                     <span class="comment">#(8)</span></div><div class="line"><span class="comment"># backprop invden = 1.0 / den </span></div><div class="line">dden = (<span class="number">-1.0</span> / (den**<span class="number">2</span>)) * dinvden                                <span class="comment">#(7)</span></div><div class="line"><span class="comment"># backprop den = sigx + xpysqr</span></div><div class="line">dsigx = (<span class="number">1</span>) * dden                                                <span class="comment">#(6)</span></div><div class="line">dxpysqr = (<span class="number">1</span>) * dden                                              <span class="comment">#(6)</span></div><div class="line"><span class="comment"># backprop xpysqr = xpy**2</span></div><div class="line">dxpy = (<span class="number">2</span> * xpy) * dxpysqr                                        <span class="comment">#(5)</span></div><div class="line"><span class="comment"># backprop xpy = x + y</span></div><div class="line">dx = (<span class="number">1</span>) * dxpy                                                   <span class="comment">#(4)</span></div><div class="line">dy = (<span class="number">1</span>) * dxpy                                                   <span class="comment">#(4)</span></div><div class="line"><span class="comment"># backprop sigx = 1.0 / (1 + math.exp(-x))</span></div><div class="line">dx += ((<span class="number">1</span> - sigx) * sigx) * dsigx <span class="comment"># Notice += !! See notes below  #(3)</span></div><div class="line"><span class="comment"># backprop num = x + sigy</span></div><div class="line">dx += (<span class="number">1</span>) * dnum                                                  <span class="comment">#(2)</span></div><div class="line">dsigy = (<span class="number">1</span>) * dnum                                                <span class="comment">#(2)</span></div><div class="line"><span class="comment"># backprop sigy = 1.0 / (1 + math.exp(-y))</span></div><div class="line">dy += ((<span class="number">1</span> - sigy) * sigy) * dsigy                                 <span class="comment">#(1)</span></div><div class="line"><span class="comment"># done! phew</span></div></pre></td></tr></table></figure><p>Notice a few things:</p><p><strong>Cache forward pass variables</strong>. To compute the backward pass it is very helpful to have some of the variables that were used in the forward pass. In practice you want to structure your code so that you cache these variables, and so that they are available during backpropagation. If this is too difficult, it is possible (but wasteful) to recompute them.</p><p><strong>Gradients add up at forks</strong>. The forward expression involves the variables <strong>x,y</strong> multiple times, so when we perform backpropagation we must be careful to use <code>+=</code> instead of <code>=</code> to accumulate the gradient on these variables (otherwise we would overwrite it). This follows the <em>multivariable chain rule</em> in Calculus, which states that if a variable branches out to different parts of the circuit, then the gradients that flow back to it will add.</p><h2 id="Patterns-in-backward-flow"><a href="#Patterns-in-backward-flow" class="headerlink" title="Patterns in backward flow"></a>Patterns in backward flow</h2><p>It is interesting to note that in many cases the backward-flowing gradient can be interpreted on an intuitive level. For example, the three most commonly used gates in neural networks (<em>add,mul,max</em>), all have very simple interpretations in terms of how they act during backpropagation. Consider this example circuit:</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-note/04/pattern.png" alt="pattern"></p><p>Looking at the diagram above as an example, we can see that:</p><p>The <strong>add gate</strong> always takes the gradient on its output and distributes it equally to all of its inputs, regardless of what their values were during the forward pass. This follows from the fact that the local gradient for the add operation is simply +1.0, so the gradients on all inputs will exactly equal the gradients on the output because it will be multiplied by x1.0 (and remain unchanged). In the example circuit above, note that the + gate routed the gradient of 2.00 to both of its inputs, equally and unchanged.</p><p>The <strong>max gate</strong> routes the gradient. Unlike the add gate which distributed the gradient unchanged to all its inputs, the max gate distributes the gradient (unchanged) to exactly one of its inputs (the input that had the highest value during the forward pass). This is because the local gradient for a max gate is 1.0 for the highest value, and 0.0 for all other values. In the example circuit above, the max operation routed the gradient of 2.00 to the <strong>z</strong> variable, which had a higher value than <strong>w</strong>, and the gradient on <strong>w</strong> remains zero.</p><p>The <strong>multiply gate</strong> is a little less easy to interpret. Its local gradients are the input values (except switched), and this is multiplied by the gradient on its output during the chain rule. In the example above, the gradient on <strong>x</strong> is -8.00, which is -4.00 x 2.00.</p><p><em>Unintuitive effects and their consequences</em>. Notice that if one of the inputs to the multiply gate is very small and the other is very big, then the multiply gate will do something slightly unintuitive: it will assign a relatively huge gradient to the small input and a tiny gradient to the large input. Note that in linear classifiers where the weights are dot producted $w^T x_i$ (multiplied) with the inputs, this implies that the scale of the data has an effect on the magnitude of the gradient for the weights. For example, if you multiplied all input data examples xixi by 1000 during preprocessing, then the gradient on the weights will be 1000 times larger, and you’d have to lower the learning rate by that factor to compensate. This is why preprocessing matters a lot, sometimes in subtle ways! And having intuitive understanding for how the gradients flow can help you debug some of these cases.</p><h2 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h2><p>Some extra materials provided in <a href="https://github.com/ewanlee/ewanlee.github.io/blob/master/2017/03/06/cs231n-Lecture4-note/sources/lecun-98b.pdf" target="_blank" rel="external">here</a> and <a href="https://github.com/ewanlee/ewanlee.github.io/blob/master/2017/03/06/cs231n-Lecture4-note/sources/vecDerivs.pdf" target="_blank" rel="external">here</a>.</p><p>Optional: [<a href="http://colah.github.io/posts/2015-08-Backprop/" target="_blank" rel="external">1</a>, <a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="external">2</a>, <a href="https://www.youtube.com/watch?v=q0pm3BrIUFo" target="_blank" rel="external">3</a>]</p><h1 id="Neural-Network-1"><a href="#Neural-Network-1" class="headerlink" title="Neural Network#1"></a>Neural Network#1</h1><h2 id="Quick-intro"><a href="#Quick-intro" class="headerlink" title="Quick intro"></a>Quick intro</h2><p>It is possible to introduce neural networks without appealing to brain analogies. In the section on linear classification we computed scores for different visual categories given the image using the formula $s=Wx$, where $W$ was a matrix and $x$ was an input column vector containing all pixel data of the image. In the case of CIFAR-10, $x$ is a [3072x1] column vector, and $W$ is a [10x3072] matrix, so that the output scores is a vector of 10 class scores.</p><p>An example neural network would instead compute $s=W_2 \max(0, W_1x)$. Here, $W_1$ could be, for example, a [100x3072] matrix transforming the image into a 100-dimensional intermediate vector. The function $\max(0,−)$is a non-linearity that is applied elementwise. There are several choices we could make for the non-linearity (which we’ll study below), but this one is a common choice and simply thresholds all activations that are below zero to zero. Finally, the matrix $W_2$ would then be of size [10x100], so that we again get 10 numbers out that we interpret as the class scores. Notice that the non-linearity is critical computationally - if we left it out, the two matrices could be collapsed to a single matrix, and therefore the predicted class scores would again be a linear function of the input. The non-linearity is where we get the <em>wiggle</em>. The parameters $W_2, W_1$ are learned with stochastic gradient descent, and their gradients are derived with chain rule (and computed with backpropagation).</p><p>A three-layer neural network could analogously look like $s = W_3 \max(0, W_2 \max(0, W_1 x))$, where all of $W_3, W_2, W_1$ are parameters to be learned. The sizes of the intermediate hidden vectors are hyperparameters of the network and we’ll see how we can set them later. Lets now look into how we can interpret these computations from the neuron/network perspective.</p><h2 id="Modeling-one-neuron"><a href="#Modeling-one-neuron" class="headerlink" title="Modeling one neuron"></a>Modeling one neuron</h2><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/neuron.png" alt="neuron"></p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/neuron_model.jpeg" alt="neuron_model"></p><p>An example code for forward-propagating a single neuron might look as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Neuron</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="comment"># ... </span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(inputs)</span>:</span></div><div class="line">    <span class="string">""" assume inputs and weights are 1-D numpy arrays and bias is a number """</span></div><div class="line">    cell_body_sum = np.sum(inputs * self.weights) + self.bias</div><div class="line">    firing_rate = <span class="number">1.0</span> / (<span class="number">1.0</span> + math.exp(-cell_body_sum)) <span class="comment"># sigmoid activation function</span></div><div class="line">    <span class="keyword">return</span> firing_rate</div></pre></td></tr></table></figure><h2 id="Single-neuron-as-a-linear-classifier"><a href="#Single-neuron-as-a-linear-classifier" class="headerlink" title="Single neuron as a linear classifier"></a>Single neuron as a linear classifier</h2><p>The mathematical form of the model Neuron’s forward computation might look familiar to you. As we saw with linear classifiers, a neuron has the capacity to “like” (activation near one) or “dislike” (activation near zero) certain linear regions of its input space. Hence, with an appropriate loss function on the neuron’s output, we can turn a single neuron into a linear classifier:</p><p><strong>Binary Softmax classifier</strong>. For example, we can interpret $\sigma(\sum_iw_ix_i + b)$ to be the probability of one of the classes $P(y_i = 1 \mid x_i; w)$. The probability of the other class would be $P(y_i = 0 \mid x_i; w) = 1 - P(y_i = 1 \mid x_i; w)$, since they must sum to one. With this interpretation, we can formulate the cross-entropy loss as we have seen in the Linear Classification section, and optimizing it would lead to a binary Softmax classifier (also known as <em>logistic regression</em>). Since the sigmoid function is restricted to be between 0-1, the predictions of this classifier are based on whether the output of the neuron is greater than 0.5.</p><p><strong>Binary SVM classifier</strong>. Alternatively, we could attach a max-margin hinge loss to the output of the neuron and train it to become a binary Support Vector Machine.</p><p><strong>Regularization interpretation</strong>. The regularization loss in both SVM/Softmax cases could in this biological view be interpreted as <em>gradual forgetting</em>, since it would have the effect of driving all synaptic weights ww towards zero after every parameter update.</p><blockquote><p>A single neuron can be used to implement a binary classifier (e.g. binary Softmax or binary SVM classifiers)</p></blockquote><h2 id="Commonly-used-activation-functions"><a href="#Commonly-used-activation-functions" class="headerlink" title="Commonly used activation functions"></a>Commonly used activation functions</h2><p>Every activation function (or <em>non-linearity</em>) takes a single number and performs a certain fixed mathematical operation on it. There are several activation functions you may encounter in practice:</p><p><strong>Sigmoid.</strong> The sigmoid non-linearity has the mathematical form $\sigma(x) = 1 / (1 + e^{-x})$ and is shown in the image. As alluded to in the previous section, it takes a real-valued number and “squashes” it into range between 0 and 1. In particular, large negative numbers become 0 and large positive numbers become 1. The sigmoid function has seen frequent use historically since it has a nice interpretation as the firing rate of a neuron: from not firing at all (0) to fully-saturated firing at an assumed maximum frequency (1). In practice, the sigmoid non-linearity has recently fallen out of favor and it is rarely ever used. It has two major drawbacks:</p><ul><li><p><em>Sigmoids saturate and kill gradients</em>. A very undesirable property of the sigmoid neuron is that when the neuron’s activation saturates at either tail of 0 or 1, the gradient at these regions is almost zero. Recall that during backpropagation, this (local) gradient will be multiplied to the gradient of this gate’s output for the whole objective. Therefore, if the local gradient is very small, it will effectively “kill” the gradient and almost no signal will flow through the neuron to its weights and recursively to its data. Additionally, one must pay extra caution when initializing the weights of sigmoid neurons to prevent saturation. For example, if the initial weights are too large then most neurons would become saturated and the network will barely learn.</p></li><li><p><em>Sigmoid outputs are not zero-centered</em>. This is undesirable since neurons in later layers of processing in a Neural Network (more on this soon) would be receiving data that is not zero-centered. This has implications on the dynamics during gradient descent, because if the data coming into a neuron is always positive (e.g. $x &gt; 0$ elementwise in $f = w^Tx + b$), then the gradient on the weights ww will during backpropagation become either all be positive, or all negative (depending on the gradient of the whole expression $f$). This could introduce undesirable zig-zagging dynamics in the gradient updates for the weights. However, notice that once these gradients are added up across a batch of data the final update for the weights can have variable signs, somewhat mitigating this issue. Therefore, this is an inconvenience but it has less severe consequences compared to the saturated activation problem above.</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/sigmoid.jpeg" alt="sigmoid"></p><p>​</p></li></ul><p><strong>Tanh.</strong> The tanh non-linearity is shown on the image. It squashes a real-valued number to the range [-1, 1]. Like the sigmoid neuron, its activations saturate, but unlike the sigmoid neuron its output is zero-centered. Therefore, in practice the <em>tanh non-linearity is always preferred to the sigmoid nonlinearity.</em> Also note that the tanh neuron is simply a scaled sigmoid neuron, in particular the following holds: $\tanh(x) = 2 \sigma(2x) -1$.</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/tanh.jpeg" alt="tanh"></p><p><strong>ReLU.</strong> The Rectified Linear Unit has become very popular in the last few years. It computes the function $f(x) = \max(0, x)$. In other words, the activation is simply thresholded at zero (see image). There are several pros and cons to using the ReLUs:</p><ul><li><p>(+) It was found to greatly accelerate (e.g. a factor of 6 in <a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf" target="_blank" rel="external">Krizhevsky et al.</a>) the convergence of stochastic gradient descent compared to the sigmoid/tanh functions. It is argued that this is due to its linear, non-saturating form.</p></li><li><p>(+) Compared to tanh/sigmoid neurons that involve expensive operations (exponentials, etc.), the ReLU can be implemented by simply thresholding a matrix of activations at zero.</p></li><li><p>(-) Unfortunately, ReLU units can be fragile during training and can “die”. For example, a large gradient flowing through a ReLU neuron could cause the weights to update in such a way that the neuron will never activate on any datapoint again. If this happens, then the gradient flowing through the unit will forever be zero from that point on. That is, the ReLU units can irreversibly die during training since they can get knocked off the data manifold. For example, you may find that as much as 40% of your network can be “dead” (i.e. neurons that never activate across the entire training dataset) if the learning rate is set too high. With a proper setting of the learning rate this is less frequently an issue.</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/relu.jpeg" alt="relu"></p></li></ul><p><strong>Leaky ReLU.</strong> Leaky ReLUs are one attempt to fix the “dying ReLU” problem. Instead of the function being zero when x &lt; 0, a leaky ReLU will instead have a small negative slope (of 0.01, or so). That is, the function computes $f(x) = \mathbb{1}(x &lt; 0) (\alpha x) + \mathbb{1}(x&gt;=0) (x)$ where $\alpha$ is a small constant. Some people report success with this form of activation function, but the results are not always consistent. The slope in the negative region can also be made into a parameter of each neuron, as seen in PReLU neurons, introduced in <a href="http://arxiv.org/abs/1502.01852" target="_blank" rel="external">Delving Deep into Rectifiers</a>, by Kaiming He et al., 2015. However, the consistency of the benefit across tasks is presently unclear.</p><p><strong>Maxout</strong>. Other types of units have been proposed that do not have the functional form $f(w^Tx + b)$ where a non-linearity is applied on the dot product between the weights and the data. One relatively popular choice is the Maxout neuron (introduced recently by <a href="http://www-etud.iro.umontreal.ca/~goodfeli/maxout.html" target="_blank" rel="external">Goodfellow et al.</a>) that generalizes the ReLU and its leaky version. The Maxout neuron computes the function $\max(w_1^Tx+b_1, w_2^Tx + b_2)$. Notice that both ReLU and Leaky ReLU are a special case of this form (for example, for ReLU we have $w_1, b_1 = 0$). The Maxout neuron therefore enjoys all the benefits of a ReLU unit (linear regime of operation, no saturation) and does not have its drawbacks (dying ReLU). However, unlike the ReLU neurons it doubles the number of parameters for every single neuron, leading to a high total number of parameters.</p><p>This concludes our discussion of the most common types of neurons and their activation functions. As a last comment, it is very rare to mix and match different types of neurons in the same network, even though there is no fundamental problem with doing so.</p><p><strong>TLDR</strong>: “<em>What neuron type should I use?</em>” Use the ReLU non-linearity, be careful with your learning rates and possibly monitor the fraction of “dead” units in a network. If this concerns you, give Leaky ReLU or Maxout a try. Never use sigmoid. Try tanh, but expect it to work worse than ReLU/Maxout.</p><h2 id="Neural-Network-architectures"><a href="#Neural-Network-architectures" class="headerlink" title="Neural Network architectures"></a>Neural Network architectures</h2><h3 id="Layer-wise-organization"><a href="#Layer-wise-organization" class="headerlink" title="Layer-wise organization"></a>Layer-wise organization</h3><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/neural_net.jpeg" alt="neuron_net"></p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/neural_net2.jpeg" alt="neural_net2"></p><p><strong>Sizing neural networks</strong>. The two metrics that people commonly use to measure the size of neural networks are the number of neurons, or more commonly the number of parameters. Working with the two example networks in the above picture:</p><ul><li>The first network (left) has 4 + 2 = 6 neurons (not counting the inputs), [3 x 4] + [4 x 2] = 20 weights and 4 + 2 = 6 biases, for a total of 26 learnable parameters.</li><li>The second network (right) has 4 + 4 + 1 = 9 neurons, [3 x 4] + [4 x 4] + [4 x 1] = 12 + 16 + 4 = 32 weights and 4 + 4 + 1 = 9 biases, for a total of 41 learnable parameters.</li></ul><p>To give you some context, modern Convolutional Networks contain on orders of 100 million parameters and are usually made up of approximately 10-20 layers (hence <em>deep learning</em>). However, as we will see the number of <em>effective</em> connections is significantly greater due to parameter sharing. More on this in the Convolutional Neural Networks module.</p><h3 id="Example-feed-forward-computation"><a href="#Example-feed-forward-computation" class="headerlink" title="Example feed-forward computation"></a>Example feed-forward computation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># forward-pass of a 3-layer neural network:</span></div><div class="line">f = <span class="keyword">lambda</span> x: <span class="number">1.0</span>/(<span class="number">1.0</span> + np.exp(-x)) <span class="comment"># activation function (use sigmoid)</span></div><div class="line">x = np.random.randn(<span class="number">3</span>, <span class="number">1</span>) <span class="comment"># random input vector of three numbers (3x1)</span></div><div class="line">h1 = f(np.dot(W1, x) + b1) <span class="comment"># calculate first hidden layer activations (4x1)</span></div><div class="line">h2 = f(np.dot(W2, h1) + b2) <span class="comment"># calculate second hidden layer activations (4x1)</span></div><div class="line">out = np.dot(W3, h2) + b3 <span class="comment"># output neuron (1x1)</span></div></pre></td></tr></table></figure><blockquote><p>The forward pass of a fully-connected layer corresponds to one matrix multiplication followed by a bias offset and an activation function.</p></blockquote><h3 id="Representational-power"><a href="#Representational-power" class="headerlink" title="Representational power"></a>Representational power</h3><p>One way to look at Neural Networks with fully-connected layers is that they define a family of functions that are parameterized by the weights of the network. A natural question that arises is: What is the representational power of this family of functions? In particular, are there functions that cannot be modeled with a Neural Network?</p><p>It turns out that Neural Networks with at least one hidden layer are <em>universal approximators</em>. That is, it can be shown (e.g. see <a href="http://www.dartmouth.edu/~gvc/Cybenko_MCSS.pdf" target="_blank" rel="external"><em>Approximation by Superpositions of Sigmoidal Function</em></a> from 1989 (pdf), or this <a href="http://neuralnetworksanddeeplearning.com/chap4.html" target="_blank" rel="external">intuitive explanation</a> from Michael Nielsen) that given any continuous function $f(x)$ and some $\epsilon &gt; 0$, there exists a Neural Network $g(x)$ with one hidden layer (with a reasonable choice of non-linearity, e.g. sigmoid) such that $\forall x, \mid f(x) - g(x) \mid &lt; \epsilon$. In other words, the neural network can approximate any continuous function.</p><p>If one hidden layer suffices to approximate any function, why use more layers and go deeper? The answer is that the fact that a two-layer Neural Network is a universal approximator is, while mathematically cute, a relatively weak and useless statement in practice. In one dimension, the “sum of indicator bumps” function $g(x) = \sum_i c_i \mathbb{1}(a_i &lt; x &lt; b_i)$ where $a, b, c$ are parameter vectors is also a universal approximator, but noone would suggest that we use this functional form in Machine Learning. Neural Networks work well in practice because they compactly express nice, smooth functions that fit well with the statistical properties of data we encounter in practice, and are also easy to learn using our optimization algorithms (e.g. gradient descent). Similarly, the fact that deeper networks (with multiple hidden layers) can work better than a single-hidden-layer networks is an empirical observation, despite the fact that their representational power is equal.</p><p>As an aside, in practice it is often the case that 3-layer neural networks will outperform 2-layer nets, but going even deeper (4,5,6-layer) rarely helps much more. This is in stark contrast to Convolutional Networks, where depth has been found to be an extremely important component for a good recognition system (e.g. on order of 10 learnable layers). One argument for this observation is that images contain hierarchical structure (e.g. faces are made up of eyes, which are made up of edges, etc.), so several layers of processing make intuitive sense for this data domain.</p><p>The full story is, of course, much more involved and a topic of much recent research. If you are interested in these topics we recommend for further reading:</p><ul><li><a href="http://www.deeplearningbook.org/" target="_blank" rel="external">Deep Learning</a> book in press by Bengio, Goodfellow, Courville, in practicular <a href="http://www.deeplearningbook.org/contents/mlp.html" target="_blank" rel="external">Chapter 6.4</a>.</li><li><a href="http://arxiv.org/abs/1312.6184" target="_blank" rel="external">Do Deep Nets Really Need to be Deep?</a></li><li><a href="http://arxiv.org/abs/1412.6550" target="_blank" rel="external">FitNets: Hints for Thin Deep Nets</a></li></ul><h3 id="Setting-number-of-layers-and-their-sizes"><a href="#Setting-number-of-layers-and-their-sizes" class="headerlink" title="Setting number of layers and their sizes"></a>Setting number of layers and their sizes</h3><p>We increase the size and number of layers in a Neural Network, the <strong>capacity</strong> of the network increases:</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/layer_sizes.jpeg" alt="layer_sizes"></p><p>In practice, it is always better to use these methods to control overfitting instead of the number of neurons.</p><p>The subtle reason behind this is that smaller networks are harder to train with local methods such as Gradient Descent: It’s clear that their loss functions have relatively few local minima, but it turns out that many of these minima are easier to converge to, and that they are bad (i.e. with high loss). Conversely, bigger neural networks contain significantly more local minima, but these minima turn out to be much better in terms of their actual loss. Since Neural Networks are non-convex, it is hard to study these properties mathematically, but some attempts to understand these objective functions have been made, e.g. in a recent paper <a href="http://arxiv.org/abs/1412.0233" target="_blank" rel="external">The Loss Surfaces of Multilayer Networks</a>. In practice, what you find is that if you train a small network the final loss can display a good amount of variance - in some cases you get lucky and converge to a good place but in some cases you get trapped in one of the bad minima. On the other hand, if you train a large network you’ll start to find many different solutions, but the variance in the final achieved loss will be much smaller. In other words, all solutions are about equally as good, and rely less on the luck of random initialization.</p><p>To reiterate, the regularization strength is the preferred way to control the overfitting of a neural network. We can look at the results achieved by three different settings:</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/lecture-notes/04/reg_strengths.jpeg" alt="reg_strengths"></p><p>You can play with these examples in this <a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/classify2d.html" target="_blank" rel="external">ConvNetsJS demo</a>.</p><p>The takeaway is that you should not be using smaller networks because you are afraid of overfitting. Instead, you should use as big of a neural network as your computational budget allows, and use other regularization techniques to control overfitting.</p><h2 id="Additional-References"><a href="#Additional-References" class="headerlink" title="Additional References"></a>Additional References</h2><ul><li><a href="http://www.deeplearning.net/tutorial/mlp.html" target="_blank" rel="external">deeplearning.net tutorial</a> with Theano</li><li><a href="http://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="external">ConvNetJS</a> demos for intuitions</li><li><a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="external">Michael Nielsen’s</a> tutorials</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BackProp&quot;&gt;&lt;a href=&quot;#BackProp&quot; class=&quot;headerlink&quot; title=&quot;BackProp&quot;&gt;&lt;/a&gt;BackProp&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; cla
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>python data analysis learning note ch08</title>
    <link href="http://yoursite.com/2017/03/05/python-data-analysis-learning-note-ch08/"/>
    <id>http://yoursite.com/2017/03/05/python-data-analysis-learning-note-ch08/</id>
    <published>2017-03-05T14:55:28.000Z</published>
    <updated>2017-03-05T15:08:37.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绘图和可视化"><a href="#绘图和可视化" class="headerlink" title="绘图和可视化"></a>绘图和可视化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">np.random.seed(<span class="number">12345</span>)</div><div class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">np.set_printoptions(precision=<span class="number">4</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div></pre></td></tr></table></figure><h2 id="matplotlib-API-入门"><a href="#matplotlib-API-入门" class="headerlink" title="matplotlib API 入门"></a>matplotlib API 入门</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div></pre></td></tr></table></figure><h3 id="Figure-和-Subplot"><a href="#Figure-和-Subplot" class="headerlink" title="Figure 和 Subplot"></a>Figure 和 Subplot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fig = plt.figure()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</div><div class="line">ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</div><div class="line">plt.plot(randn(<span class="number">50</span>).cumsum(), <span class="string">'k--'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_10_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_ = ax1.hist(randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">'k'</span>, alpha=<span class="number">0.3</span>)</div><div class="line">ax2.scatter(np.arange(<span class="number">30</span>), np.arange(<span class="number">30</span>) + <span class="number">3</span> * randn(<span class="number">30</span>))</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.close(<span class="string">'all'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</div><div class="line">axes</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_13_1.png" alt="png"></p><h4 id="调整subplot周围的间距"><a href="#调整subplot周围的间距" class="headerlink" title="调整subplot周围的间距"></a>调整subplot周围的间距</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.subplots_adjust(left=<span class="keyword">None</span>, bottom=<span class="keyword">None</span>, right=<span class="keyword">None</span>, top=<span class="keyword">None</span>,</div><div class="line">                wspace=<span class="keyword">None</span>, hspace=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="keyword">True</span>, sharey=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">        axes[i, j].hist(randn(<span class="number">500</span>), bins=<span class="number">50</span>, color=<span class="string">'k'</span>, alpha=<span class="number">0.5</span>)</div><div class="line">plt.subplots_adjust(wspace=<span class="number">0</span>, hspace=<span class="number">0</span>)</div></pre></td></tr></table></figure><pre><code>(array([  2.,   0.,   3.,   2.,   1.,   1.,   0.,   3.,   5.,   8.,   9.,
          9.,  10.,  18.,  34.,  13.,  24.,  30.,  24.,  24.,  25.,  20.,
         34.,  20.,  30.,  30.,  19.,  14.,  14.,   8.,  19.,  14.,   7.,
          3.,   7.,   2.,   7.,   2.,   2.,   0.,   1.,   0.,   0.,   0.,
          1.,   0.,   0.,   0.,   0.,   1.]),
 array([-2.9493, -2.8118, -2.6743, -2.5367, -2.3992, -2.2617, -2.1241,
        -1.9866, -1.849 , -1.7115, -1.574 , -1.4364, -1.2989, -1.1614,
        -1.0238, -0.8863, -0.7487, -0.6112, -0.4737, -0.3361, -0.1986,
        -0.0611,  0.0765,  0.214 ,  0.3516,  0.4891,  0.6266,  0.7642,
         0.9017,  1.0392,  1.1768,  1.3143,  1.4519,  1.5894,  1.7269,
         1.8645,  2.002 ,  2.1395,  2.2771,  2.4146,  2.5522,  2.6897,
         2.8272,  2.9648,  3.1023,  3.2398,  3.3774,  3.5149,  3.6525,
         3.79  ,  3.9275]),
 &lt;a list of 50 Patch objects&gt;)






(array([  1.,   1.,   0.,   2.,   0.,   1.,   1.,   5.,   7.,   4.,   5.,
          8.,  12.,  12.,  13.,  15.,  17.,  13.,  22.,  30.,  21.,  24.,
         17.,  20.,  20.,  20.,  18.,  26.,  16.,  24.,  19.,   8.,  14.,
         15.,   7.,  11.,   5.,   4.,   9.,   7.,   6.,   1.,   6.,   2.,
          4.,   2.,   0.,   2.,   1.,   2.]),
 array([-2.595 , -2.4898, -2.3845, -2.2793, -2.1741, -2.0688, -1.9636,
        -1.8584, -1.7531, -1.6479, -1.5427, -1.4374, -1.3322, -1.227 ,
        -1.1217, -1.0165, -0.9112, -0.806 , -0.7008, -0.5955, -0.4903,
        -0.3851, -0.2798, -0.1746, -0.0694,  0.0359,  0.1411,  0.2463,
         0.3516,  0.4568,  0.562 ,  0.6673,  0.7725,  0.8777,  0.983 ,
         1.0882,  1.1935,  1.2987,  1.4039,  1.5092,  1.6144,  1.7196,
         1.8249,  1.9301,  2.0353,  2.1406,  2.2458,  2.351 ,  2.4563,
         2.5615,  2.6667]),
 &lt;a list of 50 Patch objects&gt;)






(array([  1.,   0.,   1.,   0.,   0.,   1.,   0.,   1.,   1.,   0.,   4.,
          1.,   4.,   5.,  11.,   8.,   6.,  11.,  13.,  13.,  17.,  18.,
         20.,  27.,  32.,  29.,  31.,  22.,  21.,  31.,  29.,  19.,  22.,
         18.,  10.,  18.,  11.,  12.,   9.,   6.,   2.,   3.,   3.,   3.,
          2.,   1.,   1.,   1.,   0.,   1.]),
 array([-3.7454, -3.6052, -3.4651, -3.325 , -3.1849, -3.0448, -2.9047,
        -2.7646, -2.6244, -2.4843, -2.3442, -2.2041, -2.064 , -1.9239,
        -1.7837, -1.6436, -1.5035, -1.3634, -1.2233, -1.0832, -0.9431,
        -0.8029, -0.6628, -0.5227, -0.3826, -0.2425, -0.1024,  0.0377,
         0.1779,  0.318 ,  0.4581,  0.5982,  0.7383,  0.8784,  1.0185,
         1.1587,  1.2988,  1.4389,  1.579 ,  1.7191,  1.8592,  1.9994,
         2.1395,  2.2796,  2.4197,  2.5598,  2.6999,  2.84  ,  2.9802,
         3.1203,  3.2604]),
 &lt;a list of 50 Patch objects&gt;)






(array([  1.,   0.,   0.,   1.,   1.,   0.,   0.,   0.,   0.,   1.,   2.,
          5.,   9.,   8.,   6.,   2.,  11.,  17.,  10.,  13.,  10.,  14.,
         12.,  27.,  17.,  28.,  27.,  25.,  14.,  24.,  25.,  38.,  13.,
         24.,  15.,  10.,  17.,  14.,  13.,   8.,   7.,  10.,   3.,   7.,
          2.,   5.,   2.,   0.,   1.,   1.]),
 array([-3.4283, -3.3066, -3.185 , -3.0633, -2.9417, -2.8201, -2.6984,
        -2.5768, -2.4551, -2.3335, -2.2119, -2.0902, -1.9686, -1.847 ,
        -1.7253, -1.6037, -1.482 , -1.3604, -1.2388, -1.1171, -0.9955,
        -0.8739, -0.7522, -0.6306, -0.5089, -0.3873, -0.2657, -0.144 ,
        -0.0224,  0.0993,  0.2209,  0.3425,  0.4642,  0.5858,  0.7074,
         0.8291,  0.9507,  1.0724,  1.194 ,  1.3156,  1.4373,  1.5589,
         1.6806,  1.8022,  1.9238,  2.0455,  2.1671,  2.2887,  2.4104,
         2.532 ,  2.6537]),
 &lt;a list of 50 Patch objects&gt;)
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_16_4.png" alt="png"></p><h3 id="颜色、标记和线型"><a href="#颜色、标记和线型" class="headerlink" title="颜色、标记和线型"></a>颜色、标记和线型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.figure()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.plot(randn(<span class="number">30</span>).cumsum(), <span class="string">'ko--'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_19_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.close(<span class="string">'all'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data = randn(<span class="number">30</span>).cumsum()</div><div class="line">plt.plot(data, <span class="string">'k--'</span>, label=<span class="string">'Default'</span>)</div><div class="line">plt.plot(data, <span class="string">'k-'</span>, drawstyle=<span class="string">'steps-post'</span>, label=<span class="string">'steps-post'</span>)</div><div class="line">plt.legend(loc=<span class="string">'best'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_21_3.png" alt="png"></p><h3 id="刻度、标签和图例"><a href="#刻度、标签和图例" class="headerlink" title="刻度、标签和图例"></a>刻度、标签和图例</h3><h4 id="设置标题、轴标签、刻度以及刻度标签"><a href="#设置标题、轴标签、刻度以及刻度标签" class="headerlink" title="设置标题、轴标签、刻度以及刻度标签"></a>设置标题、轴标签、刻度以及刻度标签</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">ax.plot(randn(<span class="number">1000</span>).cumsum())</div><div class="line"></div><div class="line">ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</div><div class="line">labels = ax.set_xticklabels([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>],</div><div class="line">                            rotation=<span class="number">30</span>, fontsize=<span class="string">'small'</span>)</div><div class="line">ax.set_title(<span class="string">'My first matplotlib plot'</span>)</div><div class="line">ax.set_xlabel(<span class="string">'Stages'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_24_3.png" alt="png"></p><h4 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">'k'</span>, label=<span class="string">'one'</span>)</div><div class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">'k--'</span>, label=<span class="string">'two'</span>)</div><div class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">'k.'</span>, label=<span class="string">'three'</span>)</div><div class="line"></div><div class="line">ax.legend(loc=<span class="string">'best'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_26_4.png" alt="png"></p><h3 id="注解以及在subplot上绘图"><a href="#注解以及在subplot上绘图" class="headerlink" title="注解以及在subplot上绘图"></a>注解以及在subplot上绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">data = pd.read_csv(<span class="string">'ch08/spx.csv'</span>, index_col=<span class="number">0</span>, parse_dates=<span class="keyword">True</span>)</div><div class="line">spx = data[<span class="string">'SPX'</span>]</div><div class="line"></div><div class="line">spx.plot(ax=ax, style=<span class="string">'k-'</span>)</div><div class="line"></div><div class="line">crisis_data = [</div><div class="line">    (datetime(<span class="number">2007</span>, <span class="number">10</span>, <span class="number">11</span>), <span class="string">'Peak of bull market'</span>),</div><div class="line">    (datetime(<span class="number">2008</span>, <span class="number">3</span>, <span class="number">12</span>), <span class="string">'Bear Stearns Fails'</span>),</div><div class="line">    (datetime(<span class="number">2008</span>, <span class="number">9</span>, <span class="number">15</span>), <span class="string">'Lehman Bankruptcy'</span>)</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">for</span> date, label <span class="keyword">in</span> crisis_data:</div><div class="line">    ax.annotate(label, xy=(date, spx.asof(date) + <span class="number">50</span>),</div><div class="line">                xytext=(date, spx.asof(date) + <span class="number">200</span>),</div><div class="line">                arrowprops=dict(facecolor=<span class="string">'black'</span>),</div><div class="line">                horizontalalignment=<span class="string">'left'</span>, verticalalignment=<span class="string">'top'</span>)</div><div class="line"></div><div class="line"><span class="comment"># Zoom in on 2007-2010</span></div><div class="line">ax.set_xlim([<span class="string">'1/1/2007'</span>, <span class="string">'1/1/2011'</span>])</div><div class="line">ax.set_ylim([<span class="number">600</span>, <span class="number">1800</span>])</div><div class="line"></div><div class="line">ax.set_title(<span class="string">'Important dates in 2008-2009 financial crisis'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_28_7.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">rect = plt.Rectangle((<span class="number">0.2</span>, <span class="number">0.75</span>), <span class="number">0.4</span>, <span class="number">0.15</span>, color=<span class="string">'k'</span>, alpha=<span class="number">0.3</span>)</div><div class="line">circ = plt.Circle((<span class="number">0.7</span>, <span class="number">0.2</span>), <span class="number">0.15</span>, color=<span class="string">'b'</span>, alpha=<span class="number">0.3</span>)</div><div class="line">pgon = plt.Polygon([[<span class="number">0.15</span>, <span class="number">0.15</span>], [<span class="number">0.35</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.6</span>]],</div><div class="line">                   color=<span class="string">'g'</span>, alpha=<span class="number">0.5</span>)</div><div class="line"></div><div class="line">ax.add_patch(rect)</div><div class="line">ax.add_patch(circ)</div><div class="line">ax.add_patch(pgon)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_29_3.png" alt="png"></p><h3 id="将图表保存到文件"><a href="#将图表保存到文件" class="headerlink" title="将图表保存到文件"></a>将图表保存到文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fig</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_31_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fig.savefig(<span class="string">'figpath.svg'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fig.savefig(<span class="string">'figpath.png'</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">'tight'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</div><div class="line">buffer = BytesIO()</div><div class="line">plt.savefig(buffer)</div><div class="line">plot_data = buffer.getvalue()</div></pre></td></tr></table></figure><pre><code>&lt;matplotlib.figure.Figure at 0xaebe550&gt;
</code></pre><h3 id="matplotlib-配置"><a href="#matplotlib-配置" class="headerlink" title="matplotlib 配置"></a>matplotlib 配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</div></pre></td></tr></table></figure><h2 id="pandas中的绘图函数"><a href="#pandas中的绘图函数" class="headerlink" title="pandas中的绘图函数"></a>pandas中的绘图函数</h2><h3 id="线型图"><a href="#线型图" class="headerlink" title="线型图"></a>线型图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.close(<span class="string">'all'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = Series(np.random.randn(<span class="number">10</span>).cumsum(), index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</div><div class="line">s.plot()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_40_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df = DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>).cumsum(<span class="number">0</span>),</div><div class="line">               columns=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</div><div class="line">               index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</div><div class="line">df.plot()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_41_1.png" alt="png"></p><h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</div><div class="line">data = Series(np.random.rand(<span class="number">16</span>), index=list(<span class="string">'abcdefghijklmnop'</span>))</div><div class="line">data.plot(kind=<span class="string">'bar'</span>, ax=axes[<span class="number">0</span>], color=<span class="string">'k'</span>, alpha=<span class="number">0.7</span>)</div><div class="line">data.plot(kind=<span class="string">'barh'</span>, ax=axes[<span class="number">1</span>], color=<span class="string">'k'</span>, alpha=<span class="number">0.7</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_43_2.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df = DataFrame(np.random.rand(<span class="number">6</span>, <span class="number">4</span>),</div><div class="line">               index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>, <span class="string">'six'</span>],</div><div class="line">               columns=pd.Index([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>], name=<span class="string">'Genus'</span>))</div><div class="line">df</div><div class="line">df.plot(kind=<span class="string">'bar'</span>)</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th>Genus</th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><th>one</th><td>0.301686</td><td>0.156333</td><td>0.371943</td><td>0.270731</td></tr><tr><th>two</th><td>0.750589</td><td>0.525587</td><td>0.689429</td><td>0.358974</td></tr><tr><th>three</th><td>0.381504</td><td>0.667707</td><td>0.473772</td><td>0.632528</td></tr><tr><th>four</th><td>0.942408</td><td>0.180186</td><td>0.708284</td><td>0.641783</td></tr><tr><th>five</th><td>0.840278</td><td>0.909589</td><td>0.010041</td><td>0.653207</td></tr><tr><th>six</th><td>0.062854</td><td>0.589813</td><td>0.811318</td><td>0.060217</td></tr></tbody></table></div><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_44_2.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.figure()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.plot(kind=<span class="string">'barh'</span>, stacked=<span class="keyword">True</span>, alpha=<span class="number">0.5</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_46_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tips = pd.read_csv(<span class="string">'ch08/tips.csv'</span>)</div><div class="line">party_counts = pd.crosstab(tips.day, tips.size_)</div><div class="line">party_counts</div><div class="line"><span class="comment"># Not many 1- and 6-person parties</span></div><div class="line">party_counts = party_counts.ix[:, <span class="number">2</span>:<span class="number">5</span>]</div><div class="line">party_counts</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th>size_</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr><tr><th>day</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Fri</th><td>1</td><td>16</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><th>Sat</th><td>2</td><td>53</td><td>18</td><td>13</td><td>1</td><td>0</td></tr><tr><th>Sun</th><td>0</td><td>39</td><td>15</td><td>18</td><td>3</td><td>1</td></tr><tr><th>Thur</th><td>1</td><td>48</td><td>4</td><td>5</td><td>1</td><td>3</td></tr></tbody></table></div><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th>size_</th><th>2</th><th>3</th><th>4</th><th>5</th></tr><tr><th>day</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Fri</th><td>16</td><td>1</td><td>1</td><td>0</td></tr><tr><th>Sat</th><td>53</td><td>18</td><td>13</td><td>1</td></tr><tr><th>Sun</th><td>39</td><td>15</td><td>18</td><td>3</td></tr><tr><th>Thur</th><td>48</td><td>4</td><td>5</td><td>1</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Normalize to sum to 1</span></div><div class="line">party_pcts = party_counts.div(party_counts.sum(<span class="number">1</span>).astype(float), axis=<span class="number">0</span>)</div><div class="line">party_pcts</div><div class="line"></div><div class="line">party_pcts.plot(kind=<span class="string">'bar'</span>, stacked=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th>size_</th><th>2</th><th>3</th><th>4</th><th>5</th></tr><tr><th>day</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Fri</th><td>0.888889</td><td>0.055556</td><td>0.055556</td><td>0.000000</td></tr><tr><th>Sat</th><td>0.623529</td><td>0.211765</td><td>0.152941</td><td>0.011765</td></tr><tr><th>Sun</th><td>0.520000</td><td>0.200000</td><td>0.240000</td><td>0.040000</td></tr><tr><th>Thur</th><td>0.827586</td><td>0.068966</td><td>0.086207</td><td>0.017241</td></tr></tbody></table></div><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_48_2.png" alt="png"></p><h3 id="直方图和密度图"><a href="#直方图和密度图" class="headerlink" title="直方图和密度图"></a>直方图和密度图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.figure()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tips[<span class="string">'tip_pct'</span>] = tips[<span class="string">'tip'</span>] / tips[<span class="string">'total_bill'</span>]</div><div class="line">tips[<span class="string">'tip_pct'</span>].hist(bins=<span class="number">50</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_51_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.figure()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips[<span class="string">'tip_pct'</span>].plot(kind=<span class="string">'kde'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_53_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.figure()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">comp1 = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, size=<span class="number">200</span>)  <span class="comment"># N(0, 1)</span></div><div class="line">comp2 = np.random.normal(<span class="number">10</span>, <span class="number">2</span>, size=<span class="number">200</span>)  <span class="comment"># N(10, 4)</span></div><div class="line">values = Series(np.concatenate([comp1, comp2]))</div><div class="line">values.hist(bins=<span class="number">100</span>, alpha=<span class="number">0.3</span>, color=<span class="string">'k'</span>, normed=<span class="keyword">True</span>)</div><div class="line">values.plot(kind=<span class="string">'kde'</span>, style=<span class="string">'k--'</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_55_2.png" alt="png"></p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">macro = pd.read_csv(<span class="string">'ch08/macrodata.csv'</span>)</div><div class="line">data = macro[[<span class="string">'cpi'</span>, <span class="string">'m1'</span>, <span class="string">'tbilrate'</span>, <span class="string">'unemp'</span>]]</div><div class="line">trans_data = np.log(data).diff().dropna()</div><div class="line">trans_data[<span class="number">-5</span>:]</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>cpi</th><th>m1</th><th>tbilrate</th><th>unemp</th></tr></thead><tbody><tr><th>198</th><td>-0.007904</td><td>0.045361</td><td>-0.396881</td><td>0.105361</td></tr><tr><th>199</th><td>-0.021979</td><td>0.066753</td><td>-2.277267</td><td>0.139762</td></tr><tr><th>200</th><td>0.002340</td><td>0.010286</td><td>0.606136</td><td>0.160343</td></tr><tr><th>201</th><td>0.008419</td><td>0.037461</td><td>-0.200671</td><td>0.127339</td></tr><tr><th>202</th><td>0.008894</td><td>0.012202</td><td>-0.405465</td><td>0.042560</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.figure()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.scatter(trans_data[<span class="string">'m1'</span>], trans_data[<span class="string">'unemp'</span>])</div><div class="line">plt.title(<span class="string">'Changes in log %s vs. log %s'</span> % (<span class="string">'m1'</span>, <span class="string">'unemp'</span>))</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_59_2.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.scatter_matrix(trans_data, diagonal=<span class="string">'kde'</span>, c=<span class="string">'k'</span>, alpha=<span class="number">0.3</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_60_1.png" alt="png"></p><h2 id="绘制地图：图形化显示海底地震危机数据"><a href="#绘制地图：图形化显示海底地震危机数据" class="headerlink" title="绘制地图：图形化显示海底地震危机数据"></a>绘制地图：图形化显示海底地震危机数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.read_csv(<span class="string">'ch08/Haiti.csv'</span>)</div><div class="line">data.info()</div></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 3593 entries, 0 to 3592
Data columns (total 10 columns):
Serial            3593 non-null int64
INCIDENT TITLE    3593 non-null object
INCIDENT DATE     3593 non-null object
LOCATION          3592 non-null object
DESCRIPTION       3593 non-null object
CATEGORY          3587 non-null object
LATITUDE          3593 non-null float64
LONGITUDE         3593 non-null float64
APPROVED          3593 non-null object
VERIFIED          3593 non-null object
dtypes: float64(2), int64(1), object(7)
memory usage: 280.8+ KB
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[[<span class="string">'INCIDENT DATE'</span>, <span class="string">'LATITUDE'</span>, <span class="string">'LONGITUDE'</span>]][:<span class="number">10</span>]</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>INCIDENT DATE</th><th>LATITUDE</th><th>LONGITUDE</th></tr></thead><tbody><tr><th>0</th><td>05/07/2010 17:26</td><td>18.233333</td><td>-72.533333</td></tr><tr><th>1</th><td>28/06/2010 23:06</td><td>50.226029</td><td>5.729886</td></tr><tr><th>2</th><td>24/06/2010 16:21</td><td>22.278381</td><td>114.174287</td></tr><tr><th>3</th><td>20/06/2010 21:59</td><td>44.407062</td><td>8.933989</td></tr><tr><th>4</th><td>18/05/2010 16:26</td><td>18.571084</td><td>-72.334671</td></tr><tr><th>5</th><td>26/04/2010 13:14</td><td>18.593707</td><td>-72.310079</td></tr><tr><th>6</th><td>26/04/2010 14:19</td><td>18.482800</td><td>-73.638800</td></tr><tr><th>7</th><td>26/04/2010 14:27</td><td>18.415000</td><td>-73.195000</td></tr><tr><th>8</th><td>15/03/2010 10:58</td><td>18.517443</td><td>-72.236841</td></tr><tr><th>9</th><td>15/03/2010 11:00</td><td>18.547790</td><td>-72.410010</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[<span class="string">'CATEGORY'</span>][:<span class="number">6</span>]</div></pre></td></tr></table></figure><pre><code>0          1. Urgences | Emergency, 3. Public Health, 
1    1. Urgences | Emergency, 2. Urgences logistiqu...
2    2. Urgences logistiques | Vital Lines, 8. Autr...
3                            1. Urgences | Emergency, 
4                            1. Urgences | Emergency, 
5                       5e. Communication lines down, 
Name: CATEGORY, dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.describe()</div></pre></td></tr></table></figure><div><table border="1" class="dataframe"><thead><tr style="text-align:right"><th></th><th>Serial</th><th>LATITUDE</th><th>LONGITUDE</th></tr></thead><tbody><tr><th>count</th><td>3593.000000</td><td>3593.000000</td><td>3593.000000</td></tr><tr><th>mean</th><td>2080.277484</td><td>18.611495</td><td>-72.322680</td></tr><tr><th>std</th><td>1171.100360</td><td>0.738572</td><td>3.650776</td></tr><tr><th>min</th><td>4.000000</td><td>18.041313</td><td>-74.452757</td></tr><tr><th>25%</th><td>1074.000000</td><td>18.524070</td><td>-72.417500</td></tr><tr><th>50%</th><td>2163.000000</td><td>18.539269</td><td>-72.335000</td></tr><tr><th>75%</th><td>3088.000000</td><td>18.561820</td><td>-72.293570</td></tr><tr><th>max</th><td>4052.000000</td><td>50.226029</td><td>114.174287</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = data[(data.LATITUDE &gt; <span class="number">18</span>) &amp; (data.LATITUDE &lt; <span class="number">20</span>) &amp;</div><div class="line">            (data.LONGITUDE &gt; <span class="number">-75</span>) &amp; (data.LONGITUDE &lt; <span class="number">-70</span>)</div><div class="line">            &amp; data.CATEGORY.notnull()]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_cat_list</span><span class="params">(catstr)</span>:</span></div><div class="line">    stripped = (x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> catstr.split(<span class="string">','</span>))</div><div class="line">    <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> stripped <span class="keyword">if</span> x]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_categories</span><span class="params">(cat_series)</span>:</span></div><div class="line">    cat_sets = (set(to_cat_list(x)) <span class="keyword">for</span> x <span class="keyword">in</span> cat_series)</div><div class="line">    <span class="keyword">return</span> sorted(set.union(*cat_sets))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_english</span><span class="params">(cat)</span>:</span></div><div class="line">    code, names = cat.split(<span class="string">'.'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="string">'|'</span> <span class="keyword">in</span> names:</div><div class="line">        names = names.split(<span class="string">' | '</span>)[<span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> code, names.strip()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get_english(<span class="string">'2. Urgences logistiques | Vital Lines'</span>)</div></pre></td></tr></table></figure><pre><code>(&#39;2&#39;, &#39;Vital Lines&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">all_cats = get_all_categories(data.CATEGORY)</div><div class="line"><span class="comment"># Generator expression</span></div><div class="line">english_mapping = dict(get_english(x) <span class="keyword">for</span> x <span class="keyword">in</span> all_cats)</div><div class="line">english_mapping[<span class="string">'2a'</span>]</div><div class="line">english_mapping[<span class="string">'6c'</span>]</div></pre></td></tr></table></figure><pre><code>&#39;Food Shortage&#39;






&#39;Earthquake and aftershocks&#39;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_code</span><span class="params">(seq)</span>:</span></div><div class="line">    <span class="keyword">return</span> [x.split(<span class="string">'.'</span>)[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> seq <span class="keyword">if</span> x]</div><div class="line"></div><div class="line">all_codes = get_code(all_cats)</div><div class="line">code_index = pd.Index(np.unique(all_codes))</div><div class="line">dummy_frame = DataFrame(np.zeros((len(data), len(code_index))),</div><div class="line">                        index=data.index, columns=code_index)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dummy_frame.ix[:, :<span class="number">6</span>].info()</div></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Int64Index: 3569 entries, 0 to 3592
Data columns (total 6 columns):
1     3569 non-null float64
1a    3569 non-null float64
1b    3569 non-null float64
1c    3569 non-null float64
1d    3569 non-null float64
2     3569 non-null float64
dtypes: float64(6)
memory usage: 195.2 KB
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> row, cat <span class="keyword">in</span> zip(data.index, data.CATEGORY):</div><div class="line">    codes = get_code(to_cat_list(cat))</div><div class="line">    dummy_frame.ix[row, codes] = <span class="number">1</span></div><div class="line"></div><div class="line">data = data.join(dummy_frame.add_prefix(<span class="string">'category_'</span>))</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.ix[:, <span class="number">10</span>:<span class="number">15</span>].info()</div></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Int64Index: 3569 entries, 0 to 3592
Data columns (total 5 columns):
category_1     3569 non-null float64
category_1a    3569 non-null float64
category_1b    3569 non-null float64
category_1c    3569 non-null float64
category_1d    3569 non-null float64
dtypes: float64(5)
memory usage: 167.3 KB
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mpl_toolkits.basemap <span class="keyword">import</span> Basemap</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">basic_haiti_map</span><span class="params">(ax=None, lllat=<span class="number">17.25</span>, urlat=<span class="number">20.25</span>,</span></span></div><div class="line">                    lllon=<span class="number">-75</span>, urlon=<span class="number">-71</span>):</div><div class="line">    <span class="comment"># create polar stereographic Basemap instance.</span></div><div class="line">    m = Basemap(ax=ax, projection=<span class="string">'stere'</span>,</div><div class="line">                lon_0=(urlon + lllon) / <span class="number">2</span>,</div><div class="line">                lat_0=(urlat + lllat) / <span class="number">2</span>,</div><div class="line">                llcrnrlat=lllat, urcrnrlat=urlat,</div><div class="line">                llcrnrlon=lllon, urcrnrlon=urlon,</div><div class="line">                resolution=<span class="string">'f'</span>)</div><div class="line">    <span class="comment"># draw coastlines, state and country boundaries, edge of map.</span></div><div class="line">    m.drawcoastlines()</div><div class="line">    m.drawstates()</div><div class="line">    m.drawcountries()</div><div class="line">    <span class="keyword">return</span> m</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">10</span>))</div><div class="line">fig.subplots_adjust(hspace=<span class="number">0.05</span>, wspace=<span class="number">0.05</span>)</div><div class="line"></div><div class="line">to_plot = [<span class="string">'2a'</span>, <span class="string">'1'</span>, <span class="string">'3c'</span>, <span class="string">'7a'</span>]</div><div class="line"></div><div class="line">lllat=<span class="number">17.25</span>; urlat=<span class="number">20.25</span>; lllon=<span class="number">-75</span>; urlon=<span class="number">-71</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> code, ax <span class="keyword">in</span> zip(to_plot, axes.flat):</div><div class="line">    m = basic_haiti_map(ax, lllat=lllat, urlat=urlat,</div><div class="line">                        lllon=lllon, urlon=urlon)</div><div class="line"></div><div class="line">    cat_data = data[data[<span class="string">'category_%s'</span> % code] == <span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="comment"># compute map proj coordinates.</span></div><div class="line">    x, y = m(cat_data.LONGITUDE.values, cat_data.LATITUDE.values)</div><div class="line"></div><div class="line">    m.plot(x, y, <span class="string">'k.'</span>, alpha=<span class="number">0.5</span>)</div><div class="line">    ax.set_title(<span class="string">'%s: %s'</span> % (code, english_mapping[code]))</div></pre></td></tr></table></figure><pre><code>C:\Users\Ewan\Anaconda3\envs\ipykernel_py2\lib\site-packages\mpl_toolkits\basemap\__init__.py:3260: MatplotlibDeprecationWarning: The ishold function was deprecated in version 2.0.
  b = ax.ishold()
C:\Users\Ewan\Anaconda3\envs\ipykernel_py2\lib\site-packages\mpl_toolkits\basemap\__init__.py:3269: MatplotlibDeprecationWarning: axes.hold is deprecated.
    See the API Changes document (http://matplotlib.org/api/api_changes.html)
    for more details.
  ax.hold(b)
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_75_9.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#街道数据的路径</span></div><div class="line">shapefilepath = <span class="string">'ch08/PortAuPrince_Roads/PortAuPrince_Roads'</span></div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line"></div><div class="line">lat0 = <span class="number">18.533333</span>;lon0 = <span class="number">-72.333333</span>;change = <span class="number">0.13</span>;</div><div class="line">lllat=lat0-change; urlat=lat0+change; lllon=lon0-change; urlon=lon0+change;</div><div class="line"></div><div class="line">m = basic_haiti_map(ax, lllat=lllat, urlat=urlat,lllon=lllon, urlon=urlon)</div><div class="line"></div><div class="line">m.readshapefile(shapefilepath,<span class="string">'roads'</span>) <span class="comment">#添加街道数据</span></div><div class="line"></div><div class="line">code = <span class="string">'2a'</span></div><div class="line">cat_data = data[data[<span class="string">'category_%s'</span> % code] == <span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment"># compute map proj coordinates.</span></div><div class="line">x, y = m(cat_data.LONGITUDE.values, cat_data.LATITUDE.values)</div><div class="line"></div><div class="line">m.plot(x, y, <span class="string">'k.'</span>, alpha=<span class="number">0.5</span>)</div><div class="line">ax.set_title(<span class="string">'Food shortages reported in Port-au-Prince'</span>)</div><div class="line"><span class="comment"># plt.savefig('myfig.png',dpi=400,bbox_inches='tight')</span></div></pre></td></tr></table></figure><pre><code>(1583,
 3,
 [-72.749246, 18.409952, 0.0, 0.0],
 [-71.973789, 18.7147105, 0.0, 0.0],
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/pydata/ch08/output_76_3.png" alt="png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;绘图和可视化&quot;&gt;&lt;a href=&quot;#绘图和可视化&quot; class=&quot;headerlink&quot; title=&quot;绘图和可视化&quot;&gt;&lt;/a&gt;绘图和可视化&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="matplotlib" scheme="http://yoursite.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>cs231n Assignment#1 softmax</title>
    <link href="http://yoursite.com/2017/03/05/cs231n-Assignment-1-softmax/"/>
    <id>http://yoursite.com/2017/03/05/cs231n-Assignment-1-softmax/</id>
    <published>2017-03-05T03:07:45.000Z</published>
    <updated>2017-03-05T03:14:56.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Softmax-exercise"><a href="#Softmax-exercise" class="headerlink" title="Softmax exercise"></a>Softmax exercise</h1><p><em>Complete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For more details see the <a href="http://vision.stanford.edu/teaching/cs231n/assignments.html" target="_blank" rel="external">assignments page</a> on the course website.</em></p><p>This exercise is analogous to the SVM exercise. You will:</p><ul><li>implement a fully-vectorized <strong>loss function</strong> for the Softmax classifier</li><li>implement the fully-vectorized expression for its <strong>analytic gradient</strong></li><li><strong>check your implementation</strong> with numerical gradient</li><li>use a validation set to <strong>tune the learning rate and regularization</strong> strength</li><li><strong>optimize</strong> the loss function with <strong>SGD</strong></li><li><strong>visualize</strong> the final learned weights</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> cs231n.data_utils <span class="keyword">import</span> load_CIFAR10</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">%matplotlib inline</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line"><span class="comment"># for auto-reloading extenrnal modules</span></div><div class="line"><span class="comment"># see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython</span></div><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_CIFAR10_data</span><span class="params">(num_training=<span class="number">49000</span>, num_validation=<span class="number">1000</span>, num_test=<span class="number">1000</span>, num_dev=<span class="number">500</span>)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">  Load the CIFAR-10 dataset from disk and perform preprocessing to prepare</div><div class="line">  it for the linear classifier. These are the same steps as we used for the</div><div class="line">  SVM, but condensed to a single function.  </div><div class="line">  """</div><div class="line">  <span class="comment"># Load the raw CIFAR-10 data</span></div><div class="line">  cifar10_dir = <span class="string">'cs231n/datasets/cifar-10-batches-py'</span></div><div class="line">  X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)</div><div class="line">  </div><div class="line">  <span class="comment"># subsample the data</span></div><div class="line">  mask = range(num_training, num_training + num_validation)</div><div class="line">  X_val = X_train[mask]</div><div class="line">  y_val = y_train[mask]</div><div class="line">  mask = range(num_training)</div><div class="line">  X_train = X_train[mask]</div><div class="line">  y_train = y_train[mask]</div><div class="line">  mask = range(num_test)</div><div class="line">  X_test = X_test[mask]</div><div class="line">  y_test = y_test[mask]</div><div class="line">  mask = np.random.choice(num_training, num_dev, replace=<span class="keyword">False</span>)</div><div class="line">  X_dev = X_train[mask]</div><div class="line">  y_dev = y_train[mask]</div><div class="line">  </div><div class="line">  <span class="comment"># Preprocessing: reshape the image data into rows</span></div><div class="line">  X_train = np.reshape(X_train, (X_train.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">  X_val = np.reshape(X_val, (X_val.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">  X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">  X_dev = np.reshape(X_dev, (X_dev.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">  </div><div class="line">  <span class="comment"># Normalize the data: subtract the mean image</span></div><div class="line">  mean_image = np.mean(X_train, axis = <span class="number">0</span>)</div><div class="line">  X_train -= mean_image</div><div class="line">  X_val -= mean_image</div><div class="line">  X_test -= mean_image</div><div class="line">  X_dev -= mean_image</div><div class="line">  </div><div class="line">  <span class="comment"># add bias dimension and transform into columns</span></div><div class="line">  X_train = np.hstack([X_train, np.ones((X_train.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">  X_val = np.hstack([X_val, np.ones((X_val.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">  X_test = np.hstack([X_test, np.ones((X_test.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">  X_dev = np.hstack([X_dev, np.ones((X_dev.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> X_train, y_train, X_val, y_val, X_test, y_test, X_dev, y_dev</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Invoke the above function to get our data.</span></div><div class="line">X_train, y_train, X_val, y_val, X_test, y_test, X_dev, y_dev = get_CIFAR10_data()</div><div class="line"><span class="keyword">print</span> <span class="string">'Train data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Train labels shape: '</span>, y_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation data shape: '</span>, X_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation labels shape: '</span>, y_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test labels shape: '</span>, y_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'dev data shape: '</span>, X_dev.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'dev labels shape: '</span>, y_dev.shape</div></pre></td></tr></table></figure><pre><code>Train data shape:  (49000L, 3073L)
Train labels shape:  (49000L,)
Validation data shape:  (1000L, 3073L)
Validation labels shape:  (1000L,)
Test data shape:  (1000L, 3073L)
Test labels shape:  (1000L,)
dev data shape:  (500L, 3073L)
dev labels shape:  (500L,)
</code></pre><h2 id="Softmax-Classifier"><a href="#Softmax-Classifier" class="headerlink" title="Softmax Classifier"></a>Softmax Classifier</h2><p>Your code for this section will all be written inside <strong>cs231n/classifiers/softmax.py</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># First implement the naive softmax loss function with nested loops.</span></div><div class="line"><span class="comment"># Open the file cs231n/classifiers/softmax.py and implement the</span></div><div class="line"><span class="comment"># softmax_loss_naive function.</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> cs231n.classifiers.softmax <span class="keyword">import</span> softmax_loss_naive</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># Generate a random softmax weight matrix and use it to compute the loss.</span></div><div class="line">W = np.random.randn(<span class="number">3073</span>, <span class="number">10</span>) * <span class="number">0.0001</span></div><div class="line">loss, grad = softmax_loss_naive(W, X_dev, y_dev, <span class="number">0.0</span>)</div><div class="line"></div><div class="line"><span class="comment"># As a rough sanity check, our loss should be something close to -log(0.1).</span></div><div class="line"><span class="keyword">print</span> <span class="string">'loss: %f'</span> % loss</div><div class="line"><span class="keyword">print</span> <span class="string">'sanity check: %f'</span> % (-np.log(<span class="number">0.1</span>))</div></pre></td></tr></table></figure><pre><code>loss: 2.395985
sanity check: 2.302585
</code></pre><h2 id="Inline-Question-1"><a href="#Inline-Question-1" class="headerlink" title="Inline Question 1:"></a>Inline Question 1:</h2><p>Why do we expect our loss to be close to -log(0.1)? Explain briefly.</p><p><strong>Your answer:</strong> <em>Because the W is selected by random, so the probability of select the true class is 1/10. That is, 0.1.</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Complete the implementation of softmax_loss_naive and implement a (naive)</span></div><div class="line"><span class="comment"># version of the gradient that uses nested loops.</span></div><div class="line">loss, grad = softmax_loss_naive(W, X_dev, y_dev, <span class="number">0.0</span>)</div><div class="line"></div><div class="line"><span class="comment"># As we did for the SVM, use numeric gradient checking as a debugging tool.</span></div><div class="line"><span class="comment"># The numeric gradient should be close to the analytic gradient.</span></div><div class="line"><span class="keyword">from</span> cs231n.gradient_check <span class="keyword">import</span> grad_check_sparse</div><div class="line">f = <span class="keyword">lambda</span> w: softmax_loss_naive(w, X_dev, y_dev, <span class="number">0.0</span>)[<span class="number">0</span>]</div><div class="line">grad_numerical = grad_check_sparse(f, W, grad, <span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment"># similar to SVM case, do another gradient check with regularization</span></div><div class="line">loss, grad = softmax_loss_naive(W, X_dev, y_dev, <span class="number">1e2</span>)</div><div class="line">f = <span class="keyword">lambda</span> w: softmax_loss_naive(w, X_dev, y_dev, <span class="number">1e2</span>)[<span class="number">0</span>]</div><div class="line">grad_numerical = grad_check_sparse(f, W, grad, <span class="number">10</span>)</div></pre></td></tr></table></figure><pre><code>numerical: 2.368141 analytic: 2.368141, relative error: 2.349797e-08
numerical: 1.324690 analytic: 1.324690, relative error: 7.140560e-08
numerical: 3.170412 analytic: 3.170411, relative error: 1.324741e-08
numerical: 0.249509 analytic: 0.249509, relative error: 2.647240e-08
numerical: 1.536095 analytic: 1.536095, relative error: 4.345856e-08
numerical: 1.075819 analytic: 1.075819, relative error: 3.902323e-08
numerical: -0.198098 analytic: -0.198098, relative error: 5.737134e-08
numerical: -0.089902 analytic: -0.089902, relative error: 8.604010e-07
numerical: -0.339487 analytic: -0.339487, relative error: 3.992996e-08
numerical: -4.819781 analytic: -4.819781, relative error: 3.465667e-09
numerical: 1.869922 analytic: 1.869921, relative error: 7.536693e-08
numerical: 0.783465 analytic: 0.783465, relative error: 6.960291e-08
numerical: -3.206007 analytic: -3.206007, relative error: 2.337350e-09
numerical: 0.532183 analytic: 0.532183, relative error: 1.498128e-07
numerical: 0.900500 analytic: 0.900500, relative error: 6.954913e-09
numerical: -0.353224 analytic: -0.353224, relative error: 1.836960e-07
numerical: -1.331470 analytic: -1.331470, relative error: 2.726426e-08
numerical: -0.082452 analytic: -0.082452, relative error: 7.712355e-07
numerical: -1.322133 analytic: -1.322133, relative error: 5.516628e-09
numerical: 0.345814 analytic: 0.345814, relative error: 1.251858e-07
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Now that we have a naive implementation of the softmax loss function and its gradient,</span></div><div class="line"><span class="comment"># implement a vectorized version in softmax_loss_vectorized.</span></div><div class="line"><span class="comment"># The two versions should compute the same results, but the vectorized version should be</span></div><div class="line"><span class="comment"># much faster.</span></div><div class="line">tic = time.time()</div><div class="line">loss_naive, grad_naive = softmax_loss_naive(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'naive loss: %e computed in %fs'</span> % (loss_naive, toc - tic)</div><div class="line"></div><div class="line"><span class="keyword">from</span> cs231n.classifiers.softmax <span class="keyword">import</span> softmax_loss_vectorized</div><div class="line">tic = time.time()</div><div class="line">loss_vectorized, grad_vectorized = softmax_loss_vectorized(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'vectorized loss: %e computed in %fs'</span> % (loss_vectorized, toc - tic)</div><div class="line"></div><div class="line"><span class="comment"># As we did for the SVM, we use the Frobenius norm to compare the two versions</span></div><div class="line"><span class="comment"># of the gradient.</span></div><div class="line">grad_difference = np.linalg.norm(grad_naive - grad_vectorized, ord=<span class="string">'fro'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'Loss difference: %f'</span> % np.abs(loss_naive - loss_vectorized)</div><div class="line"><span class="keyword">print</span> <span class="string">'Gradient difference: %f'</span> % grad_difference</div></pre></td></tr></table></figure><pre><code>naive loss: 2.395985e+00 computed in 0.080000s
vectorized loss: 2.395985e+00 computed in 0.003000s
Loss difference: 0.000000
Gradient difference: 0.000000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use the validation set to tune hyperparameters (regularization strength and</span></div><div class="line"><span class="comment"># learning rate). You should experiment with different ranges for the learning</span></div><div class="line"><span class="comment"># rates and regularization strengths; if you are careful you should be able to</span></div><div class="line"><span class="comment"># get a classification accuracy of over 0.35 on the validation set.</span></div><div class="line"><span class="keyword">from</span> cs231n.classifiers <span class="keyword">import</span> Softmax</div><div class="line">results = &#123;&#125;</div><div class="line">best_val = <span class="number">-1</span></div><div class="line">best_softmax = <span class="keyword">None</span></div><div class="line">learning_rates = [<span class="number">1e-8</span>, <span class="number">1e-7</span>, <span class="number">2e-7</span>]</div><div class="line">regularization_strengths = [<span class="number">1e4</span>, <span class="number">2e4</span>, <span class="number">3e4</span>, <span class="number">4e4</span>, <span class="number">5e4</span>, <span class="number">6e4</span>, <span class="number">7e4</span>, <span class="number">8e4</span>, <span class="number">1e5</span>]</div><div class="line"></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment"># <span class="doctag">TODO:</span>                                                                        #</span></div><div class="line"><span class="comment"># Use the validation set to set the learning rate and regularization strength. #</span></div><div class="line"><span class="comment"># This should be identical to the validation that you did for the SVM; save    #</span></div><div class="line"><span class="comment"># the best trained softmax classifer in best_softmax.                          #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line">iters = <span class="number">2000</span></div><div class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> learning_rates:</div><div class="line">    <span class="keyword">for</span> rs <span class="keyword">in</span> regularization_strengths:</div><div class="line">        softmax = Softmax()</div><div class="line">        softmax.train(X_train, y_train, learning_rate=lr, reg=rs, num_iters=iters)</div><div class="line">        </div><div class="line">        y_train_pred = softmax.predict(X_train)</div><div class="line">        acc_train = np.mean(y_train == y_train_pred)</div><div class="line">        y_val_pred = softmax.predict(X_val)</div><div class="line">        acc_val = np.mean(y_val == y_val_pred)</div><div class="line">        </div><div class="line">        results[(lr, rs)] = (acc_train, acc_val)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> best_val &lt; acc_val:</div><div class="line">            best_val = acc_val</div><div class="line">            best_softmax = softmax</div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment">#                              END OF YOUR CODE                                #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line">    </div><div class="line"><span class="comment"># Print out results.</span></div><div class="line"><span class="keyword">for</span> lr, reg <span class="keyword">in</span> sorted(results):</div><div class="line">    train_accuracy, val_accuracy = results[(lr, reg)]</div><div class="line">    <span class="keyword">print</span> <span class="string">'lr %e reg %e train accuracy: %f val accuracy: %f'</span> % (</div><div class="line">                lr, reg, train_accuracy, val_accuracy)</div><div class="line">    </div><div class="line"><span class="keyword">print</span> <span class="string">'best validation accuracy achieved during cross-validation: %f'</span> % best_val</div></pre></td></tr></table></figure><pre><code>lr 1.000000e-08 reg 1.000000e+04 train accuracy: 0.175633 val accuracy: 0.179000
lr 1.000000e-08 reg 2.000000e+04 train accuracy: 0.174102 val accuracy: 0.161000
lr 1.000000e-08 reg 3.000000e+04 train accuracy: 0.203490 val accuracy: 0.210000
lr 1.000000e-08 reg 4.000000e+04 train accuracy: 0.191367 val accuracy: 0.202000
lr 1.000000e-08 reg 5.000000e+04 train accuracy: 0.208000 val accuracy: 0.197000
lr 1.000000e-08 reg 6.000000e+04 train accuracy: 0.203571 val accuracy: 0.215000
lr 1.000000e-08 reg 7.000000e+04 train accuracy: 0.213551 val accuracy: 0.215000
lr 1.000000e-08 reg 8.000000e+04 train accuracy: 0.238347 val accuracy: 0.229000
lr 1.000000e-08 reg 1.000000e+05 train accuracy: 0.245102 val accuracy: 0.242000
lr 1.000000e-07 reg 1.000000e+04 train accuracy: 0.358265 val accuracy: 0.362000
lr 1.000000e-07 reg 2.000000e+04 train accuracy: 0.356306 val accuracy: 0.374000
lr 1.000000e-07 reg 3.000000e+04 train accuracy: 0.347327 val accuracy: 0.362000
lr 1.000000e-07 reg 4.000000e+04 train accuracy: 0.336347 val accuracy: 0.354000
lr 1.000000e-07 reg 5.000000e+04 train accuracy: 0.331490 val accuracy: 0.348000
lr 1.000000e-07 reg 6.000000e+04 train accuracy: 0.320163 val accuracy: 0.336000
lr 1.000000e-07 reg 7.000000e+04 train accuracy: 0.314551 val accuracy: 0.325000
lr 1.000000e-07 reg 8.000000e+04 train accuracy: 0.313082 val accuracy: 0.324000
lr 1.000000e-07 reg 1.000000e+05 train accuracy: 0.303000 val accuracy: 0.315000
lr 2.000000e-07 reg 1.000000e+04 train accuracy: 0.374163 val accuracy: 0.389000
lr 2.000000e-07 reg 2.000000e+04 train accuracy: 0.353184 val accuracy: 0.365000
lr 2.000000e-07 reg 3.000000e+04 train accuracy: 0.340265 val accuracy: 0.359000
lr 2.000000e-07 reg 4.000000e+04 train accuracy: 0.334673 val accuracy: 0.351000
lr 2.000000e-07 reg 5.000000e+04 train accuracy: 0.326531 val accuracy: 0.337000
lr 2.000000e-07 reg 6.000000e+04 train accuracy: 0.319857 val accuracy: 0.336000
lr 2.000000e-07 reg 7.000000e+04 train accuracy: 0.317878 val accuracy: 0.329000
lr 2.000000e-07 reg 8.000000e+04 train accuracy: 0.310449 val accuracy: 0.329000
lr 2.000000e-07 reg 1.000000e+05 train accuracy: 0.316286 val accuracy: 0.315000
best validation accuracy achieved during cross-validation: 0.389000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># evaluate on test set</span></div><div class="line"><span class="comment"># Evaluate the best softmax on test set</span></div><div class="line">y_test_pred = best_softmax.predict(X_test)</div><div class="line">test_accuracy = np.mean(y_test == y_test_pred)</div><div class="line"><span class="keyword">print</span> <span class="string">'softmax on raw pixels final test set accuracy: %f'</span> % (test_accuracy, )</div></pre></td></tr></table></figure><pre><code>softmax on raw pixels final test set accuracy: 0.375000
</code></pre><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize the learned weights for each class</span></div><div class="line">w = best_softmax.W[:<span class="number">-1</span>,:] <span class="comment"># strip out the bias</span></div><div class="line">w = w.reshape(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">w_min, w_max = np.min(w), np.max(w)</div><div class="line"></div><div class="line">classes = [<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>, <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</div><div class="line">  plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i + <span class="number">1</span>)</div><div class="line">  </div><div class="line">  <span class="comment"># Rescale the weights to be between 0 and 255</span></div><div class="line">  wimg = <span class="number">255.0</span> * (w[:, :, :, i].squeeze() - w_min) / (w_max - w_min)</div><div class="line">  plt.imshow(wimg.astype(<span class="string">'uint8'</span>))</div><div class="line">  plt.axis(<span class="string">'off'</span>)</div><div class="line">  plt.title(classes[i])</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/softmax/template.png" alt="template"></p><h1 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax_loss_naive</span><span class="params">(W, X, y, reg)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Softmax loss function, naive implementation (with loops)</div><div class="line"></div><div class="line">    Inputs have dimension D, there are C classes, and we operate on minibatches</div><div class="line">    of N examples.</div><div class="line"></div><div class="line">    Inputs:</div><div class="line">    - W: A numpy array of shape (D, C) containing weights.</div><div class="line">    - X: A numpy array of shape (N, D) containing a minibatch of data.</div><div class="line">    - y: A numpy array of shape (N,) containing training labels; y[i] = c means</div><div class="line">      that X[i] has label c, where 0 &lt;= c &lt; C.</div><div class="line">    - reg: (float) regularization strength</div><div class="line"></div><div class="line">    Returns a tuple of:</div><div class="line">    - loss as single float</div><div class="line">    - gradient with respect to weights W; an array of same shape as W</div><div class="line">    """</div><div class="line">    <span class="comment"># Initialize the loss and gradient to zero.</span></div><div class="line">    loss = <span class="number">0.0</span></div><div class="line">    dW = np.zeros_like(W)</div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span> Compute the softmax loss and its gradient using explicit loops.     #</span></div><div class="line">    <span class="comment"># Store the loss in loss and the gradient in dW. If you are not careful     #</span></div><div class="line">    <span class="comment"># here, it is easy to run into numeric instability. Don't forget the        #</span></div><div class="line">    <span class="comment"># regularization!                                                           #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    num_train = X.shape[<span class="number">0</span>]</div><div class="line">    num_classes = W.shape[<span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_train):</div><div class="line">        f = X[i, :].dot(W)</div><div class="line">        f -= np.max(f)</div><div class="line">        correct_f = f[y[i]]</div><div class="line">        denom = np.sum(np.exp(f))</div><div class="line"></div><div class="line">        p = np.exp(correct_f) / denom</div><div class="line">        loss += -np.log(p)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(num_classes):</div><div class="line">            <span class="keyword">if</span> j == y[i]:</div><div class="line">                dW[:, y[i]] += (np.exp(f[j]) / denom - <span class="number">1</span>) * X[i, :]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                dW[:, j] += (np.exp(f[j]) / denom) * X[i, :]</div><div class="line"></div><div class="line">    loss /= num_train</div><div class="line">    loss += <span class="number">0.5</span> * reg * np.sum(W * W)</div><div class="line"></div><div class="line">    dW /= num_train</div><div class="line">    dW += reg * W</div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment">#                          END OF YOUR CODE                                 #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> loss, dW</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax_loss_vectorized</span><span class="params">(W, X, y, reg)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Softmax loss function, vectorized version.</div><div class="line"></div><div class="line">    Inputs and outputs are the same as softmax_loss_naive.</div><div class="line">    """</div><div class="line">    <span class="comment"># Initialize the loss and gradient to zero.</span></div><div class="line">    loss = <span class="number">0.0</span></div><div class="line">    dW = np.zeros_like(W)</div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span> Compute the softmax loss and its gradient using no explicit loops.  #</span></div><div class="line">    <span class="comment"># Store the loss in loss and the gradient in dW. If you are not careful     #</span></div><div class="line">    <span class="comment"># here, it is easy to run into numeric instability. Don't forget the        #</span></div><div class="line">    <span class="comment"># regularization!                                                           #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    num_train = X.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">    f = X.dot(W)</div><div class="line">    f = f - np.max(f, axis=<span class="number">1</span>)[:, np.newaxis]</div><div class="line">    loss = -np.sum(</div><div class="line">        np.log(np.exp(f[np.arange(num_train), y]) / np.sum(np.exp(f), axis=<span class="number">1</span>)))</div><div class="line"></div><div class="line">    loss /= num_train</div><div class="line">    loss += <span class="number">0.5</span> * reg * np.sum(W * W)</div><div class="line"></div><div class="line">    ind = np.zeros_like(f)</div><div class="line">    ind[np.arange(num_train), y] = <span class="number">1</span></div><div class="line">    dW = X.T.dot(np.exp(f) / np.sum(np.exp(f), axis=<span class="number">1</span>, keepdims=<span class="keyword">True</span>) - ind)</div><div class="line"></div><div class="line">    dW /= num_train</div><div class="line">    dW += reg * W</div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment">#                          END OF YOUR CODE                                 #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> loss, dW</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Softmax-exercise&quot;&gt;&lt;a href=&quot;#Softmax-exercise&quot; class=&quot;headerlink&quot; title=&quot;Softmax exercise&quot;&gt;&lt;/a&gt;Softmax exercise&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Complete a
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="softmax" scheme="http://yoursite.com/tags/softmax/"/>
    
  </entry>
  
  <entry>
    <title>cs231n Assignment#1 svm</title>
    <link href="http://yoursite.com/2017/03/03/cs231n-Assignment-1-svm/"/>
    <id>http://yoursite.com/2017/03/03/cs231n-Assignment-1-svm/</id>
    <published>2017-03-03T10:55:44.000Z</published>
    <updated>2017-03-03T11:04:37.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multiclass-Support-Vector-Machine-exercise"><a href="#Multiclass-Support-Vector-Machine-exercise" class="headerlink" title="Multiclass Support Vector Machine exercise"></a>Multiclass Support Vector Machine exercise</h1><p><em>Complete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For more details see the <a href="http://vision.stanford.edu/teaching/cs231n/assignments.html" target="_blank" rel="external">assignments page</a> on the course website.</em></p><p>In this exercise you will:<br>​</p><ul><li>implement a fully-vectorized <strong>loss function</strong> for the SVM</li><li>implement the fully-vectorized expression for its <strong>analytic gradient</strong></li><li><strong>check your implementation</strong> using numerical gradient</li><li>use a validation set to <strong>tune the learning rate and regularization</strong> strength</li><li><strong>optimize</strong> the loss function with <strong>SGD</strong></li><li><strong>visualize</strong> the final learned weights</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Run some setup code for this notebook.</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> cs231n.data_utils <span class="keyword">import</span> load_CIFAR10</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># This is a bit of magic to make matplotlib figures appear inline in the</span></div><div class="line"><span class="comment"># notebook rather than in a new window.</span></div><div class="line">%matplotlib inline</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line"><span class="comment"># Some more magic so that the notebook will reload external python modules;</span></div><div class="line"><span class="comment"># see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython</span></div><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div></pre></td></tr></table></figure><h2 id="CIFAR-10-Data-Loading-and-Preprocessing"><a href="#CIFAR-10-Data-Loading-and-Preprocessing" class="headerlink" title="CIFAR-10 Data Loading and Preprocessing"></a>CIFAR-10 Data Loading and Preprocessing</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Load the raw CIFAR-10 data.</span></div><div class="line">cifar10_dir = <span class="string">'cs231n/datasets/cifar-10-batches-py'</span></div><div class="line">X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)</div><div class="line"></div><div class="line"><span class="comment"># As a sanity check, we print out the size of the training and test data.</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Training data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Training labels shape: '</span>, y_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test labels shape: '</span>, y_test.shape</div></pre></td></tr></table></figure><pre><code>Training data shape:  (50000L, 32L, 32L, 3L)
Training labels shape:  (50000L,)
Test data shape:  (10000L, 32L, 32L, 3L)
Test labels shape:  (10000L,)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize some examples from the dataset.</span></div><div class="line"><span class="comment"># We show a few examples of training images from each class.</span></div><div class="line">classes = [<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>, <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>]</div><div class="line">num_classes = len(classes)</div><div class="line">samples_per_class = <span class="number">7</span></div><div class="line"><span class="keyword">for</span> y, cls <span class="keyword">in</span> enumerate(classes):</div><div class="line">    idxs = np.flatnonzero(y_train == y)</div><div class="line">    idxs = np.random.choice(idxs, samples_per_class, replace=<span class="keyword">False</span>)</div><div class="line">    <span class="keyword">for</span> i, idx <span class="keyword">in</span> enumerate(idxs):</div><div class="line">        plt_idx = i * num_classes + y + <span class="number">1</span></div><div class="line">        plt.subplot(samples_per_class, num_classes, plt_idx)</div><div class="line">        plt.imshow(X_train[idx].astype(<span class="string">'uint8'</span>))</div><div class="line">        plt.axis(<span class="string">'off'</span>)</div><div class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</div><div class="line">            plt.title(cls)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/sample.png" alt="sample"></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?np.random.choice</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Split the data into train, val, and test sets. In addition we will</span></div><div class="line"><span class="comment"># create a small development set as a subset of the training data;</span></div><div class="line"><span class="comment"># we can use this for development so our code runs faster.</span></div><div class="line">num_training = <span class="number">49000</span></div><div class="line">num_validation = <span class="number">1000</span></div><div class="line">num_test = <span class="number">1000</span></div><div class="line">num_dev = <span class="number">500</span></div><div class="line"></div><div class="line"><span class="comment"># Our validation set will be num_validation points from the original</span></div><div class="line"><span class="comment"># training set.</span></div><div class="line">mask = range(num_training, num_training + num_validation)</div><div class="line">X_val = X_train[mask]</div><div class="line">y_val = y_train[mask]</div><div class="line"></div><div class="line"><span class="comment"># Our training set will be the first num_train points from the original</span></div><div class="line"><span class="comment"># training set.</span></div><div class="line">mask = range(num_training)</div><div class="line">X_train = X_train[mask]</div><div class="line">y_train = y_train[mask]</div><div class="line"></div><div class="line"><span class="comment"># We will also make a development set, which is a small subset of</span></div><div class="line"><span class="comment"># the training set.</span></div><div class="line">mask = np.random.choice(num_training, num_dev, replace=<span class="keyword">False</span>)</div><div class="line">X_dev = X_train[mask]</div><div class="line">y_dev = y_train[mask]</div><div class="line"></div><div class="line"><span class="comment"># We use the first num_test points of the original test set as our</span></div><div class="line"><span class="comment"># test set.</span></div><div class="line">mask = range(num_test)</div><div class="line">X_test = X_test[mask]</div><div class="line">y_test = y_test[mask]</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'Train data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Train labels shape: '</span>, y_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation data shape: '</span>, X_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation labels shape: '</span>, y_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test labels shape: '</span>, y_test.shape</div></pre></td></tr></table></figure><pre><code>Train data shape:  (49000L, 32L, 32L, 3L)
Train labels shape:  (49000L,)
Validation data shape:  (1000L, 32L, 32L, 3L)
Validation labels shape:  (1000L,)
Test data shape:  (1000L, 32L, 32L, 3L)
Test labels shape:  (1000L,)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Preprocessing: reshape the image data into rows</span></div><div class="line">X_train = np.reshape(X_train, (X_train.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">X_val = np.reshape(X_val, (X_val.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line">X_dev = np.reshape(X_dev, (X_dev.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line"></div><div class="line"><span class="comment"># As a sanity check, print out the shapes of the data</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Training data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Validation data shape: '</span>, X_val.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'dev data shape: '</span>, X_dev.shape</div></pre></td></tr></table></figure><pre><code>Training data shape:  (49000L, 3072L)
Validation data shape:  (1000L, 3072L)
Test data shape:  (1000L, 3072L)
dev data shape:  (500L, 3072L)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Preprocessing: subtract the mean image</span></div><div class="line"><span class="comment"># first: compute the image mean based on the training data</span></div><div class="line">mean_image = np.mean(X_train, axis=<span class="number">0</span>)</div><div class="line"><span class="keyword">print</span> mean_image[:<span class="number">10</span>] <span class="comment"># print a few of the elements</span></div><div class="line">plt.figure(figsize=(<span class="number">4</span>,<span class="number">4</span>))</div><div class="line">plt.imshow(mean_image.reshape((<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>)).astype(<span class="string">'uint8'</span>)) <span class="comment"># visualize the mean image</span></div><div class="line">plt.show()</div></pre></td></tr></table></figure><pre><code>[ 130.64189796  135.98173469  132.47391837  130.05569388  135.34804082
  131.75402041  130.96055102  136.14328571  132.47636735  131.48467347]
</code></pre><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/mean.png" alt="mean"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># second: subtract the mean image from train and test data</span></div><div class="line">X_train -= mean_image</div><div class="line">X_val -= mean_image</div><div class="line">X_test -= mean_image</div><div class="line">X_dev -= mean_image</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># third: append (at the last) the bias dimension of ones (i.e. bias trick) so that our SVM</span></div><div class="line"><span class="comment"># only has to worry about optimizing a single weight matrix W.</span></div><div class="line">X_train = np.hstack([X_train, np.ones((X_train.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">X_val = np.hstack([X_val, np.ones((X_val.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">X_test = np.hstack([X_test, np.ones((X_test.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line">X_dev = np.hstack([X_dev, np.ones((X_dev.shape[<span class="number">0</span>], <span class="number">1</span>))])</div><div class="line"></div><div class="line"><span class="keyword">print</span> X_train.shape, X_val.shape, X_test.shape, X_dev.shape</div></pre></td></tr></table></figure><pre><code>(49000L, 3073L) (1000L, 3073L) (1000L, 3073L) (500L, 3073L)
</code></pre><p>​</p><h2 id="SVM-Classifier"><a href="#SVM-Classifier" class="headerlink" title="SVM Classifier"></a>SVM Classifier</h2><p>Your code for this section will all be written inside <strong>cs231n/classifiers/linear_svm.py</strong>.</p><p>As you can see, we have prefilled the function <code>compute_loss_naive</code> which uses for loops to evaluate the multiclass SVM loss function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Evaluate the naive implementation of the loss we provided for you:</span></div><div class="line"><span class="keyword">from</span> cs231n.classifiers.linear_svm <span class="keyword">import</span> svm_loss_naive</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># generate a random SVM weight matrix of small numbers</span></div><div class="line">W = np.random.randn(<span class="number">3073</span>, <span class="number">10</span>) * <span class="number">0.0001</span> </div><div class="line"></div><div class="line">loss, grad = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'loss: %f'</span> % (loss, )</div></pre></td></tr></table></figure><pre><code>loss: 8.831645
</code></pre><p>​</p><p>The <code>grad</code> returned from the function above is right now all zero. Derive and implement the gradient for the SVM cost function and implement it inline inside the function <code>svm_loss_naive</code>. You will find it helpful to interleave your new code inside the existing function.</p><p>To check that you have correctly implemented the gradient correctly, you can numerically estimate the gradient of the loss function and compare the numeric estimate to the gradient that you computed. We have provided code that does this for you:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Once you've implemented the gradient, recompute it with the code below</span></div><div class="line"><span class="comment"># and gradient check it with the function we provided for you</span></div><div class="line"></div><div class="line"><span class="comment"># Compute the loss and its gradient at W.</span></div><div class="line">loss, grad = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.0</span>)</div><div class="line"></div><div class="line"><span class="comment"># Numerically compute the gradient along several randomly chosen dimensions, and</span></div><div class="line"><span class="comment"># compare them with your analytically computed gradient. The numbers should match</span></div><div class="line"><span class="comment"># almost exactly along all dimensions.</span></div><div class="line"><span class="keyword">from</span> cs231n.gradient_check <span class="keyword">import</span> grad_check_sparse</div><div class="line">f = <span class="keyword">lambda</span> w: svm_loss_naive(w, X_dev, y_dev, <span class="number">0.0</span>)[<span class="number">0</span>]</div><div class="line">grad_numerical = grad_check_sparse(f, W, grad)</div><div class="line"></div><div class="line"><span class="comment"># do the gradient check once again with regularization turned on</span></div><div class="line"><span class="comment"># you didn't forget the regularization gradient did you?</span></div><div class="line">loss, grad = svm_loss_naive(W, X_dev, y_dev, <span class="number">1e2</span>)</div><div class="line">f = <span class="keyword">lambda</span> w: svm_loss_naive(w, X_dev, y_dev, <span class="number">1e2</span>)[<span class="number">0</span>]</div><div class="line">grad_numerical = grad_check_sparse(f, W, grad)</div></pre></td></tr></table></figure><pre><code>numerical: -13.865929 analytic: -13.865929, relative error: 1.283977e-12
numerical: 7.842142 analytic: 7.735021, relative error: 6.876784e-03
numerical: 3.464393 analytic: 3.464393, relative error: 9.040092e-11
numerical: -23.034911 analytic: -23.034911, relative error: 6.876266e-12
numerical: -0.185311 analytic: -0.185311, relative error: 2.538774e-10
numerical: 25.825504 analytic: 25.825504, relative error: 1.336035e-11
numerical: 4.457836 analytic: 4.457836, relative error: 1.015819e-10
numerical: 3.184691 analytic: 3.184691, relative error: 8.849109e-11
numerical: 10.428446 analytic: 10.374317, relative error: 2.601982e-03
numerical: 12.479957 analytic: 12.479957, relative error: 6.825191e-12
numerical: 12.237949 analytic: 12.326308, relative error: 3.597051e-03
numerical: 4.377103 analytic: 4.377103, relative error: 3.904758e-11
numerical: -1.951930 analytic: -1.951930, relative error: 1.432276e-10
numerical: 33.752503 analytic: 33.752503, relative error: 4.254520e-12
numerical: 11.367149 analytic: 11.367149, relative error: 1.682727e-11
numerical: 16.461879 analytic: 16.461879, relative error: 4.766805e-12
numerical: 3.814562 analytic: 3.814562, relative error: 1.087469e-10
numerical: 13.931226 analytic: 13.931226, relative error: 9.578349e-12
numerical: -27.291095 analytic: -27.395406, relative error: 1.907445e-03
numerical: -7.610407 analytic: -7.610407, relative error: 1.015282e-12
</code></pre><h3 id="Inline-Question-1"><a href="#Inline-Question-1" class="headerlink" title="Inline Question 1:"></a>Inline Question 1:</h3><p>It is possible that once in a while a dimension in the gradcheck will not match exactly. What could such a discrepancy be caused by? Is it a reason for concern? What is a simple example in one dimension where a gradient check could fail? <em>Hint: the SVM loss function is not strictly speaking differentiable</em></p><p><strong>Your Answer:</strong> <em>Maybe the SVM loss function is not differentiable on that dimension</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?np.max</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.sum(np.maximum(<span class="number">0</span>, X_dev.dot(W) - X_dev.dot(W)[np.arange(len(y_dev)), [y_dev]].T + <span class="number">1</span>))</div></pre></td></tr></table></figure><pre><code>4915.822409730994
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Next implement the function svm_loss_vectorized; for now only compute the loss;</span></div><div class="line"><span class="comment"># we will implement the gradient in a moment.</span></div><div class="line">tic = time.time()</div><div class="line">loss_naive, grad_naive = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Naive loss: %e computed in %fs'</span> % (loss_naive, toc - tic)</div><div class="line"></div><div class="line"><span class="keyword">from</span> cs231n.classifiers.linear_svm <span class="keyword">import</span> svm_loss_vectorized</div><div class="line">tic = time.time()</div><div class="line">loss_vectorized, _ = svm_loss_vectorized(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Vectorized loss: %e computed in %fs'</span> % (loss_vectorized, toc - tic)</div><div class="line"></div><div class="line"><span class="comment"># The losses should match but your vectorized implementation should be much faster.</span></div><div class="line"><span class="keyword">print</span> <span class="string">'difference: %f'</span> % (loss_naive - loss_vectorized)</div></pre></td></tr></table></figure><pre><code>Naive loss: 8.831645e+00 computed in 0.071000s
Vectorized loss: 8.831645e+00 computed in 0.000000s
difference: 0.000000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Complete the implementation of svm_loss_vectorized, and compute the gradient</span></div><div class="line"><span class="comment"># of the loss function in a vectorized way.</span></div><div class="line"></div><div class="line"><span class="comment"># The naive implementation and the vectorized implementation should match, but</span></div><div class="line"><span class="comment"># the vectorized version should still be much faster.</span></div><div class="line">tic = time.time()</div><div class="line">_, grad_naive = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Naive loss and gradient: computed in %fs'</span> % (toc - tic)</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line">_, grad_vectorized = svm_loss_vectorized(W, X_dev, y_dev, <span class="number">0.00001</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'Vectorized loss and gradient: computed in %fs'</span> % (toc - tic)</div><div class="line"></div><div class="line"><span class="comment"># The loss is a single number, so it is easy to compare the values computed</span></div><div class="line"><span class="comment"># by the two implementations. The gradient on the other hand is a matrix, so</span></div><div class="line"><span class="comment"># we use the Frobenius norm to compare them.</span></div><div class="line">difference = np.linalg.norm(grad_naive - grad_vectorized, ord=<span class="string">'fro'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'difference: %f'</span> % difference</div></pre></td></tr></table></figure><pre><code>Naive loss and gradient: computed in 0.084000s
Vectorized loss and gradient: computed in 0.005000s
difference: 0.000000
</code></pre><h3 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h3><p>We now have vectorized and efficient expressions for the loss, the gradient and our gradient matches the numerical gradient. We are therefore ready to do SGD to minimize the loss.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># In the file linear_classifier.py, implement SGD in the function</span></div><div class="line"><span class="comment"># LinearClassifier.train() and then run it with the code below.</span></div><div class="line"><span class="keyword">from</span> cs231n.classifiers <span class="keyword">import</span> LinearSVM</div><div class="line">svm = LinearSVM()</div><div class="line">tic = time.time()</div><div class="line">loss_hist = svm.train(X_train, y_train, learning_rate=<span class="number">1e-7</span>, reg=<span class="number">5e4</span>,</div><div class="line">                      num_iters=<span class="number">1500</span>, verbose=<span class="keyword">True</span>)</div><div class="line">toc = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">'That took %fs'</span> % (toc - tic)</div></pre></td></tr></table></figure><pre><code>iteration 0 / 1500: loss 791.772037
iteration 100 / 1500: loss 286.021346
iteration 200 / 1500: loss 107.673095
iteration 300 / 1500: loss 41.812791
iteration 400 / 1500: loss 18.665578
iteration 500 / 1500: loss 10.614984
iteration 600 / 1500: loss 6.664814
iteration 700 / 1500: loss 6.509693
iteration 800 / 1500: loss 5.792204
iteration 900 / 1500: loss 4.986855
iteration 1000 / 1500: loss 5.914691
iteration 1100 / 1500: loss 5.058078
iteration 1200 / 1500: loss 5.491475
iteration 1300 / 1500: loss 5.609450
iteration 1400 / 1500: loss 5.376595
That took 5.454000s
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A useful debugging strategy is to plot the loss as a function of</span></div><div class="line"><span class="comment"># iteration number:</span></div><div class="line">plt.plot(loss_hist)</div><div class="line">plt.xlabel(<span class="string">'Iteration number'</span>)</div><div class="line">plt.ylabel(<span class="string">'Loss value'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/learning_curve.png" alt="learning_curve"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Write the LinearSVM.predict function and evaluate the performance on both the</span></div><div class="line"><span class="comment"># training and validation set</span></div><div class="line">y_train_pred = svm.predict(X_train)</div><div class="line"><span class="keyword">print</span> <span class="string">'training accuracy: %f'</span> % (np.mean(y_train == y_train_pred), )</div><div class="line">y_val_pred = svm.predict(X_val)</div><div class="line"><span class="keyword">print</span> <span class="string">'validation accuracy: %f'</span> % (np.mean(y_val == y_val_pred), )</div></pre></td></tr></table></figure><pre><code>training accuracy: 0.364980
validation accuracy: 0.378000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use the validation set to tune hyperparameters (regularization strength and</span></div><div class="line"><span class="comment"># learning rate). You should experiment with different ranges for the learning</span></div><div class="line"><span class="comment"># rates and regularization strengths; if you are careful you should be able to</span></div><div class="line"><span class="comment"># get a classification accuracy of about 0.4 on the validation set.</span></div><div class="line">learning_rates = [<span class="number">1e-8</span>, <span class="number">1e-7</span>, <span class="number">2e-7</span>]</div><div class="line">regularization_strengths = [<span class="number">1e4</span>, <span class="number">2e4</span>, <span class="number">3e4</span>, <span class="number">4e4</span>, <span class="number">5e4</span>, <span class="number">6e4</span>, <span class="number">7e4</span>, <span class="number">8e4</span>, <span class="number">1e5</span>]</div><div class="line"></div><div class="line"><span class="comment"># results is dictionary mapping tuples of the form</span></div><div class="line"><span class="comment"># (learning_rate, regularization_strength) to tuples of the form</span></div><div class="line"><span class="comment"># (training_accuracy, validation_accuracy). The accuracy is simply the fraction</span></div><div class="line"><span class="comment"># of data points that are correctly classified.</span></div><div class="line">results = &#123;&#125;</div><div class="line">best_val = <span class="number">-1</span>   <span class="comment"># The highest validation accuracy that we have seen so far.</span></div><div class="line">best_svm = <span class="keyword">None</span> <span class="comment"># The LinearSVM object that achieved the highest validation rate.</span></div><div class="line"></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment"># <span class="doctag">TODO:</span>                                                                        #</span></div><div class="line"><span class="comment"># Write code that chooses the best hyperparameters by tuning on the validation #</span></div><div class="line"><span class="comment"># set. For each combination of hyperparameters, train a linear SVM on the      #</span></div><div class="line"><span class="comment"># training set, compute its accuracy on the training and validation sets, and  #</span></div><div class="line"><span class="comment"># store these numbers in the results dictionary. In addition, store the best   #</span></div><div class="line"><span class="comment"># validation accuracy in best_val and the LinearSVM object that achieves this  #</span></div><div class="line"><span class="comment"># accuracy in best_svm.                                                        #</span></div><div class="line"><span class="comment">#                                                                              #</span></div><div class="line"><span class="comment"># Hint: You should use a small value for num_iters as you develop your         #</span></div><div class="line"><span class="comment"># validation code so that the SVMs don't take much time to train; once you are #</span></div><div class="line"><span class="comment"># confident that your validation code works, you should rerun the validation   #</span></div><div class="line"><span class="comment"># code with a larger value for num_iters.                                      #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="keyword">for</span> learning_rate <span class="keyword">in</span> learning_rates:</div><div class="line">    <span class="keyword">for</span> regularization_strength <span class="keyword">in</span> regularization_strengths:</div><div class="line">        svm = LinearSVM()</div><div class="line">        loss_hist = svm.train(</div><div class="line">            X_train, y_train, learning_rate, \</div><div class="line">            regularization_strength, num_iters=<span class="number">1500</span>, batch_size=<span class="number">200</span>)</div><div class="line">        y_train_pred = svm.predict(X_train)</div><div class="line">        y_val_pred = svm.predict(X_val)</div><div class="line">        training_accuracy = np.mean(y_train == y_train_pred)</div><div class="line">        validation_accuracy = np.mean(y_val == y_val_pred)</div><div class="line">        results[(learning_rate, regularization_strength)] = \</div><div class="line">        (training_accuracy, validation_accuracy)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> validation_accuracy &gt; best_val:</div><div class="line">            best_val = validation_accuracy</div><div class="line">            best_svm = svm</div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment">#                              END OF YOUR CODE                                #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line">    </div><div class="line"><span class="comment"># Print out results.</span></div><div class="line"><span class="keyword">for</span> lr, reg <span class="keyword">in</span> sorted(results):</div><div class="line">    train_accuracy, val_accuracy = results[(lr, reg)]</div><div class="line">    <span class="keyword">print</span> <span class="string">'lr %e reg %e train accuracy: %f val accuracy: %f'</span> % (</div><div class="line">                lr, reg, train_accuracy, val_accuracy)</div><div class="line">    </div><div class="line"><span class="keyword">print</span> <span class="string">'best validation accuracy achieved during cross-validation: %f'</span> % best_val</div></pre></td></tr></table></figure><pre><code>lr 1.000000e-08 reg 1.000000e+04 train accuracy: 0.221898 val accuracy: 0.247000
lr 1.000000e-08 reg 2.000000e+04 train accuracy: 0.233653 val accuracy: 0.258000
lr 1.000000e-08 reg 3.000000e+04 train accuracy: 0.234694 val accuracy: 0.225000
lr 1.000000e-08 reg 4.000000e+04 train accuracy: 0.255959 val accuracy: 0.249000
lr 1.000000e-08 reg 5.000000e+04 train accuracy: 0.259755 val accuracy: 0.273000
lr 1.000000e-08 reg 6.000000e+04 train accuracy: 0.267408 val accuracy: 0.269000
lr 1.000000e-08 reg 7.000000e+04 train accuracy: 0.269102 val accuracy: 0.287000
lr 1.000000e-08 reg 8.000000e+04 train accuracy: 0.277102 val accuracy: 0.285000
lr 1.000000e-08 reg 1.000000e+05 train accuracy: 0.295306 val accuracy: 0.301000
lr 1.000000e-07 reg 1.000000e+04 train accuracy: 0.369388 val accuracy: 0.374000
lr 1.000000e-07 reg 2.000000e+04 train accuracy: 0.380265 val accuracy: 0.390000
lr 1.000000e-07 reg 3.000000e+04 train accuracy: 0.375490 val accuracy: 0.378000
lr 1.000000e-07 reg 4.000000e+04 train accuracy: 0.375633 val accuracy: 0.385000
lr 1.000000e-07 reg 5.000000e+04 train accuracy: 0.369694 val accuracy: 0.375000
lr 1.000000e-07 reg 6.000000e+04 train accuracy: 0.372469 val accuracy: 0.383000
lr 1.000000e-07 reg 7.000000e+04 train accuracy: 0.356000 val accuracy: 0.370000
lr 1.000000e-07 reg 8.000000e+04 train accuracy: 0.352816 val accuracy: 0.355000
lr 1.000000e-07 reg 1.000000e+05 train accuracy: 0.356796 val accuracy: 0.377000
lr 2.000000e-07 reg 1.000000e+04 train accuracy: 0.393510 val accuracy: 0.395000
lr 2.000000e-07 reg 2.000000e+04 train accuracy: 0.377020 val accuracy: 0.382000
lr 2.000000e-07 reg 3.000000e+04 train accuracy: 0.363857 val accuracy: 0.373000
lr 2.000000e-07 reg 4.000000e+04 train accuracy: 0.368714 val accuracy: 0.372000
lr 2.000000e-07 reg 5.000000e+04 train accuracy: 0.361531 val accuracy: 0.364000
lr 2.000000e-07 reg 6.000000e+04 train accuracy: 0.354714 val accuracy: 0.368000
lr 2.000000e-07 reg 7.000000e+04 train accuracy: 0.348306 val accuracy: 0.365000
lr 2.000000e-07 reg 8.000000e+04 train accuracy: 0.358082 val accuracy: 0.378000
lr 2.000000e-07 reg 1.000000e+05 train accuracy: 0.347898 val accuracy: 0.358000
best validation accuracy achieved during cross-validation: 0.395000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize the cross-validation results</span></div><div class="line"><span class="keyword">import</span> math</div><div class="line">x_scatter = [math.log10(x[<span class="number">0</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> results]</div><div class="line">y_scatter = [math.log10(x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> results]</div><div class="line"></div><div class="line"><span class="comment"># plot training accuracy</span></div><div class="line">marker_size = <span class="number">100</span></div><div class="line">colors = [results[x][<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> results]</div><div class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">plt.scatter(x_scatter, y_scatter, marker_size, c=colors)</div><div class="line">plt.colorbar()</div><div class="line">plt.xlabel(<span class="string">'log learning rate'</span>)</div><div class="line">plt.ylabel(<span class="string">'log regularization strength'</span>)</div><div class="line">plt.title(<span class="string">'CIFAR-10 training accuracy'</span>)</div><div class="line"></div><div class="line"><span class="comment"># plot validation accuracy</span></div><div class="line">colors = [results[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> results] <span class="comment"># default size of markers is 20</span></div><div class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>)</div><div class="line">plt.scatter(x_scatter, y_scatter, marker_size, c=colors)</div><div class="line">plt.colorbar()</div><div class="line">plt.xlabel(<span class="string">'log learning rate'</span>)</div><div class="line">plt.ylabel(<span class="string">'log regularization strength'</span>)</div><div class="line">plt.title(<span class="string">'CIFAR-10 validation accuracy'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/accuracy.png" alt="accuracy"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Evaluate the best svm on test set</span></div><div class="line">y_test_pred = best_svm.predict(X_test)</div><div class="line">test_accuracy = np.mean(y_test == y_test_pred)</div><div class="line"><span class="keyword">print</span> <span class="string">'linear SVM on raw pixels final test set accuracy: %f'</span> % test_accuracy</div></pre></td></tr></table></figure><pre><code>linear SVM on raw pixels final test set accuracy: 0.383000
</code></pre><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = np.array([[[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>]]])</div><div class="line">np.squeeze(x)</div></pre></td></tr></table></figure><pre><code>array([0, 1, 2])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize the learned weights for each class.</span></div><div class="line"><span class="comment"># Depending on your choice of learning rate and regularization strength, these may</span></div><div class="line"><span class="comment"># or may not be nice to look at.</span></div><div class="line">w = best_svm.W[:<span class="number">-1</span>,:] <span class="comment"># strip out the bias</span></div><div class="line">w = w.reshape(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">10</span>)</div><div class="line">w_min, w_max = np.min(w), np.max(w)</div><div class="line">classes = [<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>, <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</div><div class="line">  plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i + <span class="number">1</span>)</div><div class="line">    </div><div class="line">  <span class="comment"># Rescale the weights to be between 0 and 255</span></div><div class="line">  wimg = <span class="number">255.0</span> * (w[:, :, :, i].squeeze() - w_min) / (w_max - w_min)</div><div class="line">  plt.imshow(wimg.astype(<span class="string">'uint8'</span>))</div><div class="line">  plt.axis(<span class="string">'off'</span>)</div><div class="line">  plt.title(classes[i])</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/svm/weight.png" alt="weight"></p><h3 id="Inline-question-2"><a href="#Inline-question-2" class="headerlink" title="Inline question 2:"></a>Inline question 2:</h3><p>Describe what your visualized SVM weights look like, and offer a brief explanation for why they look they way that they do.</p><p><strong>Your answer:</strong> <em>fill this in</em></p><h1 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h1><h2 id="linear-svm-py"><a href="#linear-svm-py" class="headerlink" title="linear_svm.py"></a>linear_svm.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_loss_naive</span><span class="params">(W, X, y, reg)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Structured SVM loss function, naive implementation (with loops).</div><div class="line"></div><div class="line">    Inputs have dimension D, there are C classes, and we operate on minibatches</div><div class="line">    of N examples.</div><div class="line"></div><div class="line">    Inputs:</div><div class="line">    - W: A numpy array of shape (D, C) containing weights.</div><div class="line">    - X: A numpy array of shape (N, D) containing a minibatch of data.</div><div class="line">    - y: A numpy array of shape (N,) containing training labels; y[i] = c means</div><div class="line">      that X[i] has label c, where 0 &lt;= c &lt; C.</div><div class="line">    - reg: (float) regularization strength</div><div class="line"></div><div class="line">    Returns a tuple of:</div><div class="line">    - loss as single float</div><div class="line">    - gradient with respect to weights W; an array of same shape as W</div><div class="line">    """</div><div class="line">    dW = np.zeros(W.shape)  <span class="comment"># initialize the gradient as zero</span></div><div class="line"></div><div class="line">    <span class="comment"># compute the loss and the gradient</span></div><div class="line">    num_classes = W.shape[<span class="number">1</span>]</div><div class="line">    num_train = X.shape[<span class="number">0</span>]</div><div class="line">    loss = <span class="number">0.0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_train):</div><div class="line">        scores = X[i].dot(W)</div><div class="line">        correct_class_score = scores[y[i]]</div><div class="line"></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(num_classes):</div><div class="line">            <span class="keyword">if</span> j == y[i]:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            margin = scores[j] - correct_class_score + <span class="number">1</span>  <span class="comment"># note delta = 1</span></div><div class="line">            <span class="keyword">if</span> margin &gt; <span class="number">0</span>:</div><div class="line">                dW[:, y[i]] -= X[i, :]</div><div class="line">                dW[:, j] += X[i, :]</div><div class="line">                loss += margin</div><div class="line"></div><div class="line">    <span class="comment"># Right now the loss is a sum over all training examples, but we want it</span></div><div class="line">    <span class="comment"># to be an average instead so we divide by num_train.</span></div><div class="line">    loss /= num_train</div><div class="line"></div><div class="line">    dW /= num_train</div><div class="line"></div><div class="line">    <span class="comment"># Add regularization to the loss.</span></div><div class="line">    loss += <span class="number">0.5</span> * reg * np.sum(W * W)</div><div class="line">    dW += reg * W</div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span>                                                                     #</span></div><div class="line">    <span class="comment"># Compute the gradient of the loss function and store it dW.                #</span></div><div class="line">    <span class="comment"># Rather that first computing the loss and then computing the derivative,     #</span></div><div class="line">    <span class="comment"># it may be simpler to compute the derivative at the same time that the     #</span></div><div class="line">    <span class="comment"># loss is being computed. As a result you may need to modify some of the    #</span></div><div class="line">    <span class="comment"># code above to compute the gradient.                                       #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> loss, dW</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_loss_vectorized</span><span class="params">(W, X, y, reg)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Structured SVM loss function, vectorized implementation.</div><div class="line"></div><div class="line">    Inputs and outputs are the same as svm_loss_naive.</div><div class="line">    """</div><div class="line">    loss = <span class="number">0.0</span></div><div class="line">    dW = np.zeros(W.shape)  <span class="comment"># initialize the gradient as zero</span></div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span>                                                                     #</span></div><div class="line">    <span class="comment"># Implement a vectorized version of the structured SVM loss, storing the    #</span></div><div class="line">    <span class="comment"># result in loss.                                                           #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    num_train = X.shape[<span class="number">0</span>]</div><div class="line">    delta = <span class="number">1.0</span></div><div class="line"></div><div class="line">    scores = X.dot(W)</div><div class="line">    correct_class_score = scores[np.arange(num_train), y]</div><div class="line"></div><div class="line">    margins = np.maximum(</div><div class="line">        <span class="number">0</span>, scores - correct_class_score[:, np.newaxis] + delta)</div><div class="line">    margins[np.arange(num_train), y] = <span class="number">0</span></div><div class="line"></div><div class="line">    loss = np.sum(margins)</div><div class="line"></div><div class="line">    loss /= num_train</div><div class="line"></div><div class="line">    loss += <span class="number">0.5</span> * reg * np.sum(W.T.dot(W))</div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment">#                             END OF YOUR CODE                              #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment"># <span class="doctag">TODO:</span>                                                                     #</span></div><div class="line">    <span class="comment"># Implement a vectorized version of the gradient for the structured SVM     #</span></div><div class="line">    <span class="comment"># loss, storing the result in dW.                                           #</span></div><div class="line">    <span class="comment">#                                                                           #</span></div><div class="line">    <span class="comment"># Hint: Instead of computing the gradient from scratch, it may be easier    #</span></div><div class="line">    <span class="comment"># to reuse some of the intermediate values that you used to compute the     #</span></div><div class="line">    <span class="comment"># loss.                                                                     #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    X_mask = np.zeros(margins.shape)</div><div class="line">    X_mask[margins &gt; <span class="number">0</span>] = <span class="number">1</span></div><div class="line"></div><div class="line">    count = np.sum(X_mask, axis=<span class="number">1</span>)</div><div class="line">    X_mask[np.arange(num_train), y] = -count</div><div class="line"></div><div class="line">    dW = X.T.dot(X_mask)</div><div class="line"></div><div class="line">    dW /= num_train</div><div class="line"></div><div class="line">    dW += np.multiply(W, reg)</div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line">    <span class="comment">#                             END OF YOUR CODE                              #</span></div><div class="line">    <span class="comment">#############################################################################</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> loss, dW</div></pre></td></tr></table></figure><h2 id="linear-classifier"><a href="#linear-classifier" class="headerlink" title="linear_classifier"></a>linear_classifier</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> cs231n.classifiers.linear_svm <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> cs231n.classifiers.softmax <span class="keyword">import</span> *</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearClassifier</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.W = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y, learning_rate=<span class="number">1e-3</span>, reg=<span class="number">1e-5</span>, num_iters=<span class="number">100</span>,</span></span></div><div class="line">              batch_size=<span class="number">200</span>, verbose=False):</div><div class="line">        <span class="string">"""</span></div><div class="line">        Train this linear classifier using stochastic gradient descent.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: A numpy array of shape (N, D) containing training data; there are N</div><div class="line">          training samples each of dimension D.</div><div class="line">        - y: A numpy array of shape (N,) containing training labels; y[i] = c</div><div class="line">          means that X[i] has label 0 &lt;= c &lt; C for C classes.</div><div class="line">        - learning_rate: (float) learning rate for optimization.</div><div class="line">        - reg: (float) regularization strength.</div><div class="line">        - num_iters: (integer) number of steps to take when optimizing</div><div class="line">        - batch_size: (integer) number of training examples to use at each step.</div><div class="line">        - verbose: (boolean) If true, print progress during optimization.</div><div class="line"></div><div class="line">        Outputs:</div><div class="line">        A list containing the value of the loss function at each training iteration.</div><div class="line">        """</div><div class="line">        num_train, dim = X.shape</div><div class="line">        num_classes = np.max(y) + <span class="number">1</span>  <span class="comment"># assume y takes values 0...K-1 where K is number of classes</span></div><div class="line">        <span class="keyword">if</span> self.W <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="comment"># lazily initialize W</span></div><div class="line">            self.W = <span class="number">0.001</span> * np.random.randn(dim, num_classes)</div><div class="line"></div><div class="line">        <span class="comment"># Run stochastic gradient descent to optimize W</span></div><div class="line">        loss_history = []</div><div class="line">        <span class="keyword">for</span> it <span class="keyword">in</span> xrange(num_iters):</div><div class="line">            X_batch = <span class="keyword">None</span></div><div class="line">            y_batch = <span class="keyword">None</span></div><div class="line"></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></div><div class="line">            <span class="comment"># Sample batch_size elements from the training data and their           #</span></div><div class="line">            <span class="comment"># corresponding labels to use in this round of gradient descent.        #</span></div><div class="line">            <span class="comment"># Store the data in X_batch and their corresponding labels in           #</span></div><div class="line">            <span class="comment"># y_batch; after sampling X_batch should have shape (dim, batch_size)   #</span></div><div class="line">            <span class="comment"># and y_batch should have shape (batch_size,)                           #</span></div><div class="line">            <span class="comment">#                                                                       #</span></div><div class="line">            <span class="comment"># Hint: Use np.random.choice to generate indices. Sampling with         #</span></div><div class="line">            <span class="comment"># replacement is faster than sampling without replacement.              #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            mask = np.random.choice(num_train, batch_size, replace=<span class="keyword">True</span>)</div><div class="line">            X_batch = X[mask]</div><div class="line">            y_batch = y[mask]</div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment">#                       END OF YOUR CODE                                #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line"></div><div class="line">            <span class="comment"># evaluate loss and gradient</span></div><div class="line">            loss, grad = self.loss(X_batch, y_batch, reg)</div><div class="line">            loss_history.append(loss)</div><div class="line"></div><div class="line">            <span class="comment"># perform parameter update</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></div><div class="line">            <span class="comment"># Update the weights using the gradient and the learning rate.          #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            self.W = self.W - learning_rate * grad</div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line">            <span class="comment">#                       END OF YOUR CODE                                #</span></div><div class="line">            <span class="comment">#########################################################################</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> it % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'iteration %d / %d: loss %f'</span> % (it, num_iters, loss)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> loss_history</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Use the trained weights of this linear classifier to predict labels for</div><div class="line">        data points.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: D x N array of training data. Each column is a D-dimensional point.</div><div class="line"></div><div class="line">        Returns:</div><div class="line">        - y_pred: Predicted labels for the data in X. y_pred is a 1-dimensional</div><div class="line">          array of length N, and each element is an integer giving the predicted</div><div class="line">          class.</div><div class="line">        """</div><div class="line">        X = X.T</div><div class="line">        y_pred = np.zeros(X.shape[<span class="number">1</span>])</div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span>                                                                   #</span></div><div class="line">        <span class="comment"># Implement this method. Store the predicted labels in y_pred.            #</span></div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        scores = X.T.dot(self.W)</div><div class="line">        y_pred = np.argsort(scores, axis=<span class="number">1</span>)[:, <span class="number">-1</span>]</div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="comment">#                           END OF YOUR CODE                              #</span></div><div class="line">        <span class="comment">###########################################################################</span></div><div class="line">        <span class="keyword">return</span> y_pred</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X_batch, y_batch, reg)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Compute the loss function and its derivative.</div><div class="line">        Subclasses will override this.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X_batch: A numpy array of shape (N, D) containing a minibatch of N</div><div class="line">          data points; each point has dimension D.</div><div class="line">        - y_batch: A numpy array of shape (N,) containing labels for the minibatch.</div><div class="line">        - reg: (float) regularization strength.</div><div class="line"></div><div class="line">        Returns: A tuple containing:</div><div class="line">        - loss as a single float</div><div class="line">        - gradient with respect to self.W; an array of the same shape as W</div><div class="line">        """</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearSVM</span><span class="params">(LinearClassifier)</span>:</span></div><div class="line">    <span class="string">""" A subclass that uses the Multiclass SVM loss function """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X_batch, y_batch, reg)</span>:</span></div><div class="line">        <span class="keyword">return</span> svm_loss_vectorized(self.W, X_batch, y_batch, reg)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Softmax</span><span class="params">(LinearClassifier)</span>:</span></div><div class="line">    <span class="string">""" A subclass that uses the Softmax + Cross-entropy loss function """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X_batch, y_batch, reg)</span>:</span></div><div class="line">        <span class="keyword">return</span> softmax_loss_vectorized(self.W, X_batch, y_batch, reg)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Multiclass-Support-Vector-Machine-exercise&quot;&gt;&lt;a href=&quot;#Multiclass-Support-Vector-Machine-exercise&quot; class=&quot;headerlink&quot; title=&quot;Multicla
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="svm" scheme="http://yoursite.com/tags/svm/"/>
    
  </entry>
  
  <entry>
    <title>cs231n Assignment#1 kNN</title>
    <link href="http://yoursite.com/2017/03/02/cs231n-Assignment-1-kNN/"/>
    <id>http://yoursite.com/2017/03/02/cs231n-Assignment-1-kNN/</id>
    <published>2017-03-02T14:26:57.000Z</published>
    <updated>2017-03-02T14:43:27.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k-Nearest-Neighbor-kNN-exercise"><a href="#k-Nearest-Neighbor-kNN-exercise" class="headerlink" title="k-Nearest Neighbor (kNN) exercise"></a>k-Nearest Neighbor (kNN) exercise</h1><p><em>Complete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For more details see the <a href="http://vision.stanford.edu/teaching/cs231n/assignments.html" target="_blank" rel="external">assignments page</a> on the course website.</em></p><p>The kNN classifier consists of two stages:</p><ul><li>During training, the classifier takes the training data and simply remembers it</li><li>During testing, kNN classifies every test image by comparing to all training images and transfering the labels of the k most similar training examples</li><li>The value of k is cross-validated</li></ul><p>In this exercise you will implement these steps and understand the basic Image Classification pipeline, cross-validation, and gain proficiency in writing efficient, vectorized code.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Run some setup code for this notebook.</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> cs231n.data_utils <span class="keyword">import</span> load_CIFAR10</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># This is a bit of magic to make matplotlib figures appear inline in the notebook</span></div><div class="line"><span class="comment"># rather than in a new window.</span></div><div class="line">%matplotlib inline</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment"># set default size of plots</span></div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line"><span class="comment"># Some more magic so that the notebook will reload external python modules;</span></div><div class="line"><span class="comment"># see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython</span></div><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Load the raw CIFAR-10 data.</span></div><div class="line">cifar10_dir = <span class="string">'cs231n/datasets/cifar-10-batches-py'</span></div><div class="line">X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)</div><div class="line"></div><div class="line"><span class="comment"># As a sanity check, we print out the size of the training and test data.</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Training data shape: '</span>, X_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Training labels shape: '</span>, y_train.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test data shape: '</span>, X_test.shape</div><div class="line"><span class="keyword">print</span> <span class="string">'Test labels shape: '</span>, y_test.shape</div></pre></td></tr></table></figure><pre><code>Training data shape:  (50000L, 32L, 32L, 3L)
Training labels shape:  (50000L,)
Test data shape:  (10000L, 32L, 32L, 3L)
Test labels shape:  (10000L,)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Visualize some examples from the dataset.</span></div><div class="line"><span class="comment"># We show a few examples of training images from each class.</span></div><div class="line">classes = [<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>, <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>]</div><div class="line">num_classes = len(classes)</div><div class="line">samples_per_class = <span class="number">7</span></div><div class="line"><span class="keyword">for</span> y, cls <span class="keyword">in</span> enumerate(classes):</div><div class="line">    idxs = np.flatnonzero(y_train == y)</div><div class="line">    idxs = np.random.choice(idxs, samples_per_class, replace=<span class="keyword">False</span>)</div><div class="line">    <span class="keyword">for</span> i, idx <span class="keyword">in</span> enumerate(idxs):</div><div class="line">        plt_idx = i * num_classes + y + <span class="number">1</span></div><div class="line">        plt.subplot(samples_per_class, num_classes, plt_idx)</div><div class="line">        plt.imshow(X_train[idx].astype(<span class="string">'uint8'</span>))</div><div class="line">        plt.axis(<span class="string">'off'</span>)</div><div class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</div><div class="line">            plt.title(cls)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/knn/sample.png" alt="sample"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Subsample the data for more efficient code execution in this exercise</span></div><div class="line">num_training = <span class="number">5000</span></div><div class="line">mask = range(num_training)</div><div class="line">X_train = X_train[mask]</div><div class="line">y_train = y_train[mask]</div><div class="line"></div><div class="line">num_test = <span class="number">500</span></div><div class="line">mask = range(num_test)</div><div class="line">X_test = X_test[mask]</div><div class="line">y_test = y_test[mask]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Reshape the image data into rows</span></div><div class="line">X_train = np.reshape(X_train, (X_train.shape[<span class="number">0</span>], <span class="number">-1</span>)) <span class="comment"># Wow~</span></div><div class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], <span class="number">-1</span>))</div><div class="line"><span class="keyword">print</span> X_train.shape, X_test.shape</div></pre></td></tr></table></figure><pre><code>(5000L, 3072L) (500L, 3072L)
</code></pre><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> cs231n.classifiers <span class="keyword">import</span> KNearestNeighbor</div><div class="line"></div><div class="line"><span class="comment"># Create a kNN classifier instance. </span></div><div class="line"><span class="comment"># Remember that training a kNN classifier is a noop: </span></div><div class="line"><span class="comment"># the Classifier simply remembers the data and does no further processing </span></div><div class="line">classifier = KNearestNeighbor()</div><div class="line">classifier.train(X_train, y_train)</div></pre></td></tr></table></figure><p>We would now like to classify the test data with the kNN classifier. Recall that we can break down this process into two steps:</p><ol><li>First we must compute the distances between all test examples and all train examples.</li><li>Given these distances, for each test example we find the k nearest examples and have them vote for the label</li></ol><p>Lets begin with computing the distance matrix between all training and test examples. For example, if there are <strong>Ntr</strong> training examples and <strong>Nte</strong> test examples, this stage should result in a <strong>Nte x Ntr</strong> matrix where each element (i,j) is the distance between the i-th test and j-th train example.</p><p>First, open <code>cs231n/classifiers/k_nearest_neighbor.py</code> and implement the function <code>compute_distances_two_loops</code> that uses a (very inefficient) double loop over all pairs of (test, train) examples and computes the distance matrix one element at a time.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Open cs231n/classifiers/k_nearest_neighbor.py and implement</span></div><div class="line"><span class="comment"># compute_distances_two_loops.</span></div><div class="line"></div><div class="line"><span class="comment"># Test your implementation:</span></div><div class="line">dists = classifier.compute_distances_two_loops(X_test)</div><div class="line"><span class="keyword">print</span> dists.shape</div></pre></td></tr></table></figure><pre><code>(500L, 5000L)
</code></pre><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># We can visualize the distance matrix: each row is a single test example and</span></div><div class="line"><span class="comment"># its distances to training examples</span></div><div class="line">plt.imshow(dists, interpolation=<span class="string">'none'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/knn/dists.png" alt="dists"></p><p><strong>Inline Question #1:</strong> Notice the structured patterns in the distance matrix, where some rows or columns are visible brighter. (Note that with the default color scheme black indicates low distances while white indicates high distances.)</p><ul><li>What in the data is the cause behind the distinctly bright rows?</li><li>What causes the columns?</li></ul><p><strong>Your Answer</strong>: <em>Maybe exists noises in test data set and train data set.</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Now implement the function predict_labels and run the code below:</span></div><div class="line"><span class="comment"># We use k = 1 (which is Nearest Neighbor).</span></div><div class="line">y_test_pred = classifier.predict_labels(dists, k=<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># Compute and print the fraction of correctly predicted examples</span></div><div class="line">num_correct = np.sum(y_test_pred == y_test)</div><div class="line">accuracy = float(num_correct) / num_test</div><div class="line"><span class="keyword">print</span> <span class="string">'Got %d / %d correct =&gt; accuracy: %f'</span> % (num_correct, num_test, accuracy)</div></pre></td></tr></table></figure><pre><code>Got 137 / 500 correct =&gt; accuracy: 0.274000
</code></pre><p>​</p><p>You should expect to see approximately <code>27%</code> accuracy. Now lets try out a larger <code>k</code>, say <code>k = 5</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">y_test_pred = classifier.predict_labels(dists, k=<span class="number">5</span>)</div><div class="line">num_correct = np.sum(y_test_pred == y_test)</div><div class="line">accuracy = float(num_correct) / num_test</div><div class="line"><span class="keyword">print</span> <span class="string">'Got %d / %d correct =&gt; accuracy: %f'</span> % (num_correct, num_test, accuracy)</div></pre></td></tr></table></figure><pre><code>Got 142 / 500 correct =&gt; accuracy: 0.284000
</code></pre><p>​</p><p>You should expect to see a slightly better performance than with <code>k = 1</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Now lets speed up distance matrix computation by using partial vectorization</span></div><div class="line"><span class="comment"># with one loop. Implement the function compute_distances_one_loop and run the</span></div><div class="line"><span class="comment"># code below:</span></div><div class="line">dists_one = classifier.compute_distances_one_loop(X_test)</div><div class="line"></div><div class="line"><span class="comment"># To ensure that our vectorized implementation is correct, we make sure that it</span></div><div class="line"><span class="comment"># agrees with the naive implementation. There are many ways to decide whether</span></div><div class="line"><span class="comment"># two matrices are similar; one of the simplest is the Frobenius norm. In case</span></div><div class="line"><span class="comment"># you haven't seen it before, the Frobenius norm of two matrices is the square</span></div><div class="line"><span class="comment"># root of the squared sum of differences of all elements; in other words, reshape</span></div><div class="line"><span class="comment"># the matrices into vectors and compute the Euclidean distance between them.</span></div><div class="line">difference = np.linalg.norm(dists - dists_one, ord=<span class="string">'fro'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'Difference was: %f'</span> % (difference, )</div><div class="line"><span class="keyword">if</span> difference &lt; <span class="number">0.001</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">'Good! The distance matrices are the same'</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">'Uh-oh! The distance matrices are different'</span></div></pre></td></tr></table></figure><pre><code>Difference was: 0.000000
Good! The distance matrices are the same
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Now implement the fully vectorized version inside compute_distances_no_loops</span></div><div class="line"><span class="comment"># and run the code</span></div><div class="line">dists_two = classifier.compute_distances_no_loops(X_test)</div><div class="line"></div><div class="line"><span class="comment"># check that the distance matrix agrees with the one we computed before:</span></div><div class="line">difference = np.linalg.norm(dists - dists_two, ord=<span class="string">'fro'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'Difference was: %f'</span> % (difference, )</div><div class="line"><span class="keyword">if</span> difference &lt; <span class="number">0.001</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">'Good! The distance matrices are the same'</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">'Uh-oh! The distance matrices are different'</span></div></pre></td></tr></table></figure><pre><code>Difference was: 0.000000
Good! The distance matrices are the same
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Let's compare how fast the implementations are</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_function</span><span class="params">(f, *args)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">  Call a function f with args and return the time (in seconds) that it took to execute.</div><div class="line">  """</div><div class="line">  <span class="keyword">import</span> time</div><div class="line">  tic = time.time()</div><div class="line">  f(*args)</div><div class="line">  toc = time.time()</div><div class="line">  <span class="keyword">return</span> toc - tic</div><div class="line"></div><div class="line">two_loop_time = time_function(classifier.compute_distances_two_loops, X_test)</div><div class="line"><span class="keyword">print</span> <span class="string">'Two loop version took %f seconds'</span> % two_loop_time</div><div class="line"></div><div class="line">one_loop_time = time_function(classifier.compute_distances_one_loop, X_test)</div><div class="line"><span class="keyword">print</span> <span class="string">'One loop version took %f seconds'</span> % one_loop_time</div><div class="line"></div><div class="line">no_loop_time = time_function(classifier.compute_distances_no_loops, X_test)</div><div class="line"><span class="keyword">print</span> <span class="string">'No loop version took %f seconds'</span> % no_loop_time</div><div class="line"></div><div class="line"><span class="comment"># you should see significantly faster performance with the fully vectorized implementation</span></div></pre></td></tr></table></figure><pre><code>Two loop version took 27.001000 seconds
One loop version took 59.630000 seconds
No loop version took 0.205000 seconds
</code></pre><h3 id="Cross-validation"><a href="#Cross-validation" class="headerlink" title="Cross-validation"></a>Cross-validation</h3><p>We have implemented the k-Nearest Neighbor classifier but we set the value k = 5 arbitrarily. We will now determine the best value of this hyperparameter with cross-validation.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">num_folds = <span class="number">5</span></div><div class="line">k_choices = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]</div><div class="line"></div><div class="line">X_train_folds = []</div><div class="line">y_train_folds = []</div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment"># <span class="doctag">TODO:</span>                                                                        #</span></div><div class="line"><span class="comment"># Split up the training data into folds. After splitting, X_train_folds and    #</span></div><div class="line"><span class="comment"># y_train_folds should each be lists of length num_folds, where                #</span></div><div class="line"><span class="comment"># y_train_folds[i] is the label vector for the points in X_train_folds[i].     #</span></div><div class="line"><span class="comment"># Hint: Look up the numpy array_split function.                                #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line">X_train_folds = np.array_split(X_train, num_folds)</div><div class="line">y_train_folds = np.array_split(y_train, num_folds)</div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment">#                                 END OF YOUR CODE                             #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"></div><div class="line"><span class="comment"># A dictionary holding the accuracies for different values of k that we find</span></div><div class="line"><span class="comment"># when running cross-validation. After running cross-validation,</span></div><div class="line"><span class="comment"># k_to_accuracies[k] should be a list of length num_folds giving the different</span></div><div class="line"><span class="comment"># accuracy values that we found when using that value of k.</span></div><div class="line">k_to_accuracies = &#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment"># <span class="doctag">TODO:</span>                                                                        #</span></div><div class="line"><span class="comment"># Perform k-fold cross validation to find the best value of k. For each        #</span></div><div class="line"><span class="comment"># possible value of k, run the k-nearest-neighbor algorithm num_folds times,   #</span></div><div class="line"><span class="comment"># where in each case you use all but one of the folds as training data and the #</span></div><div class="line"><span class="comment"># last fold as a validation set. Store the accuracies for all fold and all     #</span></div><div class="line"><span class="comment"># values of k in the k_to_accuracies dictionary.                               #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_choices:</div><div class="line">    k_to_accuracies[k] = []</div><div class="line">    <span class="keyword">for</span> fold <span class="keyword">in</span> xrange(num_folds):</div><div class="line">        train_X = np.append(</div><div class="line">            X_train_folds[:fold], X_train_folds[fold+<span class="number">1</span>:]).reshape(</div><div class="line">            (X_train.shape[<span class="number">0</span>] - X_train.shape[<span class="number">0</span>]/num_folds, <span class="number">-1</span>))</div><div class="line">        train_y = np.append(</div><div class="line">            y_train_folds[:fold], y_train_folds[fold+<span class="number">1</span>:]).reshape(</div><div class="line">            (y_train.shape[<span class="number">0</span>] - y_train.shape[<span class="number">0</span>]/num_folds, <span class="number">-1</span>)).flatten()</div><div class="line">        classifier.train(train_X, train_y)</div><div class="line">        dists = classifier.compute_distances_no_loops(X_train_folds[fold])</div><div class="line">        y_test_pred = classifier.predict_labels(dists, k)</div><div class="line">        </div><div class="line">        num_correct = np.sum(y_test_pred == y_train_folds[fold])</div><div class="line">        accuracy = float(num_correct) / len(y_train_folds[fold])</div><div class="line">        k_to_accuracies[k].append(accuracy)</div><div class="line">        </div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="comment">#                                 END OF YOUR CODE                             #</span></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"></div><div class="line"><span class="comment"># Print out the computed accuracies</span></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> sorted(k_to_accuracies):</div><div class="line">    <span class="keyword">for</span> accuracy <span class="keyword">in</span> k_to_accuracies[k]:</div><div class="line">        <span class="keyword">print</span> <span class="string">'k = %d, accuracy = %f'</span> % (k, accuracy)</div></pre></td></tr></table></figure><pre><code>k = 1, accuracy = 0.263000
k = 1, accuracy = 0.257000
k = 1, accuracy = 0.264000
k = 1, accuracy = 0.278000
k = 1, accuracy = 0.266000
k = 3, accuracy = 0.241000
k = 3, accuracy = 0.249000
k = 3, accuracy = 0.243000
k = 3, accuracy = 0.273000
k = 3, accuracy = 0.264000
k = 5, accuracy = 0.258000
k = 5, accuracy = 0.273000
k = 5, accuracy = 0.281000
k = 5, accuracy = 0.290000
k = 5, accuracy = 0.272000
k = 8, accuracy = 0.263000
k = 8, accuracy = 0.288000
k = 8, accuracy = 0.278000
k = 8, accuracy = 0.285000
k = 8, accuracy = 0.277000
k = 10, accuracy = 0.265000
k = 10, accuracy = 0.296000
k = 10, accuracy = 0.278000
k = 10, accuracy = 0.284000
k = 10, accuracy = 0.286000
k = 12, accuracy = 0.260000
k = 12, accuracy = 0.294000
k = 12, accuracy = 0.281000
k = 12, accuracy = 0.282000
k = 12, accuracy = 0.281000
k = 15, accuracy = 0.255000
k = 15, accuracy = 0.290000
k = 15, accuracy = 0.281000
k = 15, accuracy = 0.281000
k = 15, accuracy = 0.276000
k = 20, accuracy = 0.270000
k = 20, accuracy = 0.281000
k = 20, accuracy = 0.280000
k = 20, accuracy = 0.282000
k = 20, accuracy = 0.284000
k = 50, accuracy = 0.271000
k = 50, accuracy = 0.288000
k = 50, accuracy = 0.278000
k = 50, accuracy = 0.269000
k = 50, accuracy = 0.266000
k = 100, accuracy = 0.256000
k = 100, accuracy = 0.270000
k = 100, accuracy = 0.263000
k = 100, accuracy = 0.256000
k = 100, accuracy = 0.263000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># plot the raw observations</span></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_choices:</div><div class="line">  accuracies = k_to_accuracies[k]</div><div class="line">  plt.scatter([k] * len(accuracies), accuracies)</div><div class="line"></div><div class="line"><span class="comment"># plot the trend line with error bars that correspond to standard deviation</span></div><div class="line">accuracies_mean = np.array([np.mean(v) <span class="keyword">for</span> k,v <span class="keyword">in</span> sorted(k_to_accuracies.items())])</div><div class="line">accuracies_std = np.array([np.std(v) <span class="keyword">for</span> k,v <span class="keyword">in</span> sorted(k_to_accuracies.items())])</div><div class="line">plt.errorbar(k_choices, accuracies_mean, yerr=accuracies_std)</div><div class="line">plt.title(<span class="string">'Cross-validation on k'</span>)</div><div class="line">plt.xlabel(<span class="string">'k'</span>)</div><div class="line">plt.ylabel(<span class="string">'Cross-validation accuracy'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/assignment/01/knn/cv.png" alt="cv"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Based on the cross-validation results above, choose the best value for k,   </span></div><div class="line"><span class="comment"># retrain the classifier using all the training data, and test it on the test</span></div><div class="line"><span class="comment"># data. You should be able to get above 28% accuracy on the test data.</span></div><div class="line">best_k = <span class="number">10</span></div><div class="line"></div><div class="line">classifier = KNearestNeighbor()</div><div class="line">classifier.train(X_train, y_train)</div><div class="line">y_test_pred = classifier.predict(X_test, k=best_k)</div><div class="line"></div><div class="line"><span class="comment"># Compute and display the accuracy</span></div><div class="line">num_correct = np.sum(y_test_pred == y_test)</div><div class="line">accuracy = float(num_correct) / num_test</div><div class="line"><span class="keyword">print</span> <span class="string">'Got %d / %d correct =&gt; accuracy: %f'</span> % (num_correct, num_test, accuracy)</div></pre></td></tr></table></figure><pre><code>Got 139 / 500 correct =&gt; accuracy: 0.278000
</code></pre><p>​</p><h1 id="k-nearest-neighbor-py"><a href="#k-nearest-neighbor-py" class="headerlink" title="k_nearest_neighbor.py"></a>k_nearest_neighbor.py</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNearestNeighbor</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">""" a kNN classifier with L2 distance """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Train the classifier. For k-nearest neighbors this is just</div><div class="line">        memorizing the training data.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: A numpy array of shape (num_train, D) containing the training data</div><div class="line">          consisting of num_train samples each of dimension D.</div><div class="line">        - y: A numpy array of shape (N,) containing the training labels, where</div><div class="line">             y[i] is the label for X[i].</div><div class="line">        """</div><div class="line">        self.X_train = X</div><div class="line">        self.y_train = y</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, k=<span class="number">1</span>, num_loops=<span class="number">0</span>)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Predict labels for test data using this classifier.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: A numpy array of shape (num_test, D) containing</div><div class="line">             test data consisting of num_test samples each of dimension D.</div><div class="line">        - k: The number of nearest neighbors that vote for</div><div class="line">             the predicted labels.</div><div class="line">        - num_loops: Determines which implementation to use</div><div class="line">                     to compute distances</div><div class="line">          between training points and testing points.</div><div class="line"></div><div class="line">        Returns:</div><div class="line">        - y: A numpy array of shape (num_test,)</div><div class="line">             containing predicted labels for the</div><div class="line">             test data, where y[i] is the predicted</div><div class="line">             label for the test point X[i].</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> num_loops == <span class="number">0</span>:</div><div class="line">            dists = self.compute_distances_no_loops(X)</div><div class="line">        <span class="keyword">elif</span> num_loops == <span class="number">1</span>:</div><div class="line">            dists = self.compute_distances_one_loop(X)</div><div class="line">        <span class="keyword">elif</span> num_loops == <span class="number">2</span>:</div><div class="line">            dists = self.compute_distances_two_loops(X)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Invalid value %d for num_loops'</span> % num_loops)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> self.predict_labels(dists, k=k)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_distances_two_loops</span><span class="params">(self, X)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Compute the distance between each test point in X and each training</div><div class="line">        point in self.X_train using a nested loop over both the training data</div><div class="line">        and the test data.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - X: A numpy array of shape (num_test, D) containing test data.</div><div class="line"></div><div class="line">        Returns:</div><div class="line">        - dists: A numpy array of shape (num_test, num_train) where dists[i, j]</div><div class="line">          is the Euclidean distance between the ith test point and the jth</div><div class="line">          training point.</div><div class="line">        """</div><div class="line">        num_test = X.shape[<span class="number">0</span>]</div><div class="line">        num_train = self.X_train.shape[<span class="number">0</span>]</div><div class="line">        dists = np.zeros((num_test, num_train))</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(num_train):</div><div class="line">                <span class="comment">###############################################################</span></div><div class="line">                <span class="comment"># <span class="doctag">TODO:</span>                                                             #</span></div><div class="line">                <span class="comment"># Compute the l2 distance between the ith test point and the jth    #</span></div><div class="line">                <span class="comment"># training point, and store the result in dists[i, j]. You should   #</span></div><div class="line">                <span class="comment"># not use a loop over dimension.                                    #</span></div><div class="line">                <span class="comment">###############################################################</span></div><div class="line">                dists[i, j] = np.sqrt(np.sum((X[i, :] - self.X_train[j, :]) ** <span class="number">2</span>))</div><div class="line">            <span class="comment">###############################################################</span></div><div class="line">            <span class="comment">#                       END OF YOUR CODE                            #</span></div><div class="line">            <span class="comment">###############################################################</span></div><div class="line">        <span class="keyword">return</span> dists</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_distances_one_loop</span><span class="params">(self, X)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Compute the distance between each test point in X and each training point</div><div class="line">        in self.X_train using a single loop over the test data.</div><div class="line"></div><div class="line">        Input / Output: Same as compute_distances_two_loops</div><div class="line">        """</div><div class="line">        num_test = X.shape[<span class="number">0</span>]</div><div class="line">        num_train = self.X_train.shape[<span class="number">0</span>]</div><div class="line">        dists = np.zeros((num_test, num_train))</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                               #</span></div><div class="line">            <span class="comment"># Compute the l2 distance between the ith test point and all training #</span></div><div class="line">            <span class="comment"># points, and store the result in dists[i, :].                        #</span></div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            dists[i, :] = np.sqrt(np.sum(np.square(X[i, :] - self.X_train), axis=<span class="number">1</span>))</div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            <span class="comment">#                         END OF YOUR CODE                            #</span></div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">        <span class="keyword">return</span> dists</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_distances_no_loops</span><span class="params">(self, X)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Compute the distance between each test point in X and each training point</div><div class="line">        in self.X_train using no explicit loops.</div><div class="line"></div><div class="line">        Input / Output: Same as compute_distances_two_loops</div><div class="line">        """</div><div class="line">        num_test = X.shape[<span class="number">0</span>]</div><div class="line">        num_train = self.X_train.shape[<span class="number">0</span>]</div><div class="line">        dists = np.zeros((num_test, num_train))</div><div class="line">        <span class="comment">#######################################################################</span></div><div class="line">        <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></div><div class="line">        <span class="comment"># Compute the l2 distance between all test points and all training      #</span></div><div class="line">        <span class="comment"># points without using any explicit loops, and store the result in      #</span></div><div class="line">        <span class="comment"># dists.                                                                #</span></div><div class="line">        <span class="comment">#                                                                       #</span></div><div class="line">        <span class="comment"># You should implement this function using only basic array operations; #</span></div><div class="line">        <span class="comment"># in particular you should not use functions from scipy.                #</span></div><div class="line">        <span class="comment">#                                                                       #</span></div><div class="line">        <span class="comment"># HINT: Try to formulate the l2 distance using matrix multiplication    #</span></div><div class="line">        <span class="comment">#       and two broadcast sums.                                         #</span></div><div class="line">        <span class="comment">#######################################################################</span></div><div class="line">        dists = np.sqrt(np.multiply(np.dot(X, self.X_train.T), <span class="number">-2</span>) +</div><div class="line">                        np.sum(self.X_train ** <span class="number">2</span>, axis=<span class="number">1</span>) +</div><div class="line">                        np.sum(X ** <span class="number">2</span>, axis=<span class="number">1</span>)[:, np.newaxis])</div><div class="line">        <span class="comment">#######################################################################</span></div><div class="line">        <span class="comment">#                         END OF YOUR CODE                              #</span></div><div class="line">        <span class="comment">#######################################################################</span></div><div class="line">        <span class="keyword">return</span> dists</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_labels</span><span class="params">(self, dists, k=<span class="number">1</span>)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Given a matrix of distances between test points and training points,</div><div class="line">        predict a label for each test point.</div><div class="line"></div><div class="line">        Inputs:</div><div class="line">        - dists: A numpy array of shape (num_test, num_train) where dists[i, j]</div><div class="line">          gives the distance betwen the ith test point and the jth training point.</div><div class="line"></div><div class="line">        Returns:</div><div class="line">        - y: A numpy array of shape (num_test,) containing predicted labels for the</div><div class="line">          test data, where y[i] is the predicted label for the test point X[i].</div><div class="line">        """</div><div class="line">        num_test = dists.shape[<span class="number">0</span>]</div><div class="line">        y_pred = np.zeros(num_test)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</div><div class="line">            <span class="comment"># A list of length k storing the labels of the k nearest neighbors to</span></div><div class="line">            <span class="comment"># the ith test point.</span></div><div class="line">            closest_y = []</div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></div><div class="line">            <span class="comment"># Use the distance matrix to find the k nearest neighbors of the ith    #</span></div><div class="line">            <span class="comment"># testing point, and use self.y_train to find the labels of these       #</span></div><div class="line">            <span class="comment"># neighbors. Store these labels in closest_y.                           #</span></div><div class="line">            <span class="comment"># Hint: Look up the function numpy.argsort.                             #</span></div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            k_nearest_index = np.argsort(dists[i, :])[:k]</div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></div><div class="line">            <span class="comment"># Now that you have found the labels of the k nearest neighbors, you    #</span></div><div class="line">            <span class="comment"># need to find the most common label in the list closest_y of labels.   #</span></div><div class="line">            <span class="comment"># Store this label in y_pred[i]. Break ties by choosing the smaller     #</span></div><div class="line">            <span class="comment"># label.                                                                #</span></div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            closest_y = self.y_train[k_nearest_index]</div><div class="line">            labels_counts = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> label <span class="keyword">in</span> closest_y:</div><div class="line">                <span class="keyword">if</span> label <span class="keyword">in</span> labels_counts.keys():</div><div class="line">                    labels_counts[label] += <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    labels_counts[label] = <span class="number">0</span></div><div class="line">            sorted_labels_counts = sorted(</div><div class="line">                labels_counts.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</div><div class="line">            y_pred[i] = sorted_labels_counts[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">            <span class="comment">###################################################################</span></div><div class="line">            <span class="comment">#                           END OF YOUR CODE                            #</span></div><div class="line">            <span class="comment">###################################################################</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> y_pred</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;k-Nearest-Neighbor-kNN-exercise&quot;&gt;&lt;a href=&quot;#k-Nearest-Neighbor-kNN-exercise&quot; class=&quot;headerlink&quot; title=&quot;k-Nearest Neighbor (kNN) exerc
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="kNN" scheme="http://yoursite.com/tags/kNN/"/>
    
  </entry>
  
  <entry>
    <title>CS231n Lecture3 note</title>
    <link href="http://yoursite.com/2017/03/02/CS231n-Lecture3-note/"/>
    <id>http://yoursite.com/2017/03/02/CS231n-Lecture3-note/</id>
    <published>2017-03-02T06:33:34.000Z</published>
    <updated>2017-03-03T11:06:37.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h1><p>Source is <a href="http://cs231n.github.io/linear-classify/" target="_blank" rel="external">here</a>.</p><h2 id="Multiclass-Support-Vector-Machine-loss"><a href="#Multiclass-Support-Vector-Machine-loss" class="headerlink" title="Multiclass Support Vector Machine loss"></a>Multiclass Support Vector Machine loss</h2><p>The SVM loss is set up so that the SVM “wants” the correct class for each image to a have a score higher than the incorrect classes by some fixed margin $\Delta$</p><p>The Multiclass SVM loss for the i-th example is formalized as follows:</p><p><strong>Example</strong></p><p>$s = [13, -7, 11]$ and $\Delta = 10$, then,</p><script type="math/tex;mode=display">L_i = \max(0, -7 - 13 + 10) + \max(0, 11 - 13 + 10)</script><p>In summary, the SVM loss function wants the score of the correct class $y_i$ to be larger than the incorrect class scores by at least by $\Delta$ (delta). If this is not the case, we will accumulate loss.</p><p>Note that $f(x_i; W) = W x_i$, so we can also rewrite the loss function in this equivalent form:</p><script type="math/tex;mode=display">L_i = \sum_{j\neq y_i} \max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)</script><p>A last piece of terminology we’ll mention before we finish with this section is that the threshold at zero $\max(0,−)$ function is often called the <strong>hinge loss</strong>. You’ll sometimes hear about people instead using the squared hinge loss SVM (or L2-SVM), which uses the form $\max(0,−)^2$ that penalizes violated margins more strongly (quadratically instead of linearly). The unsquared version is more standard, but in some datasets the squared hinge loss can work better. This can be determined during cross-validation.</p><p>The follow image shows the motivation of the SVM loss function”</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/03/margin.jpg" alt="margin"></p><h3 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h3><p>There is one bug with the loss function we presented above. Suppose that we have a dataset and a set of parameters <strong>W</strong> that correctly classify every example (i.e. all scores are so that all the margins are met, and $L_i=0$ for all i). The issue is that this set of <strong>W</strong> is not necessarily unique: there might be many similar <strong>W</strong> that correctly classify the examples. One easy way to see this is that if some parameters <strong>W</strong> correctly classify all examples (so loss is zero for each example), then any multiple of these parameters $\lambda W$ where $\lambda &gt; 1$ will also give zero loss because this transformation uniformly stretches all score magnitudes and hence also their absolute differences. For example, if the difference in scores between a correct class and a nearest incorrect class was 15, then multiplying all elements of <strong>W</strong> by 2 would make the new difference 30.</p><p>We can avoid this by extending the loss function with a <strong>regularization penalty</strong> $R(W)$. The most common regularization penalty is the <strong>L2</strong> norm:</p><script type="math/tex;mode=display">R(W) = \sum_k\sum_l W_{k,l}^2</script><p>That is, the full Multiclass SVM loss becomes:</p><script type="math/tex;mode=display">L =  \underbrace{ \frac{1}{N} \sum_i L_i }_\text{data loss} + \underbrace{ \lambda R(W) }_\text{regularization loss} \\\\</script><p>Or expanding this out in its full form:</p><script type="math/tex;mode=display">L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + \Delta) \right] + \lambda \sum_k\sum_l W_{k,l}^2</script><p>Including the L2 penalty leads to the appealing <strong>max margin</strong> property in SVMs (See <a href="http://cs229.stanford.edu/notes/cs229-notes3.pdf" target="_blank" rel="external">CS229</a> lecture notes for full details if you are interested).</p><p>The most appealing property is that penalizing large weights tends to improve generalization, because it means that no input dimension can have a very large influence on the scores all by itself. For example, suppose that we have some input vector $x=[1,1,1,1]$ and two weight vectors $w_1=[1,0,0,0]$, $w_2=[0.25,0.25,0.25,0.25]$. Then $w^T_1x=w^T_2x=1$ so both weight vectors lead to the same dot product, but the <strong>L2</strong> penalty of $w_1$ is 1.0 while the <strong>L2</strong> penalty of $w_2$ is only 0.25. Therefore, according to the <strong>L2</strong> penalty the weight vector $w_2$ would be preferred since it achieves a lower regularization loss. Intuitively, this is because the weights in $w_2$ are smaller and more diffuse. Since the <strong>L2</strong> penalty prefers smaller and more diffuse weight vectors, the final classifier is encouraged to take into account all input dimensions to small amounts rather than a few input dimensions and very strongly. As we will see later in the class, this effect can improve the generalization performance of the classifiers on test images and lead to less <em>overfitting</em>.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i</span><span class="params">(x, y, W)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">  unvectorized version. Compute the multiclass svm loss for a single example (x,y)</div><div class="line">  - x is a column vector representing an image (e.g. 3073 x 1 in CIFAR-10)</div><div class="line">    with an appended bias dimension in the 3073-rd position (i.e. bias trick)</div><div class="line">  - y is an integer giving index of correct class (e.g. between 0 and 9 in CIFAR-10)</div><div class="line">  - W is the weight matrix (e.g. 10 x 3073 in CIFAR-10)</div><div class="line">  """</div><div class="line">  delta = <span class="number">1.0</span> <span class="comment"># see notes about delta later in this section</span></div><div class="line">  scores = W.dot(x) <span class="comment"># scores becomes of size 10 x 1, the scores for each class</span></div><div class="line">  correct_class_score = scores[y]</div><div class="line">  D = W.shape[<span class="number">0</span>] <span class="comment"># number of classes, e.g. 10</span></div><div class="line">  loss_i = <span class="number">0.0</span></div><div class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> xrange(D): <span class="comment"># iterate over all wrong classes</span></div><div class="line">    <span class="keyword">if</span> j == y:</div><div class="line">      <span class="comment"># skip for the true class to only loop over incorrect classes</span></div><div class="line">      <span class="keyword">continue</span></div><div class="line">    <span class="comment"># accumulate loss for the i-th example</span></div><div class="line">    loss_i += max(<span class="number">0</span>, scores[j] - correct_class_score + delta)</div><div class="line">  <span class="keyword">return</span> loss_i</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i_vectorized</span><span class="params">(x, y, W)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">  A faster half-vectorized implementation. half-vectorized</div><div class="line">  refers to the fact that for a single example the implementation contains</div><div class="line">  no for loops, but there is still one loop over the examples (outside this function)</div><div class="line">  """</div><div class="line">  delta = <span class="number">1.0</span></div><div class="line">  scores = W.dot(x)</div><div class="line">  <span class="comment"># compute the margins for all classes in one vector operation</span></div><div class="line">  margins = np.maximum(<span class="number">0</span>, scores - scores[y] + delta)</div><div class="line">  <span class="comment"># on y-th position scores[y] - scores[y] canceled and gave delta. We want</span></div><div class="line">  <span class="comment"># to ignore the y-th position and only consider margin on max wrong class</span></div><div class="line">  margins[y] = <span class="number">0</span></div><div class="line">  loss_i = np.sum(margins)</div><div class="line">  <span class="keyword">return</span> loss_i</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">L</span><span class="params">(X, y, W)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">  fully-vectorized implementation :</div><div class="line">  - X holds all the training examples as columns (e.g. 3073 x 50,000 in CIFAR-10)</div><div class="line">  - y is array of integers specifying correct class (e.g. 50,000-D array)</div><div class="line">  - W are weights (e.g. 10 x 3073)</div><div class="line">  """</div><div class="line">  <span class="comment"># evaluate loss over all examples in X without using any for loops</span></div><div class="line">  <span class="comment"># left as exercise to reader in the assignment</span></div></pre></td></tr></table></figure><h3 id="Practice-Considerations"><a href="#Practice-Considerations" class="headerlink" title="Practice Considerations"></a>Practice Considerations</h3><h4 id="Setting-Delta"><a href="#Setting-Delta" class="headerlink" title="Setting Delta"></a>Setting Delta</h4><p>Note that we brushed over the hyperparameter $\Delta$ and its setting. What value should it be set to, and do we have to cross-validate it? It turns out that this hyperparameter can safely be set to $\Delta = 1.0$ in all cases. The hyperparameters $\Delta$ and $\lambda$ seem like two different hyperparameters, but in fact they both control the same tradeoff: The tradeoff between the data loss and the regularization loss in the objective. The key to understanding this is that the magnitude of the weights <strong>W</strong> has direct effect on the scores (and hence also their differences): As we shrink all values inside <strong>W</strong> the score differences will become lower, and as we scale up the weights the score differences will all become higher. Therefore, the exact value of the margin between the scores (e.g. $\Delta = 10$, or$\Delta = 100$) is in some sense meaningless because the weights can shrink or stretch the differences arbitrarily. Hence, the only real tradeoff is how large we allow the weights to grow (through the regularization strength $\lambda$).</p><h2 id="Softmax-classifier"><a href="#Softmax-classifier" class="headerlink" title="Softmax classifier"></a>Softmax classifier</h2><p>In the Softmax classifier, the function mapping $f(x_i; W) = W x_i$ stays unchanged, but we now interpret these scores as the unnormalized log probabilities for each class and replace the <em>hinge loss</em> with a <strong>cross-entropy loss</strong> that has the form:</p><script type="math/tex;mode=display">L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right) \hspace{0.5in} \text{or equivalently} \hspace{0.5in} L_i = -f_{y_i} + \log\sum_j e^{f_j}</script><p>The function $f_j(z) = \frac{e^{z_j}}{\sum_k e^{z_k}}$ is called the <strong>softmax function</strong>.</p><h3 id="Information-theory-view"><a href="#Information-theory-view" class="headerlink" title="Information theory view"></a>Information theory view</h3><p>The <em>cross-entropy</em> between a “true” distribution $p$ and an estimated distribution $q$ is defined as:</p><script type="math/tex;mode=display">H(p,q) = - \sum_x p(x) \log q(x)</script><p>The Softmax classifier is hence minimizing the cross-entropy between the estimated class probabilities ( $q = e^{f_{y_i}} / \sum_j e^{f_j}$ as seen above) and the “true” distribution, which in this interpretation is the distribution where all probability mass is on the correct class (i.e. $p = [0, \ldots 1, \ldots, 0]$ contains a single 1 at the $y_i$ -th position.).</p><p>Moreover, since the cross-entropy can be written in terms of entropy and the Kullback-Leibler divergence as $H(p,q) = H(p) + D_{KL}(p||q)$, and the entropy of the delta function $p$ is zero, this is also equivalent to minimizing the <strong>KL</strong> divergence between the two distributions (a measure of distance). In other words, the cross-entropy objective <em>wants</em> the predicted distribution to have all of its mass on the correct answer.</p><h3 id="Probabilistic-interpretation"><a href="#Probabilistic-interpretation" class="headerlink" title="Probabilistic interpretation"></a>Probabilistic interpretation</h3><script type="math/tex;mode=display">P(y_i \mid x_i; W) = \frac{e^{f_{y_i}}}{\sum_j e^{f_j} }</script><p>can be interpreted as the (normalized) probability assigned to the correct label $y_i$given the image $x_i$ and parameterized by <strong>W</strong>. To see this, remember that the Softmax classifier interprets the scores inside the output vector $f$ as the unnormalized log probabilities. Exponentiating these quantities therefore gives the (unnormalized) probabilities, and the division performs the normalization so that the probabilities sum to one. In the probabilistic interpretation, we are therefore minimizing the negative log likelihood of the correct class, which can be interpreted as performing <em>Maximum Likelihood Estimation</em> (MLE). A nice feature of this view is that we can now also interpret the regularization term $R(W)$ in the full loss function as coming from a Gaussian prior over the weight matrix <strong>W</strong>, where instead of MLE we are performing the <em>Maximum a posteriori</em> (MAP) estimation.</p><h3 id="Numeric-stability"><a href="#Numeric-stability" class="headerlink" title="Numeric stability"></a>Numeric stability</h3><p>When you’re writing code for computing the Softmax function in practice, the intermediate term $e^{f_{y_i}}$ and $\sum_j e^{f_j}$ may be very large due to the exponentials. Dividing large numbers can be numerically unstable, so it is important to use a normalization trick. Notice that if we multiply the top and bottom of the fraction by a constant <strong>C</strong> and push it into the sum, we get the following (mathematically equivalent) expression:</p><script type="math/tex;mode=display">\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}}= \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}</script><p>We are free to choose the value of <strong>C</strong>. This will not change any of the results, but we can use this value to improve the numerical stability of the computation. A common choice for <strong>C</strong> is to set $\log C = -\max_j f_j$. This simply states that we should shift the values inside the vector ff so that the highest value is zero. In code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) <span class="comment"># example with 3 classes and each having large scores</span></div><div class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># Bad: Numeric problem, potential blowup</span></div><div class="line"></div><div class="line"><span class="comment"># instead: first shift the values of f so that the highest number is 0:</span></div><div class="line">f -= np.max(f) <span class="comment"># f becomes [-666, -333, 0]</span></div><div class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># safe to do, gives the correct answer</span></div></pre></td></tr></table></figure><h3 id="Some-tricks"><a href="#Some-tricks" class="headerlink" title="Some tricks"></a>Some tricks</h3><p>How peaky or diffuse these probabilities are depends directly on the regularization strength $\lambda$ - which you are in charge of as input to the system. For example, suppose that the unnormalized log-probabilities for some three classes come out to be [1, -2, 0]. The softmax function would then compute:</p><script type="math/tex;mode=display">[1, -2, 0] \rightarrow [e^1, e^{-2}, e^0] = [2.71, 0.14, 1] \rightarrow [0.7, 0.04, 0.26]</script><p>Where the steps taken are to exponentiate and normalize to sum to one. Now, if the regularization strength $\lambda$ was higher, the weights <strong>W</strong> would be penalized more and this would lead to smaller weights. For example, suppose that the weights became one half smaller ([0.5, -1, 0]). The softmax would now compute:</p><script type="math/tex;mode=display">[0.5, -1, 0] \rightarrow [e^{0.5}, e^{-1}, e^0] = [1.65, 0.37, 1] \rightarrow [0.55, 0.12, 0.33]</script><p>where the probabilites are now more diffuse.</p><h3 id="Futher-Reading"><a href="#Futher-Reading" class="headerlink" title="Futher Reading"></a>Futher Reading</h3><ul><li><a href="http://arxiv.org/abs/1306.0239" target="_blank" rel="external">Deep Learning using Linear Support Vector Machines</a> from Charlie Tang 2013 presents some results claiming that the L2SVM outperforms Softmax.</li></ul><h1 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h1><h2 id="Strategy-1-A-first-very-bad-idea-solution-Random-search"><a href="#Strategy-1-A-first-very-bad-idea-solution-Random-search" class="headerlink" title="Strategy #1: A first very bad idea solution: Random search"></a>Strategy #1: A first very bad idea solution: Random search</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># assume X_train is the data where each column is an example (e.g. 3073 x 50,000)</span></div><div class="line"><span class="comment"># assume Y_train are the labels (e.g. 1D array of 50,000)</span></div><div class="line"><span class="comment"># assume the function L evaluates the loss function</span></div><div class="line"></div><div class="line">bestloss = float(<span class="string">"inf"</span>) <span class="comment"># Python assigns the highest possible float value</span></div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> xrange(<span class="number">1000</span>):</div><div class="line">  W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.0001</span> <span class="comment"># generate random parameters</span></div><div class="line">  loss = L(X_train, Y_train, W) <span class="comment"># get the loss over the entire training set</span></div><div class="line">  <span class="keyword">if</span> loss &lt; bestloss: <span class="comment"># keep track of the best solution</span></div><div class="line">    bestloss = loss</div><div class="line">    bestW = W</div><div class="line">  <span class="keyword">print</span> <span class="string">'in attempt %d the loss was %f, best %f'</span> % (num, loss, bestloss)</div><div class="line"></div><div class="line"><span class="comment"># prints:</span></div><div class="line"><span class="comment"># in attempt 0 the loss was 9.401632, best 9.401632</span></div><div class="line"><span class="comment"># in attempt 1 the loss was 8.959668, best 8.959668</span></div><div class="line"><span class="comment"># in attempt 2 the loss was 9.044034, best 8.959668</span></div><div class="line"><span class="comment"># in attempt 3 the loss was 9.278948, best 8.959668</span></div><div class="line"><span class="comment"># in attempt 4 the loss was 8.857370, best 8.857370</span></div><div class="line"><span class="comment"># in attempt 5 the loss was 8.943151, best 8.857370</span></div><div class="line"><span class="comment"># in attempt 6 the loss was 8.605604, best 8.605604</span></div><div class="line"><span class="comment"># ... (trunctated: continues for 1000 lines)</span></div></pre></td></tr></table></figure><p>We can take the best weights <strong>W</strong> found by this search and try it out on the test set:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Assume X_test is [3073 x 10000], Y_test [10000 x 1]</span></div><div class="line">scores = Wbest.dot(Xte_cols) <span class="comment"># 10 x 10000, the class scores for all test examples</span></div><div class="line"><span class="comment"># find the index with max score in each column (the predicted class)</span></div><div class="line">Yte_predict = np.argmax(scores, axis = <span class="number">0</span>)</div><div class="line"><span class="comment"># and calculate accuracy (fraction of predictions that are correct)</span></div><div class="line">np.mean(Yte_predict == Yte)</div><div class="line"><span class="comment"># returns 0.1555</span></div></pre></td></tr></table></figure><p>With the best <strong>W</strong> this gives an accuracy of about <strong>15.5%</strong>.</p><p><strong>Core idea: iterative refinement</strong>. Of course, it turns out that we can do much better. The core idea is that finding the best set of weights <strong>W</strong> is a very difficult or even impossible problem (especially once <strong>W</strong> contains weights for entire complex neural networks), but the problem of refining a specific set of weights <strong>W</strong> to be slightly better is significantly less difficult. In other words, our approach will be to start with a random <strong>W</strong> and then iteratively refine it, making it slightly better each time.</p><blockquote><p>Our strategy will be to start with random weights and iteratively refine them over time to get lower loss</p></blockquote><h2 id="Strategy-2-Random-Local-Search"><a href="#Strategy-2-Random-Local-Search" class="headerlink" title="Strategy #2: Random Local Search"></a>Strategy #2: Random Local Search</h2><p>Concretely, we will start out with a random WW, generate random perturbations $\delta W$ to it and if the loss at the perturbed $W + \delta W$ is lower, we will perform an update. The code for this procedure is as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># generate random starting W</span></div><div class="line">bestloss = float(<span class="string">"inf"</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</div><div class="line">  step_size = <span class="number">0.0001</span></div><div class="line">  Wtry = W + np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * step_size</div><div class="line">  loss = L(Xtr_cols, Ytr, Wtry)</div><div class="line">  <span class="keyword">if</span> loss &lt; bestloss:</div><div class="line">    W = Wtry</div><div class="line">    bestloss = loss</div><div class="line">  <span class="keyword">print</span> <span class="string">'iter %d loss is %f'</span> % (i, bestloss)</div></pre></td></tr></table></figure><p>This approach achieves test set classification accuracy of <strong>21.4%</strong>.</p><h2 id="Strategy-3-Following-the-Gradient"><a href="#Strategy-3-Following-the-Gradient" class="headerlink" title="Strategy #3: Following the Gradient"></a>Strategy #3: Following the Gradient</h2><p>The mathematical expression for the derivative of a 1-D function with respect its input is:</p><script type="math/tex;mode=display">\frac{df(x)}{dx} = \lim_{h\ \to 0} \frac{f(x + h) - f(x)}{h}</script><p>When the functions of interest take a vector of numbers instead of a single number, we call the derivatives <strong>partial derivatives</strong>, and the gradient is simply the vector of partial derivatives in each dimension.</p><h3 id="Computing-the-gradient"><a href="#Computing-the-gradient" class="headerlink" title="Computing the gradient"></a>Computing the gradient</h3><p>There are two ways to compute the gradient: A slow, approximate but easy way (<strong>numerical gradient</strong>), and a fast, exact but more error-prone way that requires calculus (<strong>analytic gradient</strong>). We will now present both.</p><h4 id="Computing-the-gradient-numerically-with-finite-differences"><a href="#Computing-the-gradient-numerically-with-finite-differences" class="headerlink" title="Computing the gradient numerically with finite differences"></a>Computing the gradient numerically with finite differences</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_numerical_gradient</span><span class="params">(f, x)</span>:</span></div><div class="line">  <span class="string">""" </span></div><div class="line">  a naive implementation of numerical gradient of f at x </div><div class="line">  - f should be a function that takes a single argument</div><div class="line">  - x is the point (numpy array) to evaluate the gradient at</div><div class="line">  """ </div><div class="line"></div><div class="line">  fx = f(x) <span class="comment"># evaluate function value at original point</span></div><div class="line">  grad = np.zeros(x.shape)</div><div class="line">  h = <span class="number">0.00001</span></div><div class="line"></div><div class="line">  <span class="comment"># iterate over all indexes in x</span></div><div class="line">  it = np.nditer(x, flags=[<span class="string">'multi_index'</span>], op_flags=[<span class="string">'readwrite'</span>])</div><div class="line">  <span class="keyword">while</span> <span class="keyword">not</span> it.finished:</div><div class="line"></div><div class="line">    <span class="comment"># evaluate function at x+h</span></div><div class="line">    ix = it.multi_index</div><div class="line">    old_value = x[ix]</div><div class="line">    x[ix] = old_value + h <span class="comment"># increment by h</span></div><div class="line">    fxh = f(x) <span class="comment"># evalute f(x + h)</span></div><div class="line">    x[ix] = old_value <span class="comment"># restore to previous value (very important!)</span></div><div class="line"></div><div class="line">    <span class="comment"># compute the partial derivative</span></div><div class="line">    grad[ix] = (fxh - fx) / h <span class="comment"># the slope</span></div><div class="line">    it.iternext() <span class="comment"># step to next dimension</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> grad</div></pre></td></tr></table></figure><p><strong>Practical considerations</strong>.</p><p>Note that in the mathematical formulation the gradient is defined in the limit as <strong>h</strong> goes towards zero, but in practice it is often sufficient to use a very small value (such as 1e-5 as seen in the example). Ideally, you want to use the smallest step size that does not lead to numerical issues. Additionally, in practice it often works better to compute the numeric gradient using the <strong>centered difference formula</strong>:</p><script type="math/tex;mode=display">[f(x+h) - f(x-h)] / 2 h</script><p>See <a href="http://en.wikipedia.org/wiki/Numerical_differentiation" target="_blank" rel="external">wiki</a> for details.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># to use the generic code above we want a function that takes a single argument</span></div><div class="line"><span class="comment"># (the weights in our case) so we close over X_train and Y_train</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">CIFAR10_loss_fun</span><span class="params">(W)</span>:</span></div><div class="line">  <span class="keyword">return</span> L(X_train, Y_train, W)</div><div class="line"></div><div class="line">W = np.random.rand(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># random weight vector</span></div><div class="line">df = eval_numerical_gradient(CIFAR10_loss_fun, W) <span class="comment"># get the gradient</span></div></pre></td></tr></table></figure><p>Then we can use to make an update:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">loss_original = CIFAR10_loss_fun(W) <span class="comment"># the original loss</span></div><div class="line"><span class="keyword">print</span> <span class="string">'original loss: %f'</span> % (loss_original, )</div><div class="line"></div><div class="line"><span class="comment"># lets see the effect of multiple step sizes</span></div><div class="line"><span class="keyword">for</span> step_size_log <span class="keyword">in</span> [<span class="number">-10</span>, <span class="number">-9</span>, <span class="number">-8</span>, <span class="number">-7</span>, <span class="number">-6</span>, <span class="number">-5</span>,<span class="number">-4</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>]:</div><div class="line">  step_size = <span class="number">10</span> ** step_size_log</div><div class="line">  W_new = W - step_size * df <span class="comment"># new position in the weight space</span></div><div class="line">  loss_new = CIFAR10_loss_fun(W_new)</div><div class="line">  <span class="keyword">print</span> <span class="string">'for step size %f new loss: %f'</span> % (step_size, loss_new)</div><div class="line"></div><div class="line"><span class="comment"># prints:</span></div><div class="line"><span class="comment"># original loss: 2.200718</span></div><div class="line"><span class="comment"># for step size 1.000000e-10 new loss: 2.200652</span></div><div class="line"><span class="comment"># for step size 1.000000e-09 new loss: 2.200057</span></div><div class="line"><span class="comment"># for step size 1.000000e-08 new loss: 2.194116</span></div><div class="line"><span class="comment"># for step size 1.000000e-07 new loss: 2.135493</span></div><div class="line"><span class="comment"># for step size 1.000000e-06 new loss: 1.647802</span></div><div class="line"><span class="comment"># for step size 1.000000e-05 new loss: 2.844355</span></div><div class="line"><span class="comment"># for step size 1.000000e-04 new loss: 25.558142</span></div><div class="line"><span class="comment"># for step size 1.000000e-03 new loss: 254.086573</span></div><div class="line"><span class="comment"># for step size 1.000000e-02 new loss: 2539.370888</span></div><div class="line"><span class="comment"># for step size 1.000000e-01 new loss: 25392.214036</span></div></pre></td></tr></table></figure><p><strong>Effect of step size</strong></p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/cs231n/03/stepsize.jpg" alt="margin"></p><h4 id="Computing-the-gradient-analytically-with-Calculus"><a href="#Computing-the-gradient-analytically-with-Calculus" class="headerlink" title="Computing the gradient analytically with Calculus"></a>Computing the gradient analytically with Calculus</h4><p>However, unlike the numerical gradient it can be more error prone to implement, which is why in practice it is very common to compute the analytic gradient and compare it to the numerical gradient to check the correctness of your implementation. This is called a <strong>gradient check</strong>.</p><p>Lets use the example of the SVM loss function for a single datapoint:</p><script type="math/tex;mode=display">L_i = \sum_{j\neq y_i} \left[ \max(0, w_j^Tx_i - w_{y_i}^Tx_i + \Delta) \right]</script><script type="math/tex;mode=display">\nabla_{w_{y_i}} L_i = - \left( \sum_{j\neq y_i} \mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \Delta > 0) \right) x_i</script><p>when you’re implementing this in code you’d simply count the number of classes that didn’t meet the desired margin (and hence contributed to the loss function) and then the data vector $x_i$ scaled by this number is the gradient.</p><script type="math/tex;mode=display">\nabla_{w_j} L_i = \mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \Delta > 0) x_i</script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Loss-function&quot;&gt;&lt;a href=&quot;#Loss-function&quot; class=&quot;headerlink&quot; title=&quot;Loss function&quot;&gt;&lt;/a&gt;Loss function&lt;/h1&gt;&lt;p&gt;Source is &lt;a href=&quot;http://
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
</feed>
