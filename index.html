<!doctype html><html class="theme-next mist use-motion" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/atom.xml" title="Abracadabra" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="Ewan&apos;s IT Blog"><meta property="og:type" content="website"><meta property="og:title" content="Abracadabra"><meta property="og:url" content="http://yoursite.com/index.html"><meta property="og:site_name" content="Abracadabra"><meta property="og:description" content="Ewan&apos;s IT Blog"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Abracadabra"><meta name="twitter:description" content="Ewan&apos;s IT Blog"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/"><title>Abracadabra</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?dc405a79ad500922134d14cdf288f646";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Abracadabra</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Do it yourself</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div><span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/策略梯度方法/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/04/14/策略梯度方法/" itemprop="url">策略梯度方法</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-14T13:59:17+08:00">2019-04-14 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/04/14/策略梯度方法/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/04/14/策略梯度方法/" itemprop="commentsCount"></span> </a></span><span id="/2019/04/14/策略梯度方法/" class="leancloud_visitors" data-flag-title="策略梯度方法"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><hr><p><strong>译者注：</strong></p><p><strong>本篇文章翻译自 <a href="https://lilianweng.github.io/lil-log/contact.html" target="_blank" rel="external">Dr. Weng</a> 的<a href="https://lilianweng.github.io/lil-log/2018/04/08/policy-gradient-algorithms.html#sac-with-automatically-adjusted-temperature" target="_blank" rel="external">博客</a>。</strong></p><p><strong>翻译行为已得到原作者授权，转载请注明原作者。</strong></p><hr><blockquote><p>摘要：在本文中，我们将深入探讨策略梯度算法的工作原理以及近年来提出的一些新的策略梯度算法：平凡策略梯度、演员评论家算法、离线策略演员评论家算法、A3C、A2C、DPG、DDPG、D4PG、MADDPG、TRPO、PPO、ACER、ACKTR、SAC以及TD3算法。</p></blockquote><h2 id="什么是策略梯度"><a href="#什么是策略梯度" class="headerlink" title="什么是策略梯度"></a>什么是策略梯度</h2><p>策略梯度算法是一类解决强化学习问题的方法。如果你对于强化学习领域还不熟悉，请首先阅读<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#key-concepts" target="_blank" rel="external">这篇博客</a>来对强化学习的问题定义以及核心概念进行初步了解。</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>下面是一个符号列表，可以帮助您更轻松地理解本文中的公式。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>$s \in \mathcal{S}$</td><td>状态。</td></tr><tr><td>$a \in \mathcal{A}$</td><td>动作。</td></tr><tr><td>$r \in \mathcal{R}$</td><td>回报。</td></tr><tr><td>$S_{t}, A_{t}, R_{t}$</td><td>一个轨迹中第$t$个时间步对应的状态、动作以及回报。我可能会偶尔使用$s_{t}, a_{t}, r_{t}$来代替。</td></tr><tr><td>$\gamma$</td><td>折扣因子；用于惩罚未来回报中的不确定性；$0&lt;\gamma \leq 1$。</td></tr><tr><td>$G_{t}$</td><td>累积回报；或者说累积折扣回报；$G_{t}=\sum_{k=0}^{\infty} \gamma^{k} R_{t+k+1}$。</td></tr><tr><td>$P\left(s^{\prime}, r\vert s, a\right)$</td><td>在当前状态$s$下采取动作$a$后转移到下一个状态$s^{\prime}$并得到回报$r$的概率。</td></tr><tr><td>$\pi(a\vert s)$</td><td>随机策略（智能体行为逻辑）；$\pi_{\theta}( .)$代表由$\theta$参数化的策略。</td></tr><tr><td>$\mu(s)$</td><td>确定性策略；虽然也可以把确定性策略记为$\pi(s)$，但是采用一个不同的字母可以让我们更容易分辨一个策略到底是确定性的还是随机的。$\pi$或者$\mu$都是强化学习算法要学习的目标。</td></tr><tr><td>$V(s)$</td><td>状态-值函数衡量状态$s$的期望累积回报；$V_{w}( .)$代表由$w$参数化的状态-值函数。</td></tr><tr><td>$V^{\pi}(s)$</td><td>当智能体遵循策略$\pi$时状态$s$的期望累积回报；$V^{\pi}(s)=\mathbb{E}_{a \sim \pi}\left[G_{t}\vert S_{t}=s\right]$。</td></tr><tr><td>$Q(s, a)$</td><td>动作-值函数，与状态-值函数类似，但是它衡量在状态$s$下采取动作$a$后的期望累积回报；$Q_{w}( .)$代表由$w$参数化的动作-值函数。</td></tr><tr><td>$Q^{\pi}(s, a)$</td><td>与$V^{\pi}(s)$类似，当智能体遵循策略$\pi$时，在状态$s$下采取动作$a$后的期望累积回报；$Q^{\pi}(s, a)=\mathbb{E}_{a \sim \pi}\left[G_{t}\vert S_{t}=s,A_{t}=a\right]$。</td></tr><tr><td>$A(s, a)$</td><td>优势函数，$A(s, a)=Q(s, a)-V(s)$；可以认为优势函数是加强版本的动作-值函数，但是由于它采用状态-值函数作为基准使得它具有更小的方差。</td></tr></tbody></table><h3 id="策略梯度"><a href="#策略梯度" class="headerlink" title="策略梯度"></a>策略梯度</h3><p>强化学习的目标是为智能体找到一个最优的行为策略从而获取最大的回报。<strong>策略梯度</strong>方法主要特点在于直接对策略进行建模并优化。策略通常被建模为由$\theta$参数化的函数$\pi_{\theta}(a | s)$。回报（目标）函数的值受到该策略的直接影响，因而可以采用很多算法来对$\theta$进行优化来最大化回报（目标）函数。</p><p>回报（目标）函数定义如下：<br>$$<br>J(\theta)=\sum_{s \in \mathcal{S}} d^{\pi}(s) V^{\pi}(s)=\sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} \pi_{\theta}(a | s) Q^{\pi}(s, a)<br>$$<br>其中$d^{\pi}(s)$代表由$\pi_{\theta}$引出的马尔科夫链的平稳分布（$\pi$下的在线策略状态分布）。</p><hr><p><strong>译者注</strong>：上述目标函数是在连续环境（没有固定的终止状态）下的目标函数（被称为<strong>平均值</strong>），在连续环境下还有一种性质更好的目标函数，叫做<strong>平均回报</strong>：<br>$$<br>\begin{aligned} J(\theta) \doteq r(\pi) &amp; \doteq \lim _{h \rightarrow \infty} \frac{1}{h} \sum_{t=1}^{h} \mathbb{E}\left[R_{t} | S_{0}, A_{0 : t-1} \sim \pi\right] \\ &amp;=\lim _{t \rightarrow \infty} \mathbb{E}\left[R_{t} | S_{0}, A_{0 : t-1} \sim \pi\right] \\ &amp;=\sum_{s} \mu(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}, r} p\left(s^{\prime}, r | s, a\right) r \end{aligned}<br>$$<br>在这种定义下，<strong>（差分）累积回报定义为回报与平均回报的差值的累加值</strong>：<br>$$<br>G_{t} \doteq R_{t+1}-r(\pi)+R_{t+2}-r(\pi)+R_{t+3}-r(\pi)+\cdots<br>$$<br>对应的还有差分状态-值函数以及差分-动作值函数：<br>$$<br>\begin{array}{l}<br>{V_{\pi}(s)=\sum_{a} \pi_{\theta}(a | s) \sum_{r, s^{\prime}} p\left(s^{\prime}, r | s, a\right)\left[r-r(\pi)+V_{\pi}\left(s^{\prime}\right)\right]} \\ {Q_{\pi}(s, a)=\sum_{r, s^{\prime}} p\left(s^{\prime}, r | s, a\right)\left[r-r(\pi)+\sum_{a^{\prime}} \pi_{\theta}\left(a^{\prime} | s^{\prime}\right) Q_{\pi}\left(s^{\prime}, a^{\prime}\right)\right]}\end{array}<br>$$<br>之所以说上述目标函数性质更好，是因为平均值目标函数其实只是它的另外一种形式，下面我们就来证明一下（<a href="http://incompleteideas.net/book/bookdraft2017nov5.pdf" target="_blank" rel="external">Sutton&amp;Barto,2017</a>; Sec 10.4）：<br>$$<br>\begin{aligned}<br>J(\theta)=&amp;\sum_{s \in \mathcal{S}} d^{\pi}(s) V^{\pi}(s) \\<br>=&amp; \sum_{s} d_{\pi}(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right)\left[r+\gamma V_{\pi}\left(s^{\prime}\right)\right] \\<br>=&amp;\;r(\pi) + \sum_{s} d_{\pi}(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right)\gamma V_{\pi}\left(s^{\prime}\right) \\<br>=&amp;\;r(\pi) + \gamma \sum_{s^{\prime}} V_{\pi}\left(s^{\prime}\right) \sum_{s} d_{\pi}(s) \sum_{a} \pi_{\theta}(a | s) p\left(s^{\prime} | s, a\right) \\<br>=&amp;\;r(\pi) + \gamma\sum_{s^{\prime}}V_{\pi}(s^{\prime})d_{\pi}(s^{\prime}) \\<br>=&amp;\;r(\pi) + \gamma J(\theta) \\<br>=&amp;\;r(\pi) + \gamma r(\pi) + \gamma^{2}J(\theta) \\<br>=&amp;\;r(\pi) + \gamma r(\pi) + \gamma^{2}r(\pi) + \gamma^{3}J(\theta) + \cdots \\<br>=&amp;\;\frac{1}{1-\gamma}r(\pi)<br>\end{aligned}<br>$$<br><strong>因而在下面进行策略梯度定理证明时，我们仅考虑平均回报形式的目标函数。</strong></p><p>另一方面，在周期环境下的目标函数（<strong>不包含折扣因子</strong>）如下：<br>$$<br>J(\theta)=V^{\pi}(s_{0})<br>$$<br>之所以不在连续环境下也使用上述目标函数，是因为在连续环境下上述目标函数的值为无穷大，优化一个无穷大值是没有意义的。</p><hr><p>为了简化符号，当策略作为其他函数的上标或者下标出现时$\pi_{\theta}$中的参数$\theta$将省略，例如：$d^{\pi}$以及$Q^{\pi}$的完整形式为$d^{\pi_{\theta}}$以及$Q^{\pi_{\theta}}$。想象一下你一直在马尔科夫链构成的状态序列中游荡，随着时间不断向前推进，你经过某个状态的概率将保持不变——这个概率就是$\pi_{\theta}$下的平稳概率。$d^{\pi}(s)=\lim _{t \rightarrow \infty} P\left(s_{t}=s | s_{0}, \pi_{\theta}\right)$就表示你从状态$s_0$开始，在策略$\pi_{\theta}$下经过$t$个时间步后到达状态$s$的概率。实际上，PageRank正是利用了马尔科夫链的平稳分布。你可以阅读<a href="https://jeremykun.com/2015/04/06/markov-chain-monte-carlo-without-all-the-bullshit/" target="_blank" rel="external">这篇文章</a>以获取更多细节。</p><p>我们可以很自然的预见到基于策略的方法能够很好地处理连续空间中的强化学习问题。因为在连续空间中存在无限多的动作及（或）状态因而基于值函数的算法由于需要去估计所有的动作及（或）状态的值导致其所需的算力变得无法接受。例如，在<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#policy-iteration" target="_blank" rel="external">一般的策略迭代</a>过程中，策略提升步骤$\arg \max _{a \in \mathcal{A}} Q^{\pi}(s, a)$需要去遍历整个动作空间，因而会遭受<a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_blank" rel="external">维度诅咒</a>。</p><p>使用<em>梯度上升</em>方法，我们可以将参数$\theta$往梯度$\nabla_{\theta} J(\theta)$给出的方向进行改变从而去找到最优的$\theta$使得其对应的策略$\pi_{\theta}$能够给智能体带来最大的期望累积回报。</p><h3 id="策略梯度定理"><a href="#策略梯度定理" class="headerlink" title="策略梯度定理"></a>策略梯度定理</h3><p>计算梯度$\nabla_{\theta} J(\theta)$可不是一件简单的事情。因为梯度值不仅依赖于动作的选择（由$\pi_{\theta}$直接决定），还依赖于由选择的动作而产生的状态的平稳分布（由$\pi_{\theta}$间接决定）。鉴于环境通常是未知的，很难去估计策略的更新对于状态分布造成的影响。</p><p>哇哦！这时候出现了策略梯度定理来拯救世界了！该定理对梯度的形式进行了变形使其不依赖于状态分布$d^{\pi}( .)$的导数，从而在很大程度上简化了梯度$\nabla_{\theta} J(\theta)$的计算：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;=\nabla_{\theta} \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s) \\<br>&amp;\propto \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a \vert s) \end{aligned}<br>$$</p><hr><p><strong>译者注：</strong>这里策略梯度定理的形式不够完全，只考虑了目标函数为连续环境下的平均值形式，上述定理还同时适用于连续环境下的平均回报形式目标函数以及周期环境下的目标函数，即：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;\stackrel{\text{def}}{=} \nabla_{\theta} \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s) &amp; \scriptstyle{\text{连续环境下的平均值形式目标函数}} \\<br>&amp;\stackrel{\text{def}}{=} \nabla_{\theta} \sum_{s\in\mathcal{S}} \mu(s) \sum_{a\in\mathcal{A}} \pi_{\theta}(a | s) \sum_{s^{\prime}\in\mathcal{S}, r} p\left(s^{\prime}, r | s, a\right) r &amp; \scriptstyle{\text{连续环境下的平均回报形式目标函数}}\\<br>&amp;\stackrel{\text{def}}{=} \nabla_{\theta} V^{\pi}(s_{0}) &amp; \scriptstyle{\text{周期环境下的目标函数}}\\<br>&amp; \propto \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a | s) &amp; \scriptstyle{}<br>\end{aligned}<br>$$</p><hr><h3 id="策略梯度定理的证明"><a href="#策略梯度定理的证明" class="headerlink" title="策略梯度定理的证明"></a>策略梯度定理的证明</h3><p>现在我们要深入上述定理的证明（<a href="http://incompleteideas.net/book/bookdraft2017nov5.pdf" target="_blank" rel="external">Sutton&amp;Barto,2017</a>; Sec 13.1（<strong>译者注：这里应该更改为Sec 13.2</strong>））从而理解为什么该定理的正确的，因而这部分会包含很多的数学公式。</p><p>我们首先从计算状态-值函数的梯度开始：<br>$$<br>\begin{aligned}<br>&amp; \nabla_\theta V^\pi(s) \\<br>=&amp; \nabla_\theta \Big(\sum_{a \in \mathcal{A}} \pi_\theta(a \vert s)Q^\pi(s, a) \Big) &amp; \\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\nabla_\theta Q^\pi(s, a)} \Big) &amp; \scriptstyle{\text{; 微分乘法法则}} \\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\nabla_\theta \sum_{s’, r} P(s’,r \vert s,a)(r + V^\pi(s’))} \Big) &amp; \scriptstyle{\text{; 扩展} Q^\pi} \\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\sum_{s’, r} P(s’,r \vert s,a) \nabla_\theta V^\pi(s’)} \Big) &amp; \scriptstyle{; P(s’,r \vert s,a) \text{或者} r \text{不是}\theta \text{的函数}}\\<br>=&amp; \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \color{red}{\sum_{s’} P(s’ \vert s,a) \nabla_\theta V^\pi(s’)} \Big) &amp; \scriptstyle{\text{; 因为 } P(s’ \vert s, a) = \sum_r P(s’, r \vert s, a)}<br>\end{aligned}<br>$$</p><p>现在我们有：<br>$$<br>{\color{red}{\nabla_\theta V^\pi(s)}}<br>= \sum_{a \in \mathcal{A}} \Big( \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) + \pi_\theta(a \vert s) \sum_{s’} P(s’ \vert s,a) \color{red}{\nabla_\theta V^\pi(s’)} \Big)<br>$$<br>上述等式拥有很好的递归特性（红色部分）因而未来状态的状态-值函数$V^{\pi}\left(s^{\prime}\right)$可以根据上式来递归地展开。让我们考虑一个下面这样的状态访问序列并将从状态$s$开始在策略$\pi_{\theta}$下经过$k$个时间步到达状态$x$的概率记为$\rho^{\pi}(s \rightarrow x, k)$：<br>$$<br>s \xrightarrow[]{a \sim \pi_\theta(.\vert s)} s’ \xrightarrow[]{a \sim \pi_\theta(.\vert s’)} s’’ \xrightarrow[]{a \sim \pi_\theta(.\vert s’’)} \dots<br>$$</p><p>对于不同的$k$值，$\rho^{\pi}(s \rightarrow x, k) $值包含以下几种情况：</p><ul><li>当$k=0$时：$\rho^{\pi}(s \rightarrow s, k=0)=1$。</li><li>当$k=1$时，我们遍历在状态$s$下所有可能的动作$a$然后将所有从元组$(s,a)$转移到目标状态的概率累加：$\rho^{\pi}\left(s \rightarrow s^{\prime}, k=1\right)=\sum_{a} \pi_{\theta}(a | s) P\left(s^{\prime} | s, a\right)$。</li><li>设想以下我们的目标是从状态$s$开始依照策略$\pi_{\theta} $经过$k+1$个时间步最终达到目标状态$x$。为了实现这个目标，我们可以先从状态$s$开始经过$k$个时间步后达到某个中间状态$s^{\prime} $（任何一个状态$s\in\mathcal{S}$均可成为中间状态）然后经过最后一个时间步到达目标状态$x$。这样的话，我们就可以递归地计算访问概率：$\rho^{\pi}(s \rightarrow x, k+1)=\sum_{s^{\prime}} \rho^{\pi}\left(s \rightarrow s^{\prime}, k\right) \rho^{\pi}\left(s^{\prime} \rightarrow x, 1\right)$。</li></ul><p>有了以上的相关基础，我们就可以递归地展开$\nabla_\theta V^\pi(s)$！首先为了简化符号我们进行以下符号上的替换：$\phi(s)=\sum_{a \in \mathcal{A}} \nabla_{\theta} \pi_{\theta}(a | s) Q^{\pi}(s, a)$。如果我们不停地展开$\nabla_{\theta} V^{\pi}(\cdot)$，那么可以发现通过这个展开过程我们可以从状态$s$开始经过任意时间步后到达任意的状态，并且将上述过程中的访问概率累加起来就可以得到$\nabla_\theta V^\pi(s)$！<br>$$<br>\begin{aligned}<br>&amp; \color{red}{\nabla_\theta V^\pi(s)} \\<br>=&amp; \phi(s) + \sum_a \pi_\theta(a \vert s) \sum_{s’} P(s’ \vert s,a) \color{red}{\nabla_\theta V^\pi(s’)} \\<br>=&amp; \phi(s) + \sum_{s’} \sum_a \pi_\theta(a \vert s) P(s’ \vert s,a) \color{red}{\nabla_\theta V^\pi(s’)} \\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \color{red}{\nabla_\theta V^\pi(s’)} \\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \color{red}{[ \phi(s’) + \sum_{s’’} \rho^\pi(s’ \to s’’, 1) \nabla_\theta V^\pi(s’’)]} \\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \phi(s’) + \sum_{s’’} \rho^\pi(s \to s’’, 2){\color{red}{\nabla_\theta V^\pi(s’’)}} \scriptstyle{\text{ ; 考虑将 }s’\text{ 作为 }s \to s’’}\text{的中间状态}\\<br>=&amp; \phi(s) + \sum_{s’} \rho^\pi(s \to s’, 1) \phi(s’) + \sum_{s’’} \rho^\pi(s \to s’’, 2)\phi(s’’) + \sum_{s’’’} \rho^\pi(s \to s’’’, 3)\color{red}{\nabla_\theta V^\pi(s’’’)} \\<br>=&amp; \dots \scriptstyle{\text{; 递归展开 }\nabla_\theta V^\pi(.)} \\<br>=&amp; \sum_{x\in\mathcal{S}}\sum_{k=0}^\infty \rho^\pi(s \to x, k) \phi(x)<br>\end{aligned}上述<br>$$</p><p>上述变形使得我们无需计算Q-值函数的梯度$\nabla_\theta Q^\pi(s, a)$。将其带入目标函数$J(\theta)$中，可得：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;= \nabla_\theta V^\pi(s_0) &amp; \scriptstyle{\text{; 从一个随机状态 } s_0 \text{开始}} \\<br>&amp;= \sum_{s}\color{blue}{\sum_{k=0}^\infty \rho^\pi(s_0 \to s, k)} \phi(s) &amp;\scriptstyle{\text{; 令 }\color{blue}{\eta(s) = \sum_{k=0}^\infty \rho^\pi(s_0 \to s, k)}} \\<br>&amp;= \sum_{s}\eta(s) \phi(s) &amp; \\<br>&amp;= \Big( {\sum_s \eta(s)} \Big)\sum_{s}\frac{\eta(s)}{\sum_s \eta(s)} \phi(s) &amp; \scriptstyle{\text{; 正则化 } \eta(s), s\in\mathcal{S} \text{ 使其成为一个概率分布}}\\<br>&amp;\propto \sum_s \frac{\eta(s)}{\sum_s \eta(s)} \phi(s) &amp; \scriptstyle{\sum_s \eta(s)\text{ 是一个常数}} \\<br>&amp;= \sum_s d^\pi(s) \sum_a \nabla_\theta \pi_\theta(a \vert s)Q^\pi(s, a) &amp; \scriptstyle{d^\pi(s) = \frac{\eta(s)}{\sum_s \eta(s)}\text{ 即为平稳分布}}<br>\end{aligned}<br>$$</p><hr><p>译者注：上述证明过程仅仅涉及周期环境，连续环境下的证明如下：<br>$$<br>\begin{aligned}<br>&amp; \nabla_\theta V^\pi(s) \\<br>=&amp; \nabla_\theta \Big(\sum_{a \in \mathcal{A}} \pi_\theta(a \vert s)Q^\pi(s, a) \Big) &amp; \\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\nabla_\theta Q^\pi(s, a)}} \Big) &amp; \scriptstyle{\text{; 微分乘法法则}} \\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\nabla_\theta \sum_{s’, r} P(s’,r \vert s,a)(r - r(\pi) + V^\pi(s’))}}\Big) &amp; \scriptstyle{\text{; 扩展} Q^\pi} \\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s){\color{red}{\bigg[{\color{blue}{-\nabla_{\theta}r(\pi)}}+\sum_{s’, r} P(s’,r \vert s,a) \nabla_\theta V^\pi(s’)} \bigg]}\Big) &amp; \scriptstyle{; P(s’,r \vert s,a) \text{或者} r \text{不是}\theta \text{的函数}}\\<br>=&amp; \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\bigg[{\color{blue}{-\nabla_{\theta}r(\pi)}}+\sum_{s’} P(s’ \vert s,a) \nabla_\theta V^\pi(s’)} \bigg]}\Big) &amp; \scriptstyle{\text{; 因为 } P(s’ \vert s, a) = \sum_r P(s’, r \vert s, a)} \\<br>=&amp; {\color{blue}{-\nabla_{\theta}r(\pi)}} + \phi(s) + \sum_{a \in \mathcal{A}} \Big( \pi_\theta(a \vert s) {\color{red}{\sum_{s’} P(s’ \vert s,a) \nabla_\theta V^\pi(s’)}}\Big)<br>\end{aligned}<br>$$</p><p>经过移项可得：<br>$$<br>\color{blue} {\nabla_{\theta}r(\pi)} =\phi(s) + \sum_{a}\left[\pi_{\theta}(a | s) \color{red} {\sum_{s^{\prime}} p\left(s^{\prime} | s, a\right) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)} \right]-\nabla_{\theta} V^{\pi}(s)<br>$$<br>那么平均回报形式的目标函数的梯度有：<br>$$<br>\begin{aligned}<br>\nabla_{\theta}J(\theta) =&amp;\;\nabla_{\theta} r(\pi) \\<br>=&amp; \sum_{s} d^{\pi}(s)\left(\phi(s) + \sum_{a}\left[\pi_{\theta}(a | s) \sum_{s^{\prime}} p\left(s^{\prime} | s, a\right) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)\right]-\nabla_{\theta} V^{\pi}(s)\right) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) +\sum_{s} d^{\pi}(s) \sum_{a} \pi_{\theta}(a | s) \sum_{s^{\prime}} p\left(s^{\prime} | s, a\right) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)-\sum_{s} d^{\pi}(s) \nabla_{\theta} V^{\pi}(s) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) + \sum_{s^{\prime}} \underbrace{\sum_{s} d^{\pi}(s) \sum_{a} \pi_{\theta}(a|s) p\left(s^{\prime}|s,a\right)}_{d^{\pi}\left(s^{\prime}\right)} \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)-\sum_{s} d^{\pi}(s) \nabla_{\theta} V^{\pi}(s) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) + \sum_{s^{\prime}} d^{\pi}(s^{\prime}) \nabla_{\theta} V^{\pi}\left(s^{\prime}\right)-\sum_{s} d^{\pi}(s) \nabla_{\theta} V^{\pi}(s) \\<br>=&amp; \sum_{s} d^{\pi}(s) \phi(s) \\<br>=&amp; \sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta\pi_\theta(a \vert s) \\<br>\propto&amp; \sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta \pi_\theta(a \vert s)<br>\end{aligned}<br>$$<br>其中第二个等式成立是因为$\nabla_{\theta}r(\pi)$不依赖$s$且$\sum_{s}d^{\pi}(s)=1$。</p><p>另外，平均值形式的目标函数的梯度有：<br>$$<br>\begin{aligned}<br>\nabla_{\theta}J(\theta) =&amp;\;\nabla_{\theta}\sum_{s \in \mathcal{S}} d^{\pi}(s) V^{\pi}(s) \\<br>=&amp;\;\nabla_{\theta} \sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s)\\<br>=&amp;\;\frac{1}{1-\gamma}\nabla_{\theta} r(\pi) \\<br>=&amp;\;\frac{1}{1-\gamma}\left(\sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta\pi_\theta(a \vert s)\right) \\<br>\propto&amp; \sum_s d^\pi(s) \sum_a Q^\pi(s, a)\nabla_\theta \pi_\theta(a \vert s)<br>\end{aligned}<br>$$</p><hr><p>梯度还可以改写为如下形式：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;\propto \sum_{s \in \mathcal{S}} d^\pi(s) \sum_{a \in \mathcal{A}} Q^\pi(s, a) \nabla_\theta \pi_\theta(a \vert s) &amp;\\<br>&amp;= \sum_{s \in \mathcal{S}} d^\pi(s) \sum_{a \in \mathcal{A}} \pi_\theta(a \vert s) Q^\pi(s, a) \frac{\nabla_\theta \pi_\theta(a \vert s)}{\pi_\theta(a \vert s)} &amp;\\<br>&amp;= \mathbb{E}_\pi [Q^\pi(s, a) \nabla_\theta \ln \pi_\theta(a \vert s)] &amp; \scriptstyle{\text{; 因为 } (\ln x)’ = 1/x}<br>\end{aligned}<br>$$<br>$\mathbb{E}_{\pi}$代表$\mathbb{E}_{s \sim d_{\pi}, a \sim \pi_{\theta}}$，下标表示遵循策略$\pi_{\theta}$（在线策略）时状态以及动作的分布。</p><p>上述策略梯度定理是许多策略梯度算法的理论基础。平凡策略梯度算法由于直接使用采样得到的回报所以其估计的梯度不存在偏差（bias）但是有较大的方差（variance）（见下式）。因此后续的算法被相继提出用以在保持偏差有界的情况下减小方差。<br>$$<br>\nabla_{\theta} J(\theta)=\mathbb{E}_{\pi}\left[Q^{\pi}(s, a) \nabla_{\theta} \ln \pi_{\theta}(a | s)\right]<br>$$<br>这里有一个从GAE（泛化优势估计，genaral advantage estimate）论文 （<a href="https://arxiv.org/abs/1506.02438" target="_blank" rel="external">Schulman et al., 2016</a>）中引用的很好的策略梯度算法一般形式的归纳，并且<a href="https://danieltakeshi.github.io/2017/04/02/notes-on-the-generalized-advantage-estimation-paper/" target="_blank" rel="external">这篇博客</a>深入探讨了GAE的几大组成部分，值得一读。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-593dfedad43dfce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1. 策略梯度方法的一般形式。图片来源：[Schulman et al., 2016](https://arxiv.org/abs/1506.02438)"></p><h2 id="策略梯度算法"><a href="#策略梯度算法" class="headerlink" title="策略梯度算法"></a>策略梯度算法</h2><p>今年来强化学习领域内提出了大量的策略梯度算法，我不可能罗列出所有的算法。因此在这里我仅仅列举出一些我恰巧了解的算法。</p><h3 id="REINFORCE"><a href="#REINFORCE" class="headerlink" title="REINFORCE"></a>REINFORCE</h3><p>REINFORCE（蒙特卡洛策略梯度）依靠使用<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#monte-carlo-methods" target="_blank" rel="external">蒙特卡洛</a>方法从采样出的轨迹样本得到的估计的累积回报来更新策略的参数$\theta $。REINFORCE算法能够起效的原因是因为采样的梯度的期望值是真实梯度的无偏估计：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;= \mathbb{E}_\pi [Q^\pi(s, a) \nabla_\theta \ln \pi_\theta(a \vert s)] &amp; \\<br>&amp;= \mathbb{E}_\pi [G_t \nabla_{\theta} \ln \pi_\theta(A_t \vert S_t)] &amp; \scriptstyle{\text{; 因为 } Q^\pi(S_t, A_t) = \mathbb{E}_\pi[G_t \vert S_t, A_t]}<br>\end{aligned}<br>$$<br>因此我们能够从真实的采样轨迹中计算$G_t$并且使用它来去更新我们的策略梯度。它依赖于一条完整的轨迹，这也是为什么被叫做蒙特卡洛方法的原因。</p><p>整个算法流程十分直接：</p><ol><li>随机初始化策略参数$\theta $</li><li>使用当前策略$\pi_{\theta} $产生一条完整的轨迹：$S_{1}, A_{1}, R_{2}, S_{2}, A_{2}, \dots, S_{T}$</li><li>对于每个时间步$\mathrm{t}=1,2, \ldots, \mathrm{T}$：<ol><li>估计累积回报$G_t$</li><li>更新参数：$\theta \leftarrow \theta+\alpha \gamma^{t} G_{t} \nabla_{\theta} \ln \pi_{\theta}\left(A_{t} | S_{t}\right)$</li></ol></li></ol><p>一个被广泛应用的REINFORCE算法的变种是从$G_t$中减去一个基准值用来<em>在保证偏差不变的情况下减小估计梯度时产生的方差</em>（我们总是希望尽可能这样做）。举个例子，一个被广泛使用的基准值是状态-值，如果我们应用状态-值作为基准，那么我们实际在估计梯度进行梯度上升来更新参数的过程中使用的是优势值：$A(s, a)=Q(s, a)-V(s)$。<a href="https://danieltakeshi.github.io/2017/03/28/going-deeper-into-reinforcement-learning-fundamentals-of-policy-gradients/" target="_blank" rel="external">这篇博客</a>不仅仅很好地解释了为什么采用基准值会减小方差，而且还详细讲解了策略梯度的一些基础知识。</p><h3 id="演员-评论家算法（Actor-Critic）"><a href="#演员-评论家算法（Actor-Critic）" class="headerlink" title="演员-评论家算法（Actor-Critic）"></a>演员-评论家算法（Actor-Critic）</h3><p>策略梯度算法主要包括策略模型以及值函数两个部分。在学习策略的基础上额外学习值函数是有很大意义的，因为值函数可以辅助策略更新，例如在平凡策略梯度算法中利用值函数来进行方差缩减，而这也是演员-评论家算法在做的事情。</p><p>演员-评论家模型由两个模型组成，可以选择是否共享参数：</p><ul><li><strong>评论家</strong>更新值函数的参数$w$并且根据算法的不同值函数可以为动作-值$Q_{w}(a | s)$或者状态-值$V_{w}(s)$</li><li><strong>演员</strong>根据评论家建议的方向更新策略$\pi_{\theta}(a | s)$参数$\theta $</li></ul><p>下面让我们看看一个简单的动作-值演员-评论家算法：</p><ol><li>随机初始化$s, w, \theta$；从初始策略中采样$a \sim \pi_{\theta}(a | s)$</li><li>对于每个时间步$t=1 \ldots T :$<ol><li>采样回报$r_{t} \sim R(s, a)$以及下一个状态$s^{\prime} \sim P\left(s^{\prime} | s, a\right)$</li><li>采样下一个动作$a^{\prime} \sim \pi_{\theta}\left(a^{\prime} | s^{\prime}\right)$</li><li>更新策略参数：$\theta \leftarrow \theta+\alpha_{\theta} Q_{w}(s, a) \nabla_{\theta} \ln \pi_{\theta}(a | s)$</li><li>对于当前时间步的动作-值计算校正值（TD误差）：$\delta_{t}=r_{t}+\gamma Q_{w}\left(s^{\prime}, a^{\prime}\right)-Q_{w}(s, a)$并且使用它来更新动作-值函数的参数：$w \leftarrow w+\alpha_{w} \delta_{t} \nabla_{w} Q_{w}(s, a)$</li><li>更新当前动作$a \leftarrow a^{\prime}$以及状态$s \leftarrow s^{\prime}$</li></ol></li></ol><p>$\alpha_w$和$\alpha_{\theta}$是两个预先定义的分别用来更新策略以及值函数的学习率。</p><h3 id="离线策略梯度（Off-Policy-Policy-Gradient）"><a href="#离线策略梯度（Off-Policy-Policy-Gradient）" class="headerlink" title="离线策略梯度（Off-Policy Policy Gradient）"></a>离线策略梯度（Off-Policy Policy Gradient）</h3><p>REINFORCE算法以及上述简单版本的演员-评论家算法都是在线（on-policy）的：训练样本是通过目标策略（target policy）——我们想要去优化的策略——收集的。然而离线方法拥有以下额外的优势：</p><ol><li>离线方法不需要完整的轨迹样本并且可以复用任何历史轨迹的样本（<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#deep-q-network" target="_blank" rel="external">“经验回放”</a>）从而具有更好的样本有效性。</li><li>训练样本根据行为策略（behavior policy）而不是目标策略收集而来，给算法带来更好的<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#exploration-exploitation-dilemma" target="_blank" rel="external">探索性</a>。</li></ol><p>现在让我们来看看离线策略梯度是如何计算的。用来收集训练样本的行为策略是一个已知的策略（类似一个预先定义好的超参数），我们把它记作$\beta(a | s)$。那么目标函数（这里我们采用的是平均值形式的目标函数，其他形式的目标函数可以导出相同的结果）为由此行为策略导出的平稳状态分布下的回报的加和：</p><p>$$<br>J(\theta)=\sum_{s \in \mathcal{S}} d^{\beta}(s) \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s)=\mathbb{E}_{s \sim d^{\beta}}\left[\sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a | s)\right],<br>$$<br>其中$d^{\beta}(s)$为行为策略$\beta$导出的平稳分布，$d^{\beta}(s)=\lim _{t \rightarrow \infty} P\left(S_{t}=s | S_{0}, \beta\right)$。$Q^{\pi}$为根据目标策略$\pi$（不是行为策略！）估计的动作-值函数。</p><p>给定根据行为策略采样得到的动作$a \sim \beta(a | s)$产生的训练样本，我们可以将策略梯度改写为如下形式：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;= \nabla_{\theta} \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \pi_{\theta}(a \vert s) \Big] &amp; \\<br>&amp;= \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} \big( Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a \vert s) + \color{red}{\pi_{\theta}(a \vert s) \nabla_{\theta} Q^{\pi}(s, a)} \big) \Big] &amp; \scriptstyle{\text{; 微分乘法法则.}}\\<br>&amp;\stackrel{(i)}{\approx} \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} Q^{\pi}(s, a) \nabla_{\theta} \pi_{\theta}(a \vert s) \Big] &amp; \scriptstyle{\text{; 忽略红色部分: } \color{red}{\pi_{\theta}(a \vert s) \nabla_{\theta} Q^{\pi}(s, a)}}. \\<br>&amp;= \mathbb{E}_{s \sim d^{\beta}} \Big[ \sum_{a \in \mathcal{A}} \beta (a \vert s) \frac{\pi_{\theta}(a \vert s)}{\beta (a \vert s)} Q^{\pi}(s, a) \frac{\nabla_{\theta} \pi_{\theta}(a \vert s)}{\pi_{\theta}(a \vert s)} \Big] &amp; \\<br>&amp;= \mathbb{E}_\beta \Big[\frac{\color{blue}{\pi_{\theta}(a \vert s)}}{\color{blue}{\beta (a \vert s)}} Q^{\pi}(s, a) \nabla_{\theta} \ln \pi_{\theta}(a \vert s) \Big], &amp; \scriptstyle{\text{; 蓝色部分成为重要性权重.}}<br>\end{aligned}<br>$$<br>其中$\frac{\pi_{\theta}(a | s)}{\beta(a | s)}$为<a href="http://timvieira.github.io/blog/post/2014/12/21/importance-sampling/" target="_blank" rel="external">重要性权重(importance weight)</a>。由于$Q^{\pi}$是目标策略的函数因而也就是策略参数$\theta$的参数，因而根据微分乘法法则我们需要计算梯度$\nabla_{\theta} Q^{\pi}(s, a)$。然而在现实问题中计算$\nabla_{\theta} Q^{\pi}(s, a)$是一件超级困难的事情。幸运的是如果我们直接忽略掉$Q$的梯度而去使用一个近似的策略梯度的话，依旧能够保证采用梯度上升算法能够使得策略性能提升并且最终收敛到一个真实的局部最优解。上述结论的具体证明过程请参阅<a href="https://arxiv.org/pdf/1205.4839.pdf" target="_blank" rel="external">这篇论文</a>（Degris, White &amp; Sutton, 2012）。</p><p>总而言之，当我们想在离线环境下应用策略梯度时，只需通过加权求和的方式对其进行简单的修改，权重为目标策略与行为策略的比值。</p><h3 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h3><p>[<a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">论文</a>|<a href="https://github.com/dennybritz/reinforcement-learning/tree/master/PolicyGradient/a3c" target="_blank" rel="external">代码</a>]</p><p>异步优势演员-评论家方法（<strong>Asynchronous Advantage Actor-Critic</strong>）（<a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">Mnih et al., 2016</a>），简写为<strong>A3C</strong>时一种经典的策略梯度方法，尤其注重并行训练。</p><p>在A3C中，评论家学习值函数，同时有多个演员并行训练并且不时与全局参数同步。因而，A3C旨在用于并行训练。</p><p>让我们用状态-值函数进行举例。状态值的损失函数是最小化均方误差 $J_{v}(w)=\left(G_{t}-V_{w}(s)\right)^{2}$，因而采用梯度下降方法可以找到最优参数$w$。状态-值函数用来在策略梯度更新中作为基准值。</p><p>下面是算法大纲：</p><ol><li>定义全局参数 $\theta$ 和 $w$ 以及特定线程参数 $\theta^{\prime}$ 和 $w^{\prime}$。</li><li>初始化时间步 $t=1$。</li><li><p>当 $T&lt;=T_{\mathrm{max}}$：</p><ol><li><p>重置梯度：$\mathrm{d} \theta=0$ 并且 $\mathrm{d} \mathrm{w}=0$。</p></li><li><p>将特定于线程的参数与全局参数同步：$\theta^{\prime}=\theta$ 以及 $w^{\prime}=w$。</p></li><li><p>令 $t_{\text {start }}=t$ 并且随机采样一个初始状态 $s_t$。</p></li><li><p>当 （$s_{t} !=$ 终止状态）并且 $t-t_{\text {start}}&lt;=t_{\text {max}}$：</p><ol><li>根据当前线程的策略选择当前执行的动作 $a_{t} \sim \pi_{\theta^{\prime}}\left(a_{t} | s_{t}\right)$，执行动作后接收回报$r_t$然后转移到下一个状态$s_{t+1}$。</li><li>更新 $t$ 以及 $T$：$t=t+1$ 并且 $T=T+1$。</li></ol></li><li><p>初始化保存累积回报估计值的变量：$r=\left\{\begin{array}{ll}{0} &amp; {\text { 如果 } s_{t} \text { 是终止状态}} \\ {V_{w^{\prime}}\left(s_{t}\right)} &amp; {\text { 否则}}\end{array}\right.$</p></li><li><p>对于 $i=t-1, \dots, t_{\text {start}}$：</p><ol><li><p>$r \leftarrow \gamma r+r_{i}$；这里 $r$ 是 $G_i$ 的蒙特卡洛估计。</p></li><li><p>累积关于参数 $\theta^{\prime}$ 的梯度：$d \theta \leftarrow d \theta+\nabla_{\theta^{\prime}} \log \pi_{\theta^{\prime}}\left(a_{i} | s_{i}\right)\left(r-V_{w^{\prime}}\left(s_{i}\right)\right)$；</p><p>累积关于参数 $w^{\prime}$ 的梯度：$d w \leftarrow d w+2\left(r-V_{w^{\prime}}\left(s_{i}\right)\right) \nabla_{w^{\prime}}\left(r-V_{w^{\prime}}\left(s_{i}\right)\right)$。</p></li></ol></li><li><p>分别使用 $d\theta$ 以及 $dw$异步更新 $\theta$ 以及 $w$。</p></li></ol></li></ol><p>A3C支持多智能体（<strong>译者注：这里的多智能体与多智能体强化学习中的多智能体不是一个概念</strong>）并行训练。梯度累积步骤（6.2）可以认为是基于小批量样本的随机梯度下降在并行环境下的变形：$w$ 或者 $\theta$ 的值在每个训练线程得出的更新方向上独立地校正一点点。</p><h3 id="A2C"><a href="#A2C" class="headerlink" title="A2C"></a>A2C</h3><p>[<a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/blob/master/baselines/a2c/a2c.py" target="_blank" rel="external">代码</a>]</p><p><strong>A2C</strong>是A3C的同步、确定版本；这也是为什么要把A3C的第一个”A“（”异步“）去掉。在A3C中，每个演员独立地与（保存）全局参数（的服务器）进行交互，因此有时不同线程中的演员将使用不同版本的策略，因此累积更新的方向将不是最优的。为了解决上述执行策略不一致问题，A2C中引入协调器，在更新全局参数之前等待所有并行的演员完成其工作，那么在下一次迭代中并行的演员将均执行同一策略。同步的梯度更新使得训练过程更加耦合因而有可能使得算法具有更快得收敛速度。</p><p>A2C已被<a href="https://blog.openai.com/baselines-acktr-a2c/" target="_blank" rel="external">证明</a>在能够实现与A3C相同或更好的性能得同时，更有效地利用GPU，并且能够适应更大的批量大小。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-936d61bf7c84165f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2. A3C与A2C架构对比。"></p><h3 id="确定性策略梯度（DPG）"><a href="#确定性策略梯度（DPG）" class="headerlink" title="确定性策略梯度（DPG）"></a>确定性策略梯度（DPG）</h3><p>[<a href="https://hal.inria.fr/file/index/docid/938992/filename/dpg-icml2014.pdf" target="_blank" rel="external">论文</a>|代码]</p><p>在上述方法中，策略函数 $\pi( . | s)$ 总是被建模为给定当前状态下在动作空间 $\mathcal{A}$ 上的概率分布，因而策略是随机的。相反，确定性策略梯度（<strong>Deterministic Policy Gradient</strong>）将环境建模为一个确定性决策：$a=\mu(s)$。这可能看上去很奇怪——你如何计算一个只能输出单个动作的策略函数的梯度呢？让我们一步步往下看。</p><p>回忆一些符号以便进行下面的讨论：</p><ul><li>$\rho_{0}(s)$：初始状态分布</li><li>$\rho^{\mu}\left(s \rightarrow s^{\prime}, k\right)$：从状态 $s$ 开始，遵循策略 $\mu$ 的情况下经过 $k$ 个时间步后到达状态 $s^{\prime}$ 的访问概率密度</li><li>$\rho^{\mu}\left(s^{\prime}\right)$：折扣状态分布，定义为 $\rho^{\mu}\left(s^{\prime}\right)=\int_{\mathcal{S}} \sum_{k=1}^{\infty} \gamma^{k-1} \rho_{0}(s) \rho^{\mu}\left(s \rightarrow s^{\prime}, k\right) d s$</li></ul><p>（平均值形式的）目标函数定义如下：<br>$$<br>J(\theta)=\int_{\mathcal{S}} \rho^{\mu}(s) Q\left(s, \mu_{\theta}(s)\right) ds<br>$$<br><strong>确定性策略梯度定理</strong>：现在该计算梯度了！根据链式法则，我们首先计算 $Q$ 相对于动作 $a$ 的梯度然后计算确定性策略函数 $\mu$ 相对于其参数 $\theta$ 的参数：<br>$$<br>\begin{aligned}<br>\nabla_{\theta} J(\theta) &amp;=\int_{\mathcal{S}} \rho^{\mu}(s) \nabla_{a} Q^{\mu}(s, a) \nabla_{\theta} \mu_{\theta}\left.(s)\right|_{a=\mu_{\theta}(s)} d s \\ &amp;=\mathbb{E}_{s \sim \rho^{\mu}}\left[\nabla_{a} Q^{\mu}(s, a) \nabla_{\theta} \mu_{\theta}\left.(s)\right|_{a=\mu_{\theta}(s)}\right]<br>\end{aligned}<br>$$<br>我们可以将确定性策略看成是随即策略的一个特例，前者的在整个动作空间的概率分布只在一个动作上是非零值。实际上在DPG<a href="https://hal.inria.fr/file/index/docid/938992/filename/dpg-icml2014.pdf" target="_blank" rel="external">论文</a>中作者表明，如果随机策略 $\pi_{\mu_{\theta}, \sigma}$ 被确定性策略 $\mu_{\theta}$ 以及一个方差变量 $\sigma$ 重参数化，则当 $\sigma = 0$ 时随机策略最终将等价于确定策略。与确定性策略相比，我们可以认为随机策略需要更多样本，因为它整合了整个状态和动作空间的数据。</p><p>确定性梯度定理可以整合到通用的策略梯度算法框架中。</p><p>让我们考虑一个在线演员-评论家算法的例子来表明这个过程。在在线演员-评论家算法的每次迭代过程中，两个时间步的动作通过确定策略来选择 $a=\mu_{\theta}(s)$，然后 <a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#sarsa-on-policy-td-control" target="_blank" rel="external">SARSA</a> 算法通过上面计算得到的新形式的梯度来更新策略参数：<br>$$<br>\begin{aligned}<br>\delta_t &amp;= R_t + \gamma Q_w(s_{t+1}, a_{t+1}) - Q_w(s_t, a_t) &amp; \scriptstyle{\text{; SARSA算法中的 TD 误差}}\\<br>w_{t+1} &amp;= w_t + \alpha_w \delta_t \nabla_w Q_w(s_t, a_t) &amp; \\<br>\theta_{t+1} &amp;= \theta_t + \alpha_\theta \color{red}{\nabla_a Q_w(s_t, a_t) \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)}} &amp; \scriptstyle{\text{; 确定性策略梯度定理}}<br>\end{aligned}<br>$$<br>然而，除非环境本身具有足够多的噪声，否则由于策略的确定性很难保证在训练的过程中有进行足够多的<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#exploration-exploitation-dilemma" target="_blank" rel="external">探索</a>。我们可以在确定策略中添加噪音（讽刺的是，这使得它将不具有确定性！）或者通过遵循不同的随机<strong>行为</strong>策略来收集样本来离线地学习<strong>目标</strong>确定策略。</p><p>比方说，在离线方法中，训练轨迹样本是通过一个随机行为策略 $\beta(a | s)$ 产生的因而状态分布服从对应的折扣状态密度 $\rho^{\beta}$：<br>$$<br>\begin{aligned}<br>J_\beta(\theta) &amp;= \int_\mathcal{S} \rho^\beta Q^\mu(s, \mu_\theta(s)) ds \\<br>\nabla_\theta J_\beta(\theta) &amp;= \mathbb{E}_{s \sim \rho^\beta} [\nabla_a Q^\mu(s, a) \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)} ]<br>\end{aligned}<br>$$<br>注意由于策略是确定性的，我们只需要通过 $Q^{\mu}\left(s, \mu_{\theta}(s)\right)$ 而不是 $\sum_{a} \pi(a | s) Q^{\pi}(s, a)$ 来估计给定状态 $s$ 的累积回报（<strong>译者注：这也是为什么上述第二个等式期望的下标只有状态的期望</strong>）。就像我们在<a href="#离线策略梯度">之前</a>提到的，在采用随机目标策略的离线方法中，会引入重要性采样来校正行为策略与目标策略之间的不匹配现象。然而，由于确定性策略梯度中移除了在动作空间中的积分项，我们就可以避免使用重要性采样。</p><h3 id="深度确定性策略梯度-（DDPG）"><a href="#深度确定性策略梯度-（DDPG）" class="headerlink" title="深度确定性策略梯度 （DDPG）"></a>深度确定性策略梯度 （DDPG）</h3><p>[<a href="https://arxiv.org/pdf/1509.02971.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/ddpg" target="_blank" rel="external">代码</a>]</p><p><strong>DDPG</strong>（<a href="https://arxiv.org/pdf/1509.02971.pdf" target="_blank" rel="external">Lillicrap, et al., 2015</a>）是深度确定性策略梯度（<strong>Deep Deterministic Policy Gradient</strong>）的缩写，是一个结合了<a href="https://lilianweng.github.io/lil-log/2018/04/08/policy-gradient-algorithms.html#dpg" target="_blank" rel="external">DPG</a>以及<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#deep-q-network" target="_blank" rel="external">DQN</a>的无模型离线演员-评论家算法。回忆一下，DQN（深度Q网络）通过经验回访以及冻结目标网络的方式来稳定Q函数的训练过程。原始的DQN算法只能在离散的动作空间上使用，DDPG算法在学习一个确定性策略的同时通过演员-评论家框架将其扩展到连续的动作空间中。</p><p>为了获得更好的探索度，DDPG通过添加噪声 $\mathcal{N}$ 的方式构建了一个探索策略 $\mu^{\prime}$：<br>$$<br>\mu^{\prime}(s)=\mu_{\theta}(s)+\mathcal{N}<br>$$<br>另外，DDPG对演员以及评论家的目标网络的参数实行的是软更新（”保守策略迭代“），其中 $\tau \ll 1$：$\theta^{\prime} \leftarrow \tau \theta+(1-\tau) \theta^{\prime}$。采用这种方式，目标网络的值被限制为缓慢变化，不同于在DQN的设计中目标网络在一段时间内直接被冻结。</p><p>论文中关于机器人领域特别有用的一个细节是如何正则化低维特征的不同物理单位。例如，我们设计一个模型旨在学习以机器人的位置和速度为输入的策略；这些物理统计数据本质上是不同的，甚至相同类型的统计数据在多个机器人中也可能会有很大差异。论文通过应用<a href="http://proceedings.mlr.press/v37/ioffe15.pdf" target="_blank" rel="external">批正则化</a>通过对一个小批量中的样本的每个维度进行正则化来解决上述问题。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-c2801505c52ccbf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3. DDPG算法。图片来源：[Lillicrap, et al., 2015](https://arxiv.org/pdf/1509.02971.pdf)"></p><h3 id="D4PG"><a href="#D4PG" class="headerlink" title="D4PG"></a>D4PG</h3><p>[<a href="https://openreview.net/forum?id=SyZipzbCb" target="_blank" rel="external">论文</a>|代码（在谷歌中搜索”github d4pg“可以找到一些非官方开源实现）]</p><p>分布地分布式DDPG（<strong>Distributed Distributional DDPG</strong>，<strong>D4PG</strong>）在DDPG算法上进行了一系列的改进使得其可以分布式地运行。</p><p>（1）<strong>分布式评论家</strong>：分布式评论家不再只估计Q值的期望值，而是去估计期望Q值的分布，即将期望Q值作为一个随机变量来进行估计——该变量服从一个由 $w$ 参数化的分布 $Z_w$ 因而 $Q_{w}(s, a)=\mathbb{E} Z_{w}(x, a)$。学习该分布的参数所对应的损失函数是去最小化两个分布之间的某种距离度量——分布式TD误差：$L(w)=\mathbb{E}\left[d\left(\mathcal{T}_{\mu_{\theta}}, Z_{w^{\prime}}(s, a), Z_{w}(s, a)\right]\right.$，其中 $T_{\mu_{\theta}}$ 表示贝尔曼算子。</p><p>相应的，确定性策略梯度更新转变为以下形式：<br>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)<br>&amp;\approx \mathbb{E}_{\rho^\mu} [\nabla_a Q_w(s, a) \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)}] &amp; \scriptstyle{\text{; DPG中的梯度更新}} \\<br>&amp;= \mathbb{E}_{\rho^\mu} [\mathbb{E}[\nabla_a Q_w(s, a)] \nabla_\theta \mu_\theta(s) \rvert_{a=\mu_\theta(s)}] &amp; \scriptstyle{\text{; Q值分布的期望}}<br>\end{aligned}<br>$$<br>（2）<strong>N步累积回报</strong>：当计算TD误差时，D4PG计算的是N步的TD目标值而不仅仅只有一步，这样就可以考虑未来更多步骤的回报。因而新的TD目标值变为：<br>$$<br>r\left(s_{0}, a_{0}\right)+\mathbb{E}\left[\sum_{n=1}^{N-1} r\left(s_{n}, a_{n}\right)+\gamma^{N} Q\left(s_{N}, \mu_{\theta}\left(s_{N}\right)\right) | s_{0}, a_{0}\right]<br>$$<br>（3）<strong>多个分布式并行演员</strong>：D4PG使用$K$个独立的演员并行收集训练样本并存储到同一个回访缓冲中。</p><p>（4）<strong>优先经验回放</strong>（<strong>Prioritized Experience Replay</strong>，<a href="https://arxiv.org/abs/1511.05952" target="_blank" rel="external"><strong>PER</strong></a>）：最后一个改进是使用一个非均匀的概率 $p_i$ 从一个大小为 $R$ 的回放缓冲中进行采样。在这种采样方式下，一个样本 $i$ 将以概率 $\left(R p_{i}\right)^{-1}$ 被采样到因而重要性权重为 $\left(R p_{i}\right)^{-1}$。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-73d004524ff39cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4. D4PG算法。图片来源：[Barth-Maron, et al. 2018。注意在原始论文中变量符号的选择与本文有些微的区别；例如，我使用$\mu(.)$而不是$\pi(.)$来表示一个确定性策略](https://openreview.net/forum?id=SyZipzbCb)。"></p><h3 id="MADDPG"><a href="#MADDPG" class="headerlink" title="MADDPG"></a>MADDPG</h3><p>[<a href="https://arxiv.org/pdf/1706.02275.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/maddpg" target="_blank" rel="external">代码</a>]</p><p>多智能体DDPG（<strong>Multi-agent DDPG</strong>，<strong>MADDPG</strong>，<a href="https://arxiv.org/pdf/1706.02275.pdf" target="_blank" rel="external">Lowe et al., 2017</a>）将DDPG扩展到多智能体环境中，其中包含多个智能体在仅依靠局部信息的情况下协作完成任务。从单个智能体的角度来看，环境是非平稳的，因为其他智能体的策略在很快地更新并且一直是未知的。MADDPG是一个经过重新设计的演员评论家算法，专门用于处理这种不断变化的环境以及智能体之间的互动。</p><p>这个问题可以被建模为多智能体版本的MDP，也被称为<em>马尔科夫游戏</em>。其中，共有 $N$ 个智能体，公共的状态空间为 $\mathcal{S}$。每个智能体拥有自己的动作空间 $\mathcal{A}_{1}, \dots, \mathcal{A}_{N}$ 以及观察空间 $\mathcal{O}_{1}, \dots, \mathcal{O}_{N}$。状态转移函数包括所有的状态、动作以及观察空间$\mathcal{T} : \mathcal{S} \times \mathcal{A}_{1} \times \ldots \mathcal{A}_{N} \mapsto \mathcal{S}$。每个智能体自己的随机策略仅仅用到属于自己的观察以及动作：$\pi_{\theta_{i}} : \mathcal{O}_{i} \times \mathcal{A}_{i} \mapsto[0,1]$，一个给定其自身观察下关于动作的概率分布；或者一个确定性策略：$\mu_{\theta_{i}} : \mathcal{O}_{i} \mapsto \mathcal{A}_{i}$。</p><p>令 $\vec{o}=o_{1}, \ldots, o_{N}, \vec{\mu}=\mu_{1}, \ldots, \mu_{N}$ 并且策略是由 $\vec{\theta}=\theta_{1}, \dots, \theta_{N}$ 参数化的。</p><p>MADDPG中的评论家为第 $i$ 个智能体（每个智能体）学习一个中心化的动作-值函数 $Q_{i}^{\vec{\mu}}\left(\vec{o}, a_{1}, \ldots, a_{N}\right)$，其中 $a_{1} \in \mathcal{A}_{1}, \ldots, a_{N} \in \mathcal{A}_{N}$ 是所有智能体的动作。每一个 $Q_{i}^{\vec{\mu}},\;i=1, \dots, N$ 都是独立学习的，因而每个智能体可以拥有任意形式的回报函数，包括竞争环境中相互冲突的回报函数。同时，每个智能体各自的演员，也是独立探索以及独立更新策略参数 $\theta_{i}$。</p><p><strong>演员更新：</strong><br>$$<br>\nabla_{\theta_{i}} J\left(\theta_{i}\right)=\mathbb{E}_{\vec{o}, a \sim D}\left[\nabla_{a_{i}} Q_{i}^{\vec{\mu}}\left(\vec{o}, a_{1}, \ldots, a_{N}\right) \nabla_{\theta_{i}} \mu_{\theta_{i}}\left.\left(o_{i}\right)\right|_{a_{i}=\mu_{\theta_{i}}\left(o_{i}\right)}\right]<br>$$<br>其中 $\mathcal{D}$ 表示经验回放缓冲，包含大量轨迹样本 $\left(\vec{o}, a_{1}, \ldots, a_{N}, r_{1}, \ldots, r_{N}, \vec{o}^{\prime}\right)$ —— 给定当前联合观察 $\vec{o}$，每个智能体分别执行动作 $a_{1}, \dots, a_{N}$ 后获取各自的回报 $r_{1}, \dots, r_{N}$，并转移到下一个联合观察 $\vec{o}^{\prime}$。</p><p><strong>评论家更新：</strong><br>$$<br>\begin{aligned}<br>\mathcal{L}(\theta_i) &amp;= \mathbb{E}_{\vec{o}, a_1, \dots, a_N, r_1, \dots, r_N, \vec{o}’}[ (Q^{\vec{\mu}}_i(\vec{o}, a_1, \dots, a_N) - y)^2 ] &amp; \\<br>\text{其中 } y &amp;= r_i + \gamma Q^{\vec{\mu}’}_i (\vec{o}’, a’_1, \dots, a’_N) \rvert_{a’_j = \mu’_{\theta_j}} &amp; \scriptstyle{\text{; TD目标值!}}<br>\end{aligned}<br>$$<br>其中 $\vec{\mu}^{\prime}$ 是延迟软更新参数的目标策略。</p><p>如果在评论家更新的过程中策略 $\vec{\mu}$ 是未知的，我们可以让每个智能体学习并更新自己对其他智能体策略的近似。当使用近似的策略时，尽管推断出的策略可能不够精确但是MADDPG仍然能够有效地学习。</p><p>为了缓解环境中竞争或协作关系的智能体之间由于相互作用所带来的高方差，MADDPG提出了另外一个技术——策略集成：</p><ol><li>为单个智能体训练 $K$ 个策略；</li><li>随机选取一个策略用以轨迹采样；</li><li>使用 $K$ 个策略的集成梯度来进行参数更新。</li></ol><p>总之，MADDPG在DDPG之上添加了三个额外部分，使其适应多智能体环境：</p><ul><li>中心化评论家+去中心化演员；</li><li>智能体能够使用估计的其他智能体的策略来进行学习；</li><li>策略集成能够很好的减小方差。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13653853-6620a93556a2d0e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5. MADDPG的算法框架. 图片来源：[Lowe et al., 2017](https://arxiv.org/pdf/1706.02275.pdf)"></p><h3 id="TRPO"><a href="#TRPO" class="headerlink" title="TRPO"></a>TRPO</h3><p>[<a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/trpo_mpi" target="_blank" rel="external">代码</a>]</p><p>为了提升训练的稳定性，我们应该避免更新一步就使得策略发生剧烈变化的参数更新。置信区间策略优化（<strong>Trust region policy optimization，TRPO</strong> ，<a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">Schulman, et al., 2015</a>）通过在每次迭代时对策略更新的幅度强制施加KL散度约束来实现上述理念。</p><p>对于离线情况，目标函数衡量的是在遵循一个不同的行为策略 $\beta(a | s)$ 进行采样的同时在状态访问分布以及动作空间上所有的优势：<br>$$<br>\begin{aligned}<br>J(\theta)<br>&amp;= \sum_{s \in \mathcal{S}} \rho^{\pi_{\theta_\text{old}}} \sum_{a \in \mathcal{A}} \big( \pi_\theta(a \vert s) \hat{A}_{\theta_\text{old}}(s, a) \big) &amp; \\<br>&amp;= \sum_{s \in \mathcal{S}} \rho^{\pi_{\theta_\text{old}}} \sum_{a \in \mathcal{A}} \big( \beta(a \vert s) \frac{\pi_\theta(a \vert s)}{\beta(a \vert s)} \hat{A}_{\theta_\text{old}}(s, a) \big) &amp; \scriptstyle{\text{; 重要性采样}} \\<br>&amp;= \mathbb{E}_{s \sim \rho^{\pi_{\theta_\text{old}}}, a \sim \beta} \big[ \frac{\pi_\theta(a \vert s)}{\beta(a \vert s)} \hat{A}_{\theta_\text{old}}(s, a) \big] &amp;<br>\end{aligned}<br>$$<br>其中 $\theta_{\mathrm{old}}$ 是更新之前的策略参数因而对于我们来说是已知的；$\rho^{\pi_{\mathrm{old}}}$ 和<a href="#确定性策略梯度（DPG）">之前</a>的定义相同；$\beta(a | s)$是用来采样轨迹数据的行为策略。注意这里我们使用的是一个估计的优势 $\hat{A}(\cdot)$ 而不是真实的优势 $A(\cdot)$，因为真实的回报往往是未知的。</p><p>对于在线情况，行为策略是 $\pi_{\theta_{\text {old}}}(a | s) :$<br>$$<br>J(\theta) = \mathbb{E}_{s \sim \rho^{\pi_{\theta_\text{old}}}, a \sim \pi_{\theta_\text{old}}} \big[ \frac{\pi_\theta(a \vert s)}{\pi_{\theta_\text{old}}(a \vert s)} \hat{A}_{\theta_\text{old}}(s, a) \big]<br>$$<br>TRPO算法旨在满足<em>置信区间约束</em>下最大化目标函数 $J(\theta)$。该约束强制旧策略与新策略之间的<a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence" target="_blank" rel="external">KL散度</a>小于某个参数 $\delta$：<br>$$<br>\mathbb{E}_{s \sim \rho^{\pi_{\theta_\text{old}}}} [D_\text{KL}(\pi_{\theta_\text{old}}(.\vert s) | \pi_\theta(.\vert s)] \leq \delta<br>$$<br>通过这种方式，当满足这种硬约束时，旧策略和新策略不会差距太大。虽然如此，TRPO可以保证策略一直在往好的方向迭代（很厉害，对吧？）。如果大家感兴趣的话，可以去看看<a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">论文</a>中的证明:)</p><h3 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h3><p>[<a href="https://arxiv.org/pdf/1707.06347.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/ppo1" target="_blank" rel="external">代码</a>]</p><p>鉴于TRPO相对复杂但是我们仍然想要去实现一个类似的约束，近端策略优化（<strong>proximal policy optimization ，PPO</strong>）在实现相似性能的同时通过使用一个截断的替代目标函数来简化TRPO。</p><p>首先，让我们将旧策略和新策略之间的概率比值表示为：<br>$$<br>r(\theta)=\frac{\pi_{\theta}(a | s)}{\pi_{\theta_{\text {old}}}(a | s)}<br>$$<br>接着，TRPO的目标函数（在线）变为：<br>$$<br>J^{\mathrm{TRPO}}(\theta)=\mathbb{E}\left[r(\theta) \hat{A}_{\theta_{\mathrm{old}}}(s, a)\right]<br>$$<br>如果在最大化 $J^{\mathrm{TRPO}}(\theta)$ 时不对 $\theta_{\mathrm{old}}$ 和 $\theta$ 之间的距离加以限制的话，将会因为过大的参数更新幅度以及过大的策略比值而使得更新过程不稳定。PPO通过强行使得 $r(\theta)$ 保持在 $1$ 附近的邻域中，即 $[1-\varepsilon, 1+\varepsilon]$，来施加这一约束。其中 $\varepsilon$ 为超参数。<br>$$<br>J^{\mathrm{CLIP}}(\theta)=\mathbb{E}\left[\min \left(r(\theta) \hat{A}_{\theta_{\mathrm{dd}}}(s, a), \operatorname{clip}(r(\theta), 1-\epsilon, 1+\epsilon) \hat{A}_{\theta_{\mathrm{dd}}}(s, a)\right)\right]<br>$$<br>函数 $\operatorname{clip}(r(\theta), 1-\epsilon, 1+\epsilon)$ 将策略比值约束在 $[1-\varepsilon, 1+\varepsilon]$ 范围内。PPO的目标函数是去取原始值与截断版本的之间的较小值因此我们违背了TRPO最开始的一个理念，即尽可能最大化策略的更新幅度从而得到更好的回报。</p><p>当将PPO算法应用在策略（演员）和值函数（评论家）共享参数的网络结构上时，除了截断回报之外，目标函数上还加上了关于值估计的误差项（红色部分）以及一个熵正则项（蓝色部分）用以鼓励探索。<br>$$<br>J^\text{CLIP’} (\theta) = \mathbb{E} [ J^\text{CLIP} (\theta) - \color{red}{c_1 (V_\theta(s) - V_\text{target})^2} + \color{blue}{c_2 H(s, \pi_\theta(.))} ]<br>$$<br>其中 $c_1$ 和 $c_2$ 为两个常数超参数。</p><p>PPO已经在一系列基准任务上进行了测试并证明可以以更加简单的方式得到可喜的结果。</p><h3 id="ACER"><a href="#ACER" class="headerlink" title="ACER"></a>ACER</h3><p>[<a href="https://arxiv.org/pdf/1611.01224.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/acer" target="_blank" rel="external">代码</a>]</p><p>ACER，带有经验回放的演员-评论家（<strong>Actor-Critic with Experience Replay</strong>，<a href="https://arxiv.org/pdf/1611.01224.pdf" target="_blank" rel="external">Wang, et al., 2017</a>）算法的缩写，是一个带有经验回放的离线演员-评论家算法，它极大地提升了采样有效性并且较低了训练数据间的关联性。A3C基于ACER构建，只不过它是在线方法；ACER是A3C的离线版本。使A3C成为离线方法的主要障碍是如何保证离线估计器的稳定性。ACER提出了三种改进来去克服这个障碍：</p><ul><li>使用 Retrace Q值估计</li><li>使用偏差校正截断重要性权重</li><li>使用更加高效的TRPO算法</li></ul><p><strong>Retrace Q值估计</strong></p><p><a href="http://papers.nips.cc/paper/6538-safe-and-efficient-off-policy-reinforcement-learning.pdf" target="_blank" rel="external">Retrace</a> 是一种离线的基于累积回报的Q值估计算法。它在任意的目标-策略网络对 $(\pi, \beta)$ 下都有一个比较好的收敛性保证并且拥有很好的数据有效性。</p><p>回忆一下TD学习是如何进行预测的：</p><ol><li>计算TD误差：$\delta_{t}=R_{t}+\gamma \mathbb{E}_{a \sim \pi} Q\left(S_{t+1}, a\right)-Q\left(S_{t}, A_{t}\right)$；其中 $r_{t}+\gamma \mathbb{E}_{a \sim \pi} Q\left(s_{t+1}, a\right)$ 被称为”TD目标“。使用期望值 $\mathbb{E}_{a \sim \pi}$ 是因为如果我们遵循当前策略 $\pi$ 的话对于未来时间步我们能做的最好的估计就是累积回报可能是多少。</li><li>通过校正误差往目标移动来更新Q值：$Q\left(S_{t}, A_{t}\right) \leftarrow Q\left(S_{t}, A_{t}\right)+\alpha \delta_{t}$。换句话说，Q的增量更新幅度与TD误差成正比：$\Delta Q\left(S_{t}, A_{t}\right)=\alpha \delta_{t}$。</li></ol><p>当进行离线采样时，我们需要在Q值更新过程中应用重要性采样：<br>$$<br>\Delta Q^{\mathrm{imp}}\left(S_{t}, A_{t}\right)=\gamma^{t} \prod_{1 \leq \tau \leq t} \frac{\pi\left(A_{\tau} | S_{\tau}\right)}{\beta\left(A_{\tau} | S_{\tau}\right)} \delta_{t}<br>$$<br>当我们想象一下重要性权重的连乘会带来多大的方差时就会感觉到这个连乘项有多么可怕了。Retrace Q值估计方法通过截断重要性权重使其不超过某个常数 $c$ 的方式对 $\Delta Q$ 进行修改：<br>$$<br>\Delta Q^{\mathrm{ret}}\left(S_{t}, A_{t}\right)=\gamma^{t} \prod_{1 \leq \tau \leq t} \min \left(c, \frac{\pi\left(A_{\tau} | S_{\tau}\right)}{\beta\left(A_{\tau} | S_{\tau}\right)}\right) \delta_{t}<br>$$<br>ACER使用 $Q^{\mathrm{ret}}$ 作为TD目标通过最小化 $L2$ 误差项来训练评论家：$\left(Q^{\mathrm{ret}}(s, a)-Q(s, a)\right)^{2}$。</p><p><strong>重要性权重截断</strong></p><p>为了减少估计策略梯度 $\hat{g}$ 时产生的高方差，ACER使用一个常数 $c$ 加上一个校正项来截断重要性权重。$\hat{g}_{t}^{\text { acer }}$ 代表 $t$ 时刻的ACER策略梯度。<br>$$<br>\begin{aligned}<br>\hat{g}_t^\text{acer}<br>= &amp; \omega_t \big( Q^\text{ret}(S_t, A_t) - V_{\theta_v}(S_t) \big) \nabla_\theta \ln \pi_\theta(A_t \vert S_t)<br>&amp; \scriptstyle{\text{; 令 }\omega_t=\frac{\pi(A_t \vert S_t)}{\beta(A_t \vert S_t)}} \\<br>= &amp; \color{blue}{\min(c, \omega_t) \big( Q^\text{ret}(S_t, A_t) - V_w(S_t) \big) \nabla_\theta \ln \pi_\theta(A_t \vert S_t)} \\<br>&amp; + \color{red}{\mathbb{E}_{a \sim \pi} \big[ \max(0, \frac{\omega_t(a) - c}{\omega_t(a)}) \big( Q_w(S_t, a) - V_w(S_t) \big) \nabla_\theta \ln \pi_\theta(a \vert S_t) \big]}<br>&amp; \scriptstyle{\text{; 令 }\omega_t (a) =\frac{\pi(a \vert S_t)}{\beta(a \vert S_t)}}<br>\end{aligned}<br>$$<br>其中 $Q_{w}( .)$ 以及 $V_{w}( .)$ 由 $w$ 参数化的评论家预测的动作-值以及状态-值。第一项（蓝色部分）包含了截断重要性权重。截断操作促进方差缩减，减去状态-值 $V_{w}( .)$ 作为基准进一步加强了方差缩减的效果。第二项（红色部分）进行了校正使得上述方差估计为无偏估计。</p><p><strong>高效TRPO</strong></p><p>此外，ACER采用TRPO的思想，但通过一个小的调整使其具有更高的计算效率：ACER不再去计算当前策略与更新一步之后的新策略之间的KL散度，而是去维护一个历史策略的运行平均（running average）值并且强制新策略不会偏离这个平均策略太远。</p><p>ACER论文信息量很大，包含很多公式。但是在事先了解了TD学习，Q学习，重要性采样和TRPO之后，你会发现这篇论文会稍微变得容易理解一些:)</p><h3 id="ACKTR"><a href="#ACKTR" class="headerlink" title="ACKTR"></a>ACKTR</h3><p>[<a href="https://arxiv.org/pdf/1708.05144.pdf" target="_blank" rel="external">论文</a>|<a href="https://github.com/openai/baselines/tree/master/baselines/acktr" target="_blank" rel="external">代码</a>]</p><p>Kronecker因子化置信区间的演员-评论家算法（<strong>Actor-Critic using Kronecker-factored Trust Region，ACKTR</strong>，<a href="https://arxiv.org/pdf/1708.05144.pdf" target="_blank" rel="external">Yuhuai Wu, et al., 2017</a>）使用Kronecker因子化曲率估计（<a href="https://arxiv.org/pdf/1503.05671.pdf" target="_blank" rel="external">K-FAC</a>）同时进行演员以及评论家的梯度更新。K-FAC对自然梯度的计算进行了改进，这与我们的标准梯度有很大不同。<a href="http://kvfrans.com/a-intuitive-explanation-of-natural-gradient-descent/" target="_blank" rel="external">这里</a>有一个对于自然梯度很好很直观的解释。</p><p>如果要用一句话总结的话：</p><blockquote><p>“我们首先考虑所有参数组合，这些参数组合导致新网络与旧网络保持恒定的KL差异。该常数值可以视为步长或学习速率。在所有这些可能的组合中，我们选择最小化损失函数的组合。“</p></blockquote><p>我在这里列出了ACTKR主要是为了这篇文章的完整性，但我不会深入到细节部分，因为它涉及很多关于自然梯度和优化方法的理论知识。如果有兴趣，请在阅读ACKTR论文之前查看这些文章/帖子：</p><ul><li>Amari. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.452.7280&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Natural Gradient Works Efficiently in Learning</a>. 1998</li><li>Kakade. <a href="https://papers.nips.cc/paper/2073-a-natural-policy-gradient.pdf" target="_blank" rel="external">A Natural Policy Gradient</a>. 2002</li><li><a href="http://kvfrans.com/a-intuitive-explanation-of-natural-gradient-descent/" target="_blank" rel="external">A intuitive explanation of natural gradient descent</a></li><li><a href="https://en.wikipedia.org/wiki/Kronecker_product" target="_blank" rel="external">Wiki: Kronecker product</a></li><li>Martens &amp; Grosse. <a href="http://proceedings.mlr.press/v37/martens15.pdf" target="_blank" rel="external">Optimizing neural networks with kronecker-factored approximate curvature.</a> 2015.</li></ul><p>以下是K-FAC论文的高度概括（译者注：以下为论文原文，因此不做翻译）：</p><blockquote><p>“This approximation is built in two stages. In the first, the rows and columns of the Fisher are divided into groups, each of which corresponds to all the weights in a given layer, and this gives rise to a block-partitioning of the matrix. These blocks are then approximated as Kronecker products between much smaller matrices, which we show is equivalent to making certain approximating assumptions regarding the statistics of the network’s gradients.</p><p>In the second stage, this matrix is further approximated as having an inverse which is either block-diagonal or block-tridiagonal. We justify this approximation through a careful examination of the relationships between inverse covariances, tree-structured graphical models, and linear regression. Notably, this justification doesn’t apply to the Fisher itself, and our experiments confirm that while the inverse Fisher does indeed possess this structure (approximately), the Fisher itself does not.”</p></blockquote><h3 id="SAC"><a href="#SAC" class="headerlink" title="SAC"></a>SAC</h3><p>[<a href="https://arxiv.org/abs/1801.01290" target="_blank" rel="external">论文</a>|<a href="https://github.com/haarnoja/sac" target="_blank" rel="external">代码</a>]</p><p>软演员-评论家算法（<strong>Soft Actor-Critic，SAC</strong>，<a href="https://arxiv.org/abs/1801.01290" target="_blank" rel="external">Haarnoja et al. 2018</a>）将策略的熵度量纳入回报函数中用以鼓励探索：我们希望学习到一种尽可能随机行动的策略，同时仍然能够在任务中完成目标。它是一个遵循最大熵强化学习框架的离线演员-评论家模型。一个先例工作是<a href="https://arxiv.org/abs/1702.08165" target="_blank" rel="external">软Q学习</a>。</p><p>SAC算法中的三个关键部分如下：</p><ul><li>包含分离策略网络以及值函数网络的<a href="#演员-评论家算法">演员-评论家</a>架构；</li><li>离线形式使其能够复用历史收集的数据从而实现高采样有效性；</li><li>熵最大化以使得训练稳定并鼓励探索。</li></ul><p>策略的训练目标是同时最大化期望累积回报以及策略的熵度量：<br>$$<br>J(\theta)=\sum_{t=1}^{T} \mathbb{E}_{\left(s_{t}, a_{t}\right) \sim \rho_{\pi_{\theta}}}\left[r\left(s_{t}, a_{t}\right)+\alpha \mathcal{H}\left(\pi_{\theta}\left( . | s_{t}\right)\right)\right]<br>$$</p><p>其中 $\mathcal{H}( .)$ 表示熵度量，$\alpha$ 被称为<em>热度（temperature）</em>参数用以控制熵正则项的重要度。熵最大化使得策略再训练过程中可以（1）进行更多的探索更多和（2）捕获近似最优策略的多种模式（例如，如果存在似乎同样好的多种选项，则策略应该为每个选项分配以相同的概率被选中）。</p><p>准确地说，SAC旨在学习三个函数：</p><ul><li>由 $\theta$ 参数化的策略 $\pi_{\theta}$。</li><li>由 $w$ 参数化的软Q值函数 $Q_w$。</li><li>由 $\psi$ 参数化的软状态-值函数 $V_{\psi}$ ；理论上来说我们可以通过 $Q$ 以及 $\pi$ 来推导出 $V$，但是在实际情况下，显式对状态-值函数建模可以使得训练过程更加稳定。</li></ul><p>软Q值以及软状态值分别定义如下：<br>$$<br>\begin{aligned}<br>Q(s_t, a_t) &amp;= r(s_t, a_t) + \gamma \mathbb{E}_{s_{t+1} \sim \rho_{\pi}(s)} [V(s_{t+1})] &amp; \text{; 根据贝尔曼方程}\\<br>\text{where }V(s_t) &amp;= \mathbb{E}_{a_t \sim \pi} [Q(s_t, a_t) - \alpha \log \pi(a_t \vert s_t)] &amp; \text{; 软状态值函数}<br>\end{aligned}<br>$$</p><p>$$<br>\text{Thus, } Q(s_t, a_t) = r(s_t, a_t) + \gamma \mathbb{E}_{(s_{t+1}, a_{t+1}) \sim \rho_{\pi}} [Q(s_{t+1}, a_{t+1}) - \alpha \log \pi(a_{t+1} \vert s_{t+1})]<br>$$</p><p>$\rho_{\pi}(s)$ 和 $\rho_{\pi}(s, a)$ 分别表示由策略 $\pi(a\vert s)$ 导出的状态分布的状态以及状态-动作边际分布；<a href="#离线策略梯度（Off-Policy Policy Gradient）">DPG算法</a>部分有类似的定义。</p><p>软状态值函数通过最小化均方误差来训练：<br>$$<br>\begin{aligned}<br>J_V(\psi) &amp;= \mathbb{E}_{s_t \sim \mathcal{D}} [\frac{1}{2} \big(V_\psi(s_t) - \mathbb{E}[Q_w(s_t, a_t) - \log \pi_\theta(a_t \vert s_t)] \big)^2] \\<br>\text{其中梯度为: }\nabla_\psi J_V(\psi) &amp;= \nabla_\psi V_\psi(s_t)\big( V_\psi(s_t) - Q_w(s_t, a_t) + \log \pi_\theta (a_t \vert s_t) \big)<br>\end{aligned}<br>$$<br>其中 $\mathcal{D}$ 代表经验回放缓冲。</p><p>软Q值函数通过最小化软贝尔曼残差来训练：<br>$$<br>\begin{aligned}<br>J_Q(w) &amp;= \mathbb{E}_{(s_t, a_t) \sim \mathcal{D}} [\frac{1}{2}\big( Q_w(s_t, a_t) - (r(s_t, a_t) + \gamma \mathbb{E}_{s_{t+1} \sim \rho_\pi(s)}[V_{\bar{\psi}}(s_{t+1})]) \big)^2] \\<br>\text{其中梯度为: } \nabla_w J_Q(w) &amp;= \nabla_w Q_w(s_t, a_t) \big( Q_w(s_t, a_t) - r(s_t, a_t) - \gamma V_{\bar{\psi}}(s_{t+1})\big)<br>\end{aligned}<br>$$<br>其中 $\bar{\psi}$ 代表目标值函数，它是个指数移动平均值（exponential moving average）或者只是采用一种“硬”方式进行周期更新。就像<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#deep-q-network" target="_blank" rel="external">DQN</a>中目标Q网络中的参数一样，为了使得训练过程更加稳定。</p><p>SAC通过最小化如下<a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence" target="_blank" rel="external">KL散度</a>来去更新策略：<br>$$<br>\begin{aligned}<br>\pi_\text{new}<br>&amp;= \arg\min_{\pi’ \in \Pi} D_\text{KL} \Big( \pi’(.\vert s_t) | \frac{\exp(Q^{\pi_\text{old}}(s_t, .))}{Z^{\pi_\text{old}}(s_t)} \Big) \[6pt]<br>&amp;= \arg\min_{\pi’ \in \Pi} D_\text{KL} \big( \pi’(.\vert s_t) | \exp(Q^{\pi_\text{old}}(s_t, .) - \log Z^{\pi_\text{old}}(s_t)) \big) \[6pt]<br>\text{目标函数: } J_\pi(\theta) &amp;= \nabla_\theta D_\text{KL} \big( \pi_\theta(. \vert s_t) | \exp(Q_w(s_t, .) - \log Z_w(s_t)) \big) \[6pt]<br>&amp;= \mathbb{E}_{a_t\sim\pi} \Big[ - \log \big( \frac{\exp(Q_w(s_t, a_t) - \log Z_w(s_t))}{\pi_\theta(a_t \vert s_t)} \big) \Big] \[6pt]<br>&amp;= \mathbb{E}_{a_t\sim\pi} [ \log \pi_\theta(a_t \vert s_t) - Q_w(s_t, a_t) + \log Z_w(s_t) ]<br>\end{aligned}<br>$$<br>其中 $\prod$ 是潜在策略的集合，我们可以将这些策略建模为容易处理的形式；例如，$\prod$ 可以是高斯混合分布族，虽然建模时复杂度较高但是具有很强的表达能力并且易于处理。$Z^{\pi_\text{old}}(s_t)$ 是用于正则化分布的配分函数。它一般是很难处理的但所幸对于梯度值没有影响。最小化 $J_{\pi}(\theta)$ 的方式依赖于 $\prod$ 的选择。</p><p>一旦我们为软动作-值，软状态值和策略网络定义了目标函数和梯度，软演员-评论家算法就很简单了：</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-88808043234e89e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6. 软演员-评论家算法. 图片来源：[原始论文](https://arxiv.org/abs/1801.01290)"></p><h3 id="带有自动热度调整的软演员-评论家算法"><a href="#带有自动热度调整的软演员-评论家算法" class="headerlink" title="带有自动热度调整的软演员-评论家算法"></a>带有自动热度调整的软演员-评论家算法</h3><p>[<a href="https://arxiv.org/abs/1812.05905" target="_blank" rel="external">论文</a>|<a href="https://github.com/rail-berkeley/softlearning" target="_blank" rel="external">代码</a>]</p><p>SAC算法对于热度参数十分敏感。不幸的是，调整热度参数是一件很困难的事情。因为在随着策略由于训练变得更优的过程中或者在不同任务中进行训练时熵都会出现不可预测的变化。在SAC算法针对上述问题的改进可以建模为如下带约束的优化问题：在最大化期望累积回报的同时，策略应满足最小熵约束：<br>$$<br>\max _{\pi_{0}, \ldots, \pi_{T}} \mathbb{E}\left[\sum_{t=0}^{T} r\left(s_{t}, a_{t}\right)\right] \text { s.t. } \forall t, \mathcal{H}\left(\pi_{t}\right) \geq \mathcal{H}_{0}<br>$$<br>其中 $\mathcal{H}_{0}$ 表示预定义的最小策略熵阈值。</p><p>其中期望收益 $\mathbb{E}\left[\sum_{t=0}^{T} r\left(s_{t}, a_{t}\right)\right]$ 可以分解为每一时间步回报的和。因为在时刻 $t$ 的策略 $\pi_t$ 不会影响到之前时刻的策略 $\pi_{t-1}$，我们可以从后往前逐步最大化收益——这其实就是<strong>动态规划</strong>了。<br>$$<br>\underbrace{\max_{\pi_0} \Big( \mathbb{E}[r(s_0, a_0)]+ \underbrace{\max_{\pi_1} \Big(\mathbb{E}[…] + \underbrace{\max_{\pi_T} \mathbb{E}[r(s_T, a_T)]}_\text{第一步最大化} \Big)}_\text{第二步但也是最后一步最大化} \Big)}_\text{最后一步最大化}<br>$$<br>其中 $\gamma=1$。</p><p>我们从最后一个时间步 $T$ 开始最大化：<br>$$<br>\mathbb{E}_{\left(s_{T}, a_{T}\right) \sim \rho_{\pi}}\left[r\left(s_{T}, a_{T}\right)\right] \text { s.t. } \mathcal{H}\left(\pi_{T}\right)-\mathcal{H}_{0} \geq 0<br>$$<br>首先，我们定义以下一些函数：<br>$$<br>\begin{aligned}<br>h(\pi_T) &amp;= \mathcal{H}(\pi_T) - \mathcal{H}_0 = \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [-\log \pi_T(a_T\vert s_T)] - \mathcal{H}_0\\<br>f(\pi_T) &amp;= \begin{cases}<br>\mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) ], &amp; \text{if }h(\pi_T) \geq 0 \\<br>-\infty, &amp; \text{otherwise}<br>\end{cases}<br>\end{aligned}<br>$$<br>因而优化问题就转变为如下形式：<br>$$<br>f\left(\pi_{T}\right) \text { s.t. } h\left(\pi_{T}\right) \geq 0<br>$$<br>为了解决带有不等式约束的最大化优化问题，我们可以构建一个带有拉格朗日乘子（也被称为“对偶变量”） $\alpha_{T}$ 的<a href="https://cs.stanford.edu/people/davidknowles/lagrangian_duality.pdf" target="_blank" rel="external">拉格朗日表达式</a>：<br>$$<br>L\left(\pi_{T}, \alpha_{T}\right)=f\left(\pi_{T}\right)+\alpha_{T} h\left(\pi_{T}\right)<br>$$<br>考虑如下情况，在给定策略 $\pi_{T}$ 的情况下，我们尝试去找到最小化 $L\left(\pi_{T}, \alpha_{T}\right)$ 的 $\alpha_{T}$ 值，</p><ul><li>如果约束被满足，即 $h\left(\pi_{T}\right) \geq 0$ ，那么因为我们无法通过 $\alpha_T$ 控制 $f\left(\pi_{T}\right)$ 的值因此最好将其设置为0（<strong>译者注：这里我有些无法理解，如果要最小化，那么当 $h\left(\pi_{T}\right) \geq 0$ 时 $\alpha_T$ 为负数应该会使得目标函数更小？</strong>）。因而，$L\left(\pi_{T}, 0\right)=f\left(\pi_{T}\right)$。</li><li>如果约束被违背了，即 $h\left(\pi_{T}\right)&lt;0$，我们可以通过令 $\alpha_{T} \rightarrow \infty$ 来使得 $L\left(\pi_{T}, \alpha_{T}\right) \rightarrow-\infty$。因而 $L\left(\pi_{T}, \infty\right)=-\infty=f\left(\pi_{T}\right)$。</li></ul><p>无论哪种情况，我们都可以得到如下等式：<br>$$<br>f\left(\pi_{T}\right)=\min _{\alpha_{T} \geq 0} L\left(\pi_{T}, \alpha_{T}\right)<br>$$<br>同时，我们想要去最大化$ f\left(\pi_{T}\right)$：<br>$$<br>\max _{\pi_{T}} f\left(\pi_{T}\right)=\min _{\alpha_{T} \geq 0} \max _{\pi_{T}} L\left(\pi_{T}, \alpha_{T}\right)<br>$$<br>因此，为了最大化 $f\left(\pi_{T}\right)$，其对应的对偶问题罗列如下。注意为了保证 $\max _{\pi_{T}} f\left(\pi_{T}\right)$ 是一个良定的操作（即 $f\left(\pi_{T}\right)$ 不为 $-\infty$），约束必须要被满足。<br>$$<br>\begin{aligned}<br>\max_{\pi_T} \mathbb{E}[ r(s_T, a_T) ]<br>&amp;= \max_{\pi_T} f(\pi_T) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} L(\pi_T, \alpha_T) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} f(\pi_T) + \alpha_T h(\pi_T) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) ] + \alpha_T ( \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [-\log \pi_T(a_T\vert s_T)] - \mathcal{H}_0) \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) - \alpha_T \log \pi_T(a_T\vert s_T)] - \alpha_T \mathcal{H}_0 \\<br>&amp;= \min_{\alpha_T \geq 0} \max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) + \alpha_T \mathcal{H}(\pi_T) - \alpha_T \mathcal{H}_0 ]<br>\end{aligned}<br>$$<br>我们可以迭代地计算最优的 $\pi_T$ 以及 $\alpha_T$。首先给定目前的 $\alpha_{T}$，通过最大化 $L\left(\pi_{T}^{<em>}, \alpha_{T}\right)$ 来得到最优的策略 $\pi_{T}^{</em>}$。然后将 $\pi_{T}^{<em>}$ 代入去最小化 $L\left(\pi_{T}^{</em>}, \alpha_{T}\right)$ 来计算 $\alpha_{T}^{<em>}$。想象一下我们用一个神经网络来表示策略，用另一个网络来表示热度参数，这个迭代过程就与训练演员-评论家算法时更新两者的网络参数比较类似了。<br>$$<br>\begin{aligned}<br>\pi^{</em>}_T<br>&amp;= \arg\max_{\pi_T} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi}} [ r(s_T, a_T) + \alpha_T \mathcal{H}(\pi_T) - \alpha_T \mathcal{H}_0 ] \\<br>\color{blue}{\alpha^{<em>}_T}<br>&amp;\color{blue}{=} \color{blue}{\arg\min_{\alpha_T \geq 0} \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi^{</em>}}} [\alpha_T \mathcal{H}(\pi^{*}_T) - \alpha_T \mathcal{H}_0 ]}<br>\end{aligned}<br>$$</p><p>$$<br>\text{因而, }\max_{\pi_T} \mathbb{E} [ r(s_T, a_T) ]<br>= \mathbb{E}_{(s_T, a_T) \sim \rho_{\pi^{<em>}}} [ r(s_T, a_T) + \alpha^{</em>}_T \mathcal{H}(\pi^{<em>}_T) - \alpha^{</em>}_T \mathcal{H}_0 ]<br>$$</p><p>现在，让我们回到软Q值函数：<br>$$<br>\begin{aligned}<br>Q_{T-1}(s_{T-1}, a_{T-1})<br>&amp;= r(s_{T-1}, a_{T-1}) + \mathbb{E} [Q(s_T, a_T) - \alpha_T \log \pi(a_T \vert s_T)] \\<br>&amp;= r(s_{T-1}, a_{T-1}) + \mathbb{E} [r(s_T, a_T)] + \alpha_T \mathcal{H}(\pi_T) \\<br>Q_{T-1}^{<em>}(s_{T-1}, a_{T-1})<br>&amp;= r(s_{T-1}, a_{T-1}) + \max_{\pi_T} \mathbb{E} [r(s_T, a_T)] + \alpha_T^{</em>} \mathcal{H}(\pi^{<em>}_T) &amp; \text{; 代入最优策略 }\pi_T^{</em>}<br>\end{aligned}<br>$$<br>因此，当我们进一步退回到 $T-1$ 时间步时，期望收益如下：<br>$$<br>\begin{aligned}<br>&amp;\max_{\pi_{T-1}}\Big(\mathbb{E}[r(s_{T-1}, a_{T-1})] + \max_{\pi_T} \mathbb{E}[r(s_T, a_T] \Big) \\<br>&amp;= \max_{\pi_{T-1}} \Big( Q^{<em>}_{T-1}(s_{T-1}, a_{T-1}) - \alpha^{</em>}_T \mathcal{H}(\pi^{<em>}_T) \Big) &amp; \text{; 需 } \mathcal{H}(\pi_{T-1}) - \mathcal{H}_0 \geq 0 \\<br>&amp;= \min_{\alpha_{T-1} \geq 0} \max_{\pi_{T-1}} \Big( Q^{</em>}_{T-1}(s_{T-1}, a_{T-1}) - \alpha^{<em>}_T \mathcal{H}(\pi^{</em>}_T) + \alpha_{T-1} \big( \mathcal{H}(\pi_{T-1}) - \mathcal{H}_0 \big) \Big) &amp; \text{; 对偶问题} \\<br>&amp;= \min_{\alpha_{T-1} \geq 0} \max_{\pi_{T-1}} \Big( Q^{<em>}_{T-1}(s_{T-1}, a_{T-1}) + \alpha_{T-1} \mathcal{H}(\pi_{T-1}) - \alpha_{T-1}\mathcal{H}_0 \Big) - \alpha^{</em>}_T \mathcal{H}(\pi^{<em>}_T)<br>\end{aligned}<br>$$<br>与之前类似，我们有：<br>$$<br>\begin{aligned}<br>\pi^{</em>}_{T-1} &amp;= \arg\max_{\pi_{T-1}} \mathbb{E}_{(s_{T-1}, a_{T-1}) \sim \rho_\pi} [Q^{<em>}_{T-1}(s_{T-1}, a_{T-1}) + \alpha_{T-1} \mathcal{H}(\pi_{T-1}) - \alpha_{T-1} \mathcal{H}_0 ] \\<br>\color{green}{\alpha^{</em>}_{T-1}} &amp;\color{green}{=} \color{green}{\arg\min_{\alpha_{T-1} \geq 0} \mathbb{E}_{(s_{T-1}, a_{T-1}) \sim \rho_{\pi^{<em>}}} [ \alpha_{T-1} \mathcal{H}(\pi^{</em>}_{T-1}) - \alpha_{T-1}\mathcal{H}_0 ]}<br>\end{aligned}<br>$$<br>绿色部分更新 $\alpha_{T-1}^{<em>}$ 的公式与上面蓝色部分更新 $\alpha_{T}^{</em>}$ 的公式具有相同的形式。通过不断重复上述过程，我们可以通过最小化相同的目标函数（译者注：这里的目标函数中的策略不是最优的）来学习每个时间步的最优热度参数：<br>$$<br>J(\alpha)=\mathbb{E}_{a_{t} \sim \pi_{t}}\left[-\alpha \log \pi_{t}\left(a_{t} | \pi_{t}\right)-\alpha \mathcal{H}_{0}\right]<br>$$<br>除了根据最小化 $J(\alpha)$ 来显式地学习 $\alpha$ 之外本部分算法与SAC算法没有任何区别（见图7）。</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-b6a8d9fdca4d146d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7. 带有自动热度调整的软演员-评论家算法. 图片来源：[原始论文](https://arxiv.org/abs/1812.05905)"></p><h3 id="TD3"><a href="#TD3" class="headerlink" title="TD3"></a>TD3</h3><p>[<a href="https://arxiv.org/abs/1802.09477" target="_blank" rel="external">论文</a>|<a href="https://github.com/sfujim/TD3" target="_blank" rel="external">代码</a>]</p><p>众所周知Q学习一直存在对值函数过估计的问题。过估计会随着训练过程不断传播最终会对策略学习造成负面影响。这个问题促使<a href="https://papers.nips.cc/paper/3964-double-q-learning" target="_blank" rel="external">双Q学习</a>以及<a href="https://arxiv.org/abs/1509.06461" target="_blank" rel="external">双DQN</a>的提出：通过使用两个值网络将动作选择和Q值更新进行解耦。</p><p>双延迟深度确定性策略梯度方法（<strong>Twin Delayed Deep Deterministic，TD3</strong>; <a href="https://arxiv.org/abs/1802.09477" target="_blank" rel="external">Fujimoto et al., 2018</a>）在<a href="#深度确定性策略梯度 （DDPG）">DDPG</a>算法的基础上应用了很多新的改进从而防止值函数的过估计现象：</p><p>（1）<strong>截断双Q学习</strong>：在双Q学习中，动作选择以及Q值估计是通过两个独立的网络完成的。在DDPG中，给定两个确定性演员 $\left(\mu_{\theta_{1}}, \mu_{\theta_{2}}\right)$ 以及两个对应的评论家 $\left(Q_{w_{1}}, Q_{w_{2}}\right)$，双Q学习的贝尔曼目标如下：<br>$$<br>\begin{aligned}<br>y_1 &amp;= r + \gamma Q_{w_2}(s’, \mu_{\theta_1}(s’))\\<br>y_2 &amp;= r + \gamma Q_{w_1}(s’, \mu_{\theta_2}(s’))<br>\end{aligned}<br>$$<br>然而，由于策略变化过于缓慢，使得两个演员网络会过于相似从而很难做出完全独立的决策。<em>截断双Q学习</em>使用两者中的最小估计，从而倾向于使用难以通过训练传播的欠估计偏差：<br>$$<br>\begin{aligned}<br>y_1 &amp;= r + \gamma \min_{i=1,2}Q_{w_i}(s’, \mu_{\theta_1}(s’))\\<br>y_2 &amp;= r + \gamma \min_{i=1,2} Q_{w_i}(s’, \mu_{\theta_2}(s’))<br>\end{aligned}<br>$$<br>（2）<strong>延迟更新目标和策略网络</strong>：在<a href="#演员-评论家算法（Actor-Critic）">演员-评论家</a>模型中，策略与值函数的更新深度耦合：当策略较差时值函数的估计将会由于过估计问题发散；相反如果值函数估计不准确又会使得策略变差。</p><p>为了减小训练过程中的方差，TD3以一个相对于Q值函数更低的更新频率来更新策略。策略网络的参数将会保持不变直至值函数误差经过多轮迭代后足够小。这个想法类似于定期更新的目标网络如何在<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#dqn" target="_blank" rel="external">DQN</a>中作为稳定的目标存在。</p><p>（3）<strong>目标策略平滑：</strong>考虑到确定性策略会过拟合到值函数的峰值上，TD3在值函数上引入了平滑正则化策略。在所选动作中添加少量经过截断的随机噪声，并对小批量数据进行平均。<br>$$<br>\begin{aligned}<br>y &amp;= r + \gamma Q_w (s’, \mu_{\theta}(s’) + \epsilon) &amp; \\<br>\epsilon &amp;\sim \text{clip}(\mathcal{N}(0, \sigma), -c, +c) &amp; \scriptstyle{\text{ ; 截断的随机噪声}}<br>\end{aligned}<br>$$<br>这种做法模仿了<a href="https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html#sarsa-on-policy-td-control" target="_blank" rel="external">SARSA</a>参数更新的思想，并强制相似的动作应具有相似的动作-值。</p><p>下面是最终的算法框架：</p><p><img src="https://upload-images.jianshu.io/upload_images/13653853-bb3945372d7d7578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8. TD3算法. 图片来源：[原始论文](https://arxiv.org/abs/1802.09477)"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>研究完上面的所有算法后，我列出了一些似乎在它们中很常见的基础构件或原则：</p><ul><li>尽量减少方差并保持偏差不变以稳定训练过程。</li><li>离线方法可以带来更高的探索度以及更高的数据有效性。</li><li>经验回放（训练数据从一个回放缓存中采样）。</li><li>目标网络要么周期更新要么比正在学习的网络更慢地更新。</li><li>批标准化。</li><li>带有熵正则的回报函数</li><li>演员和评论家可以共享网络的低层参数然后两个输出头分别为策略和值函数。</li><li>可以学习一个确定性的策略而不是一个随即策略。</li><li>在策略更新上施加距离约束。</li><li>新的优化方法（例如K-FAC）。</li><li>最大化策略的熵度量从而鼓励探索。</li><li>避免对值函数过估计。</li><li>等等</li></ul><p>如果你在这篇文章中发现了一些错误或描述不当的地方，不要犹豫，马上通过邮件<em>[lilian dot wengweng at gmail dot com]</em>联系我，我很乐意及时改正！</p><p>下篇文章再见:D</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] jeremykun.com <a href="https://jeremykun.com/2015/04/06/markov-chain-monte-carlo-without-all-the-bullshit/" target="_blank" rel="external">Markov Chain Monte Carlo Without all the Bullshit</a></p><p>[2] Richard S. Sutton and Andrew G. Barto. <a href="http://incompleteideas.net/book/bookdraft2017nov5.pdf" target="_blank" rel="external">Reinforcement Learning: An Introduction; 2nd Edition</a>. 2017.</p><p>[3] John Schulman, et al. <a href="https://arxiv.org/pdf/1506.02438.pdf" target="_blank" rel="external">“High-dimensional continuous control using generalized advantage estimation.”</a> ICLR 2016.</p><p>[4] Thomas Degris, Martha White, and Richard S. Sutton. <a href="https://arxiv.org/pdf/1205.4839.pdf" target="_blank" rel="external">“Off-policy actor-critic.”</a> ICML 2012.</p><p>[5] timvieira.github.io <a href="http://timvieira.github.io/blog/post/2014/12/21/importance-sampling/" target="_blank" rel="external">Importance sampling</a></p><p>[6] Mnih, Volodymyr, et al. <a href="https://arxiv.org/abs/1602.01783" target="_blank" rel="external">“Asynchronous methods for deep reinforcement learning.”</a> ICML. 2016.</p><p>[7] David Silver, et al. <a href="https://hal.inria.fr/file/index/docid/938992/filename/dpg-icml2014.pdf" target="_blank" rel="external">“Deterministic policy gradient algorithms.”</a> ICML. 2014.</p><p>[8] Timothy P. Lillicrap, et al. <a href="https://arxiv.org/pdf/1509.02971.pdf" target="_blank" rel="external">“Continuous control with deep reinforcement learning.”</a> arXiv preprint arXiv:1509.02971 (2015).</p><p>[9] Ryan Lowe, et al. <a href="https://arxiv.org/pdf/1706.02275.pdf" target="_blank" rel="external">“Multi-agent actor-critic for mixed cooperative-competitive environments.”</a>NIPS. 2017.</p><p>[10] John Schulman, et al. <a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="external">“Trust region policy optimization.”</a> ICML. 2015.</p><p>[11] Ziyu Wang, et al. <a href="https://arxiv.org/pdf/1611.01224.pdf" target="_blank" rel="external">“Sample efficient actor-critic with experience replay.”</a> ICLR 2017.</p><p>[12] Rémi Munos, Tom Stepleton, Anna Harutyunyan, and Marc Bellemare. <a href="http://papers.nips.cc/paper/6538-safe-and-efficient-off-policy-reinforcement-learning.pdf" target="_blank" rel="external">“Safe and efficient off-policy reinforcement learning”</a> NIPS. 2016.</p><p>[13] Yuhuai Wu, et al. <a href="https://arxiv.org/pdf/1708.05144.pdf" target="_blank" rel="external">“Scalable trust-region method for deep reinforcement learning using Kronecker-factored approximation.”</a> NIPS. 2017.</p><p>[14] kvfrans.com <a href="http://kvfrans.com/a-intuitive-explanation-of-natural-gradient-descent/" target="_blank" rel="external">A intuitive explanation of natural gradient descent</a></p><p>[15] Sham Kakade. <a href="https://papers.nips.cc/paper/2073-a-natural-policy-gradient.pdf" target="_blank" rel="external">“A Natural Policy Gradient.”</a>. NIPS. 2002.</p><p>[16] <a href="https://danieltakeshi.github.io/2017/03/28/going-deeper-into-reinforcement-learning-fundamentals-of-policy-gradients/" target="_blank" rel="external">“Going Deeper Into Reinforcement Learning: Fundamentals of Policy Gradients.”</a> - Seita’s Place, Mar 2017.</p><p>[17] <a href="https://danieltakeshi.github.io/2017/04/02/notes-on-the-generalized-advantage-estimation-paper/" target="_blank" rel="external">“Notes on the Generalized Advantage Estimation Paper.”</a> - Seita’s Place, Apr, 2017.</p><p>[18] Gabriel Barth-Maron, et al. <a href="https://arxiv.org/pdf/1804.08617.pdf" target="_blank" rel="external">“Distributed Distributional Deterministic Policy Gradients.”</a> ICLR 2018 poster.</p><p>[19] Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. <a href="https://arxiv.org/pdf/1801.01290.pdf" target="_blank" rel="external">“Soft Actor-Critic: Off-Policy Maximum Entropy Deep Reinforcement Learning with a Stochastic Actor.”</a> arXiv preprint arXiv:1801.01290 (2018).</p><p>[20] Scott Fujimoto, Herke van Hoof, and Dave Meger. <a href="https://arxiv.org/abs/1802.09477" target="_blank" rel="external">“Addressing Function Approximation Error in Actor-Critic Methods.”</a> arXiv preprint arXiv:1802.09477 (2018).</p><p>[21] Tuomas Haarnoja, et al. <a href="https://arxiv.org/abs/1812.05905" target="_blank" rel="external">“Soft Actor-Critic Algorithms and Applications.”</a> arXiv preprint arXiv:1812.05905 (2018).</p><p>[22] David Knowles. <a href="https://cs.stanford.edu/people/davidknowles/lagrangian_duality.pdf" target="_blank" rel="external">“Lagrangian Duality for Dummies”</a> Nov 13, 2010.</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/06/Guided-Policy-Search-GPS/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/04/06/Guided-Policy-Search-GPS/" itemprop="url">Guided Policy Search(GPS)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-06T03:18:32+08:00">2019-04-06 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/04/06/Guided-Policy-Search-GPS/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/04/06/Guided-Policy-Search-GPS/" itemprop="commentsCount"></span> </a></span><span id="/2019/04/06/Guided-Policy-Search-GPS/" class="leancloud_visitors" data-flag-title="Guided Policy Search(GPS)"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p><em>一篇因为各种突发状况断断续续写了将近两周的文章 = =</em></p><hr><p>这篇博客将介绍GPS方法，GPS方法是由强化学习大牛Sergey Levine（在最近的ICLR 2019发表了13篇论文）于2013年提出的，目前被作为基础算法广泛应用于各种强化学习任务中。其出发点在于纯粹的策略梯度方法在更新参数时不会用到环境模型因而属于一种无模型强化学习算法，所谓成也萧何败也萧何，虽然这使得策略梯度方法通用性很好，但是由于没有利用到任何环境的内在属性，使得其训练只能完全依靠试错，效率较低。</p><p>基于模型的路径优化算法（例如前面博客里提到的iLQR）方法，能够充分利用环境模型，从而在利用较少训练样本的情况下即可使得算法收敛到局部最优解。但是路径优化算法是一个开环方法，在随机环境下效果较差，虽然能够通过使用MPC方法（基本思想是每次只执行路径优化算法输出的第一个时间步的动作）来增加算法的稳定性，但是执行时耗时较长无法适用于实时任务。但是策略梯度方法是一个闭环方法，因而其对于随即环境的适应能力以及执行耗时上都能达到很好的效果。因而一个直观的想法是，能不能将两者结合起来，用路径优化算法的输出结果来指导策略梯度方法的训练过程，从而提升策略梯度方法的效率呢？GPS方法正是基于这种思想提出的。</p><p>本文主要对早期GPS的三篇论文进行了总结（还包括了一些其他论文的相关结论），具体请参阅文末的参考文献。文章的结构如下：第一部分将会对最原始的GPS方法进行介绍，第二部分将会介绍一个改进版本。注意，这两种版本的GPS算法都必须事先已知环境模型。第三部分将介绍一个在未知环境模型（需要在算法训练的过程中对环境模型进行局部估计）的情况下也能够使用的GPS算法。以上三种GPS算法均属于基于模型的强化学习算法（以后我将专门写一篇文章来介绍基于模型的强化学习算法）。为了方便起见，我将最原始的GPS算法记为GPS-V1(ICML2013)[^2]，改进版记为GPS-V2(ICML2014)[^3]，最后一个版本记为GPS-V3(NIPS2014)[^4]。</p><h2 id="GPS-V1"><a href="#GPS-V1" class="headerlink" title="GPS-V1"></a>GPS-V1</h2><p>原始版本的GPS算法基本思想是首先使用路径优化算法产生一些训练数据并加入训练集中用以指导后续策略梯度方法的训练。但是策略梯度方法是在线策略算法，只能使用当前策略采样得到的数据来估计梯度从而更新参数。为了能够使用其他策略采样的数据，这里必须要使用一种技术：重要性采样。在这里我首先跑一下题来介绍一下重要性采样。</p><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><p>对于一个函数$f$以及一个概率分布$P$，我们想要计算如下统计量：<br>$$<br>\mathbf{E}_{P(X)}[f(X)]=\int_{x}P(x)f(x)dx.<br>$$<br>我们知道，一般估计一个期望值的方法是从变量从属的概率分布中进行采样，然后计算均值。但是实际上概率分布$P$可能非常复杂，我们没有办法从其中进行采样。重要性采样方法通过从另外一个较为简单的分布$Q$中采样出的样本对以上期望值进行估计：<br>$$<br>\begin{align}<br>\mathbf{E}_{P(X)}[f(X)]&amp;=\mathbf{E}_{Q(X)}\left[\frac{P(X)}{Q(X)}f(X)\right] \\<br>&amp;\approx \frac{1}{m}\sum_{i=1}^m \frac{P(x^{(i)})}{Q(x^{(i)})}f(x^{(i)})\;\;\text{with}\;\;x^{(i)}\sim Q.<br>\end{align}<br>$$</p><h3 id="基于重要性采样的策略梯度方法"><a href="#基于重要性采样的策略梯度方法" class="headerlink" title="基于重要性采样的策略梯度方法"></a>基于重要性采样的策略梯度方法</h3><p>让我们回到正题，利用这种方法就可以在估计当前正在学习的策略的梯度时采用其他策略采样出的样本：<br>$$<br>\mathbf{E}[J(\theta)]\approx\sum_{t=1}^T \frac{1}{Z_t(\theta)}\sum_{i=1}^m \frac{\pi_{\theta}(\tau_{i,1:t)}}{q(\tau_{i,1:t})}r(x_t^i,u^i_t),<br>$$<br>其中$Z_t(\theta)=\sum_{i=1}^m\frac{\pi_{\theta}(\tau_{i,1:t)}}{q(\tau_{i,1:t})}$。从理论上来说$Z_t(\theta)=m$才是期望的无偏估计，这里为了减小训练时的方差采用了这个特殊值。但是我们是在其他策略采样出的样本分布的基础上进行新策略的搜索，一旦新策略的样本分布与采样样本分布相距较远时，无法保证估计梯度的准确性。前面有工作是通过计算重要性权重的方差来判断新策略的准确性的[^6]，但是对于很长的路径，重要性权重在大部分地方都为0，方差也很小，但是并不能说明什么问题。V1版本的GPS算法通过在优化目标上额外加入重要性权重的对数值的方式，来“软最大化”重要性权重值，毕竟重要性权重越大，代表新策略分布与采样分布更为接近（<strong>但其实在采样分布概率较小的地方新策略分配一个较大的概率也会使得这个值比较大，所以感觉这种方法还是有很大缺陷的</strong>）：<br>$$<br>\Phi(\theta)=\sum_{t=1}^{T}\left[\frac{1}{Z_{t}(\theta)} \sum_{i=1}^{m} \frac{\pi_{\theta}\left(\zeta_{i, 1 : t}\right)}{q\left(\zeta_{i, 1 : t}\right)} r\left(\mathbf{x}_{t}^{i}, \mathbf{u}_{t}^{i}\right)+w_{r} \log Z_{t}(\theta)\right].<br>$$</p><h3 id="指导样本的生成"><a href="#指导样本的生成" class="headerlink" title="指导样本的生成"></a>指导样本的生成</h3><p>GPS系列算法希望使用路径优化算法生成的指导样本来引导策略梯度算法往高回报的区域搜索（而非暴力试错）。在之前的文章中我们讲过iLQR算法，但是只展开讲了确定性情况下的相关知识。而策略梯度算法的应用场景大部分都是非确定性场景，即使是确定性场景，也会因为噪声的存在使其实际上同样是非确定性的。因而，下面我们主要关注非确定性场景下的指导样本生成。</p><p>在非确定性条件下，指导样本将服从某个概率分布，我们希望这个概率分布满足以下两个性质：</p><ol><li>各区域的概率密度不要过大（否则会使得重要性权重较小，使得指导样本对于梯度的贡献很小）</li><li>该分布要尽可能覆盖高回报区域</li></ol><p>GPS-V1的作者发现，如果指导样本的分布$q$是分布$\rho(\zeta) \propto \exp (r(\zeta))$的<a href="https://en.wikipedia.org/wiki/Information_projection" target="_blank" rel="external">I-投影</a>，即最小化如下KL散度:<br>$$<br>D_{\mathrm{KL}}(q | \rho)=E_{q}[-r(\zeta)]-\mathcal{H}(q),<br>$$<br>得到的分布$q$即可满足以上两个性质。具体来说，上式右边第一部分保证了性质2，右边第二部分保证了性质1。那么剩余的问题是分布$q$的具体形式是什么呢？GPS-V1假设分布$q$是一个<strong>高斯分布</strong>，这是一个很自然的也是最容易想到的假设。<strong>而且如果我们希望能够用只能解决非随机环境的路径优化算法例如iLQR来解决随即环境下的规划问题的话，只能假设$q$为高斯分布。</strong></p><p>为了能够直接使用类似iLQR算法的路径优化算法，我们这里再引入另外一个概念或者一个框架，叫做线性可解马尔科夫决策过程（LMDP）[^5]。该框架的核心思想在于，摒弃动作（action）的概念。智能体在不断优化其策略的过程中，会通过动作来改变其自身的状态转移概率（即在一个状态下转移到下一个状态的概率，策略在不断优化，那么每个状态下采取的动作也会变化，因而状态转移概率也会发生变化）。那么为何不放弃这一间接的做法，将策略直接定义为状态转移概率呢？即:</p><p>$$<br>p\left(x^{\prime} | x, u\right)=u\left(x^{\prime} | x\right)<br>$$<br>这就是LMDP的核心思想（<strong>这部分牵涉的知识较广，我同样会之后单独写一篇文章来详细介绍</strong>）。在LMDP的框架下，其回报函数变成如下形式：<br>$$<br>\tilde{r}\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)=r\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)-D_{\mathrm{KL}}\left(\pi_{\mathcal{G}}\left(\cdot | \mathbf{x}_{t}\right) | p\left(\cdot | \mathbf{x}_{t}\right)\right),<br>$$<br>其中$\pi_{\mathcal{G}}$代表学习到的策略（即学习到的状态转移概率），$p$代表智能体在没有任何算法控制的情况下的状态转移概率。当$p$表示一个均匀分布时，上式可转化为：<br>$$<br>E_{\pi_{\mathcal{G}}}[\tilde{r}(\zeta)]=E_{\pi_{\mathcal{G}}}[r(\zeta)]+\mathcal{H}\left(\pi_{\mathcal{G}}\right).<br>$$<br>因而求解一个LMDP得到的指导样本的概率分布是满足前面提到的两个性质的。另外，可以证明，当状态转移是线性以及回报函数是二次函数的情况下，最优策略可以直接通过iLQR算法求解并且求解出的最优策略服从以下高斯分布：<br>$$<br>\pi_{\mathcal{G}}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right)=\mathcal{G}\left(\mathbf{u}_{t} ; g\left(\mathbf{x}_{t}\right),-Q_{\mathbf{u u} t}^{-1}\right).<br>$$<br>$g(\mathbf{x}_t)$代表确定环境下运用iLQR算法得出的最优策略，$Q_{\mathbf{u u} t}^{-1}$代表确定环境下运行iLQR算法中的参数，具体参见iLQR算法。值得注意的是，由于LMDP并没有动作这一概念，之所以可以得出以上结论，是采用LMDP估计MDP得出的结论，具体细节我会单独写一篇文章细讲。这里得出的结论是什么意思呢？其实就是说在运行iLQR算法时，将前向循环中计算最优动作的过程转化为从以上高斯分布中采样，然后将优化目标从仅仅最小化（或最大化）损失函数（或回报函数）转变为同时最大化最优策略的熵即可即可。这样导出的指导样本就满足我们的要求。</p><p>还有一个问题是$\pi_{\mathcal{G}}$只有在状态转移是线性的情况下才是一个高斯分布，在状态转移是非线性的情况下，$\pi_{\mathcal{G}}$是指导样本分布的一个局部的高斯估计。由于GPS算法需要通过指导样本来将策略搜索的方向引导向高回报区域（这个高回报区域就是采样出指导样本的高斯分布的均值区域），但是这个分布只在指导样本附近是准确的，离得比较远就会出现较大误差，但是策略搜索的区域是任意的，就会出现梯度估计不准确的现象。以上问题其实已经缓解了，前面提到的改进版的梯度公式中的正则项保证了策略搜索的区域会靠近指导样本的区域：<br>$$<br>\Phi(\theta)=\sum_{t=1}^{T}\left[\frac{1}{Z_{t}(\theta)} \sum_{i=1}^{m} \frac{\pi_{\theta}\left(\zeta_{i, 1 : t}\right)}{q\left(\zeta_{i, 1 : t}\right)} r\left(\mathbf{x}_{t}^{i}, \mathbf{u}_{t}^{i}\right)+w_{r} \log Z_{t}(\theta)\right].<br>$$</p><h3 id="适应性指导样本分布"><a href="#适应性指导样本分布" class="headerlink" title="适应性指导样本分布"></a>适应性指导样本分布</h3><p>我们的策略是用某个特定的函数来进行估计的，而函数的表示能力是有限的（即使是神经网络，不同网络层数以及神经元个数都会对网络的表示能力产生影响。而所谓的通用函数估计器是在神经元个数无限的情况下才成立），那么强行让学习策略的分布与知道样本的分布尽可能一致可能会导致一些问题。考虑下面这种情况：指导样本是在了解模型的情况下进行决策的，而策略梯度算法是在不知道模型的情况下进行决策的。因而前者除了观察到的状态外还利用了环境模型的信息，在相似的观察下可能会进行差异较大的决策。换句话讲，策略函数要尝试去拟合一些相似输入产生不同输出的数据点，这就会使得算法训练起来十分困难。</p><p>目前的算法流程是在算法初始化时就使用iLQR算法产生大量的指导样本，之后就不再产生新的指导样本了。为了解决以上问题，在策略不断更新的过程中，重新根据以下这个新的回报函数来运行iLQR算法产生新的指导样本：<br>$$<br>\overline{r}\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)=r\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)+\log \pi_{\theta}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right).<br>$$<br>通过以上回报函数产生的指导样本会尝试产生策略函数能够产生的样本分布。</p><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>GPS-V1的整体流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/GPS/GPS-V1.png" alt="GPS-V1"></p><p>这里有几点细节需要说明。</p><ol><li>算法第6行选取训练样本，其实主要包括以下两种样本。第一种，全部的指导样本；第二种，重要性权重较大的新样本，权重较大代表与指导样本更为相似。</li><li>第7行进行参数更新时，是从上一步最优的参数作为初始点进行更新的。但是有时算法会陷入到局部最优解中，使得在该局部最优解下指导样本的重要性权重较小，那么指导样本就对梯度的估计无法产生影响，这样就会使得算法进一步往更差的方向更新。为了防止以上问题，这一步的参数更新从两个不同的初始点开始：第一个初始点就是上一步更新的结果；而第二个则是求得一个使得当前采集到的回报较高的样本重要性权重最大的参数当作初始化参数。</li><li>关于第11-17行，具体解释以下为什么要采取这些操作。当新搜索到的策略比原先的策略要好时，适当减小约束项的权重，这样可以增大下一步的策略搜索范围，换句话说就是可以步子迈得大一些；反之，如果新搜索到的策略比上一步的要差，那么可能目前处于一个局部最优解较多的区域内，或者搜索区域过大使得梯度估计得不准确，这时候应该适当缩小搜索范围，在更接近指导样本的区域内搜索。再者，如果这样还是不能搜索到更好的策略，那么可能就是采样出的训练样本不好，这时候可以尝试重新采样。</li></ol><p>以上就是GPS-V1算法的全部内容。其实在理解GPS-V1算法之后，后面两个版本就很简单了，因此我下面的内容相对也会少很多。</p><h2 id="GPS-V2"><a href="#GPS-V2" class="headerlink" title="GPS-V2"></a>GPS-V2</h2><p>作者在GPS-V1算法里发现了一个问题，其实V1算法也尝试去解决这个问题但是效果不好，这个问题就是1.4节中所描述的问题。基于模型的路径优化算法产生的指导样本，不基于模型的策略梯度方法有时候并不能拟合出来，就像在上一节中讲到的那样，策略梯度算法观察不到一些通过模型才能反应出来的因素。这样会使得对于复杂问题学习出来的样本分布并不能与指导样本分布符合的很好。GPS-V2从另外一个角度解决了上述问题，即完全抛弃了策略梯度步骤，直接让策略通过对指导样本进行监督学习得出，并且在路径优化算法更新时考虑到与当前策略的距离并且尝试使得这个距离尽可能小。通过这样一种迭代更新的流程来使得两者最终匹配。</p><p>上述思想其实GPS-V1部分的1.4节已经考虑到了，但是是通过改变回报函数的方式达到的。GPS-V2通过一种更直接的方式来建模，并抛弃了策略梯度部分，通过更加鲁棒的监督学习来学习策略，使得算法更新更为稳定。具体来说，GPS-V2求解以下优化问题：<br>$$<br>\begin{align} \min _{\theta, q(\tau)} &amp; D_{\mathbf{KL}}(q(\tau) | \rho(\tau)) \\ \text { s.t. } &amp; q\left(\mathbf{x}_{1}\right)=p\left(\mathbf{x}_{1}\right) \nonumber \\ &amp; q\left(\mathbf{x}_{t+1} | \mathbf{x}_{t}, \mathbf{u}_{t}\right)=p\left(\mathbf{x}_{t+1} | \mathbf{x}_{t}, \mathbf{u}_{t}\right) \nonumber \\ &amp; D_{\mathrm{KL}}\left(q\left(\mathbf{x}_{t}\right) \pi_{\theta}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right) | q\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)\right)=0. \nonumber \end{align}<br>$$<br>其中第一个和第二个约束在路径优化算法运行的过程中已经默认保证了，实际我们只需要考虑第三个约束<strong>。注意优化目标就是GPS-V1中提到的I-projection，只不过这里没有展开</strong>。我们采用拉格朗日乘子法（或者扩展拉格朗日乘子法）将上述问题转化为一个无约束优化问题：<br>$$<br>\begin{align} \mathcal{L}(\theta, q, \lambda)=&amp; D_{\mathrm{KL}}(q(\tau) | \rho(\tau))+\nonumber\\ &amp; \sum_{t=1}^{T} \lambda_{t} D_{\mathrm{KL}}\left(q\left(\mathbf{x}_{t}\right) \pi_{\theta}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right) | q\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)\right). \end{align}<br>$$<br>而对于上述优化问题，我们可以采用对偶梯度下降法（DGD，或者交替方向乘子法，ADMM）分别更新三部分的参数。而对偶变量通过以下公式更新：<br>$$<br>\lambda_{t} \leftarrow \lambda_{t}+\eta D_{\mathrm{KL}}\left(q\left(\mathbf{x}_{t}\right) \pi_{\theta}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right) | q\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)\right).<br>$$<br>可以看出更新$q$其实就是在采用路径优化算法，更新$\theta$时就是在做监督学习。最后给出算法流程：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/GPS/GPS-V2.png" alt="GPS-V2"></p><h2 id="GPS-V3"><a href="#GPS-V3" class="headerlink" title="GPS-V3"></a>GPS-V3</h2><p>其实我觉得最实用的还是V3版本的GPS算法，因为对于大部分现实问题，环境模型对与算法设计者来说都是未知的。但是前两个版本的GPS算法都假设环境模型是已知的（这样才能运行路径优化算法）。GPS-V3算法尝试解决事先未知环境模型场景下的相关问题，其实其基本思想也很直接，未知模型那我就估计模型，只不过全局模型肯定是很难估计准确的，而且要采用类似iLQR这种路径优化算法要对模型进行线性近似，因而更加不可能采用全局模型了。GPS-V3通过估计局部模型来缓解上述问题，但是采用局部模型又会引入类似GPS-V1这样的问题，在搜索区域距离当前样本过远时，算法误差就会较大，因而GPS-V3在GPS-V2的基础上再加了一个约束来解决这个问题。</p><p>具体来说，GPS-V1是解决如下优化问题来产生指导样本的：<br>$$<br>p(\tau)=\arg \min _{p(\tau) \in \mathcal{N}(\tau)} E_{p}[\ell(\tau)]-\mathcal{H}(p(\tau)) \text { s.t. } p\left(\mathbf{x}_{t+1} | \mathbf{x}_{t}, \mathbf{u}_{t}\right)=\mathcal{N}\left(\mathbf{x}_{t+1} ; f_{\mathbf{x} t} \mathbf{x}_{t}+f_{\mathbf{u} t} \mathbf{u}_{t}, \mathbf{F}_{t}\right).<br>$$<br>然后我们先转回到最原始iLQR算法的优化目标，不过因为这个时候我们是用估计的局部模型来运行该算法的，我们加上如下KL散度的约束来使得搜索范围不会离当前样本太远：<br>$$<br>\min _{p(\tau) \in \mathcal{N}(\tau)} E_{p}[\ell(\tau)] \text { s.t. } D_{\mathrm{KL}}(p(\tau) | \hat{p}(\tau)) \leq \epsilon.<br>$$<br>接下来同样采用拉格朗日乘子法（或者扩展拉格朗日乘子法）将其转变为无约束问题：<br>$$<br>\mathcal{L}_{\text { traj }}(p(\tau), \eta)=E_{p}[\ell(\tau)]+\eta\left[D_{\mathrm{KL}}(p(\tau) | \hat{p}(\tau))-\epsilon\right].<br>$$<br>将上式中的KL散度展开：<br>$$<br>\mathcal{L}_{\mathrm{traj}}(p(\tau), \eta)=\left[\sum_{t} E_{p\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)}\left[\ell\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)-\eta \log \hat{p}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right)\right]\right]-\eta \mathcal{H}(p(\tau))-\eta \epsilon.<br>$$<br>和GPS-V1的优化问题对比，我们可以发现一个优秀的巧合，我们只需要对上式两边除以$\eta$，并将回报函数转变一下：$\tilde{\ell}\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)=\frac{1}{\eta} \ell\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)-\log \hat{p}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right)$，就可以直接采用GPS-V1一样的方法产生指导样本。再将GPS-V2算法引入进来：<br>$$<br>\begin{align} \mathcal{L}(\theta, q, \lambda)=&amp; \mathcal{L}_{\mathrm{traj}}(p(\tau), \eta) +\nonumber\\ &amp; \sum_{t=1}^{T} \lambda_{t} D_{\mathrm{KL}}\left(q\left(\mathbf{x}_{t}\right) \pi_{\theta}\left(\mathbf{u}_{t} | \mathbf{x}_{t}\right) | q\left(\mathbf{x}_{t}, \mathbf{u}_{t}\right)\right). \end{align}<br>$$<br>对于上式同样采用GPS-V2一样的DGD方法（或者ADMM算法）求解即可。具体流程如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/GPS/GPS-V3.png" alt="GPS-V3"></p><p>这里需要再提一点，关于估计局部模型采用的方法。由于局部模型是一个高斯分布，我们其实只要去估计其均值即可（方差设定为$Q_{\mathbf{u u} t}^{-1}$）。而均值又是个线性函数，其实只要估计两个梯度即可：<br>$$<br>p\left(\mathbf{x}_{t+1} | \mathbf{x}_{t}, \mathbf{u}_{t}\right)=\mathcal{N}\left(\mathbf{A}_{t} \mathbf{x}_{t}+\mathbf{B}_{t} \mathbf{u}_{t}+\mathbf{c}, \mathbf{N}_{t}\right) \quad \mathbf{A}_{t} \approx \frac{d f}{d \mathbf{x}_{t}} \quad \mathbf{B}_{t} \approx \frac{d f}{d \mathbf{u}_{t}}<br>$$<br>因而可以用简单的线性回归方法。当然，对于较复杂的问题，一般会采用<strong>贝叶斯线性回归，选用高斯过程、深度网络或者高斯混合模型作为贝叶斯先验</strong>（这部分有机会我也会展开讲一讲）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我引用[^1]文中的一段文字来总结GPS算法的核心思想：</p><blockquote><p>Since each trajectory-centric teacher only needs to solve the task from a single initial state, it is faced with a much easier problem. The final policy is trained with supervised learning, which allows us to use a nonlinear, high-dimensional representation for this final policy, such as a multilayer neural network, in order to learn complex behaviors with good generalization. A key component in guided policy search is adaptation between the trajectories produced by the teacher and the final policy. This adaptation ensures that, at convergence, the teacher does not take actions that the final policy cannot reproduce. This is realized by an alternating optimization procedure, which iteratively optimizes the policy to match each teacher, while the teachers adapt to gradually match the behavior of the final policy.</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[^1]: Zhang, Marvin, et al. “Learning deep neural network policies with continuous memory states.” <em>2016 IEEE International Conference on Robotics and Automation (ICRA)</em>. IEEE, 2016.</p><p>[^2]: Levine, Sergey, and Vladlen Koltun. “Guided policy search.” <em>International Conference on Machine Learning</em>. 2013.</p><p>[^3]: Levine, Sergey, and Vladlen Koltun. “Learning complex neural network policies with trajectory optimization.” <em>International Conference on Machine Learning</em>. 2014.</p><p>[^4]: Levine, Sergey, and Pieter Abbeel. “Learning neural network policies with guided policy search under unknown dynamics.” <em>Advances in Neural Information Processing Systems</em>. 2014.</p><p>[^5]: Dvijotham, Krishnamurthy, and Emanuel Todorov. “Inverse optimal control with linearly-solvable MDPs.” <em>Proceedings of the 27th International Conference on Machine Learning (ICML-10)</em>. 2010.</p><p>[^6]: Jie, Tang, and Pieter Abbeel. “On a connection between importance sampling and the likelihood ratio policy gradient.” <em>Advances in Neural Information Processing Systems</em>. 2010.</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/" itemprop="url">How to make an optimal decision in the case of knowing the environment model(CS294 lecture notes) ?</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-25T01:31:40+08:00">2019-03-25 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/" itemprop="commentsCount"></span> </a></span><span id="/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/" class="leancloud_visitors" data-flag-title="How to make an optimal decision in the case of knowing the environment model(CS294 lecture notes) ?"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>首先我们假设环境是确定性的，即在某个状态执行某个动作之后，转移到的下一个状态是确定的，不存在任何随机性。而在这种情况下，我们想做的是在环境给了我们一个初始状态的条件下，根据我们需要完成的任务以及环境模型，直接得出从初始状态到任务完成状态中间最优的动作序列。因为环境是确定的，而我们又已知环境模型，因而以上想法是自然且可行的。下图展示了我们想做的事情：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/2.png" alt="目标任务"></p><p>现在我们将以上问题抽象成一个正式的优化问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/1.png" alt="优化目标"></p><p>其中$f$就代表环境模型。但是一旦环境不再是确定的，即正在某个状态执行某个动作之后，转移到的下一个状态是从一个状态分布中随机采样的。对于这种情况，上述的优化问题就会转变为最大化如下形式的期望值：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/3.png" alt="期望优化目标"></p><p>但是在随机环境下，解决与确定环境的类似的如上优化问题并不能得到与确定环境一样的最优解。原因在于我们只接受环境反馈回来的初始状态，接着便凭借着我们掌握的环境模型在脑海中进行规划。这种方法在确定环境下没有任何问题，但在随机环境下，智能体实际会转移到的状态可能并不符合我们的预期，因为它是从一个条件状态分布中随机采样的。而一旦从某一个状态开始与我们的预期产生偏差，那么后续的所有状态都会产生偏差，而我们设想的最优动作序列便不是最优了。从优化函数的角度来看，我们优化的只是一个期望值，而不是某一次随机采样的值。</p><p>我们把上述解决问题的方法叫做开环方法，与之对应的叫做闭环方法。那么这个“环”具体是指什么呢？具体示意图如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/4.png" alt="环"></p><p>开环方法是只在最开始时接收环境反馈的初始状态，然后开始规划从开始到任务完成的过程中所经历的所有状态对应的最优动作，并不需要一个基于状态产生动作的<strong>策略</strong>；反之，闭环方法在每一个时间步都会接收环境反馈的状态，然后利用一个根据状态输出动作的<strong>策略</strong>来产生一个动作。我们可以看出，对于一个随机环境，闭环方法显然比开环方法更具优势，因为其可以根据所处的状态随时调整自己的动作。</p><p>但接下来我们还是首先假定一个确定性的环境，因而采用开环方法来解决上述问题。下面将介绍三种优化方法：随机优化方法、蒙特卡洛树搜索法以及轨迹优化方法。</p><h2 id="随机优化方法"><a href="#随机优化方法" class="headerlink" title="随机优化方法"></a>随机优化方法</h2><p>对于随机优化方法来讲，上述优化问题可以简化为如下等价优化问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/5.png" alt="随机优化目标"></p><p>随机优化方法完全不关系优化目标的特殊结构等信息，而是把任何优化问题都当作上图右半边这样的一般优化问题。</p><h3 id="随即发射方法"><a href="#随即发射方法" class="headerlink" title="随即发射方法"></a>随即发射方法</h3><p>最简单的随机优化方法就是随机瞎猜，即随机选择一个动作序列，然后评估其累积的代价。如上过程不断进行，最后选择一个累积代价最小的动作序列作为上述优化问题的最优解，因而这类方法也叫做“随机发射方法”：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/6.png" alt="随机发射方法"></p><h3 id="CMA算法"><a href="#CMA算法" class="headerlink" title="CMA算法"></a>CMA算法</h3><p>但是这种方法在相对高维的情况下效率会很低，因为搜索空间太大但是目标区域比较小。回顾一下上述方法，我们可以在采样分布上做些文章。假设第一次从一个均匀分布采样一些动作序列之后，得到的累积代价分别为如下情况：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/7.png" alt="随机采样"></p><p>那么下一次我们可以不再继续从一个均匀分布中采样了，我们可以聚焦于累积代价较小（累积回报较大）的区域，然后估计那个区域的分布，在这里我们假设分布是一个高斯分布：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/8.png" alt="估计分布"></p><p>接下来的采样我们就从这个新的分布中进行采样：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/9.png" alt="新的采样结果"></p><p>然后在下一次采样之前，我们再次聚焦于性能更好的区域然后估计其分布：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/10.png" alt="再次估计分布"></p><p>就这样不断迭代，直到满足停止条件。以上方法就是Cross-Entropy Method(CEM)算法，其伪代码如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/11.png" alt="CEM算法"></p><p>该方法还有个进阶版的算法叫做CMA-ES算法，后者可以看作是CMA算法带动量的版本。CMA算法会直接舍弃之前采样的数据点，但是CMA-ES算法会保留部分之前采样的数据点的相关信息，用来指导后续的采样。可以类比一下梯度下降法以及带动量的梯度下降法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>随机优化方法具有以下优点：</p><ul><li>并行化后效率极高</li><li>实现起来十分简单</li></ul><p>但是也存在如下不可避免地缺点：</p><ul><li>极易受到维度灾难的影响</li><li>只适用于开环情形</li></ul><p>随即优化方法虽然可以同时适用于连续变量以及离散变量的情况，但不是专门为离散情况设计的。下面我们将介绍一种专门为离散动作空间设计的强大的优化方法（严格来讲叫做启发式搜索算法）：蒙特卡洛树搜索MCTS方法。</p><h2 id="蒙特卡洛树搜索算法"><a href="#蒙特卡洛树搜索算法" class="headerlink" title="蒙特卡洛树搜索算法"></a>蒙特卡洛树搜索算法</h2><p>MCTS方法本质是一个搜索算法：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/12.png" alt="搜索算法"></p><p>假设我们想要训练一个智能体能够自动去玩上面这个游戏（击沉敌方潜水艇将会获得分数，但是潜水艇自身的氧气储存量是逐渐减少的，需要不时地去浮出水面补充氧气。被敌方潜水艇撞上会损失生命值，游戏目标就是获得尽可能多的分数）。一个简单的暴力搜索算法可能会包含上图右边的过程，假设一段最优动作序列仅仅包含十个时间步，每个状态下仅仅包含两个可能动作，那么最后一个时间步就包含1024个可能性。但对于大多数问题来说，十个时间步远远不足以完成目标，因而暴力搜索算法是不可行的。</p><p>那么蒙特卡洛算法是如何在不穷举所有可能性直到到达终点的情况下对一个动作序列进行评估的呢？考虑潜水艇游戏，在潜水艇做出攻击指令后，由于炮弹的运行需要时间，因而几个时间步之后敌方潜水艇才会被击沉从而受到奖励，在潜水艇做出攻击指令那个时间步是没有任何奖励的，因而智能体可能认为这个动作并不是一个优秀的动作。对于以上情况，其实我们只需要在做出攻击指令后，如果要评估这个动作的优劣，“等待”几个时间步 即可。蒙特卡洛树搜索算法正是采用这种思想，同样用上图右边的过程举例，当动作执行到第三层时，如何评估这四个动作序列的性能好坏呢？算法进行了某种“等待”，即从第三层开始，不再把树进行完全的扩展了，而是采用一个随机策略随机执行动作直到游戏结束或者到达某个设定的时间步。这就类似于在潜水艇游戏中，潜水艇在发出炮弹后，随机执行一些动作，直到炮弹击中敌方潜水艇。</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/13.png" alt="评估过程"></p><p>而蒙特卡洛算法正是通过这种评估方法来避免暴力搜索，具体来说，蒙特卡洛树搜索算法会根据评估结果的好坏以及访问次数来决定下一步应该搜索哪一条路径：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/14.png" alt="搜索策略"></p><p>可能以上描述有点难以理解，那么下面我们过一遍蒙特卡洛树搜索方法的搜索过程。我们首先给出算法的执行步骤：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/28.png" alt="蒙特卡洛树搜索算法框架"></p><p>首先我们处于一个初始状态：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/15.png" alt="初始状态"></p><p>然后我们进行算法第一步，根据一个“树策略”找到一个叶子节点，注意这里找到一个叶节点的意思是找到一个<em>*新的</em>叶节点。树策略的具体形式如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/29.png" alt="树策略"></p><p>根据以上策略，由于初始状态没有被完全扩展，因而随机选择一个动作，并执行第二步使用<strong>默认策略</strong>来评估执行这个动作的好坏，这里默认策略使用的是随机采样策略：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/16.png" alt="随机选择"></p><p>假设评估结果如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/17.png" alt="评估结果"></p><p>这里Q代表环境定义的回报，N代表访问这个状态的次数。<strong>这里值得注意的是，N记录的并不是某个具体的状态的访问次数，而是执行某个动作的次数，执行这个动作后在随机环境下可能转移到很多个不同的状态，但在树中均显示为一个节点。</strong>评估完之后，我们需要更新根节点到这个新加入的叶节点之间所有节点的Q值以及N值。由于这里两者之间并没有其他的节点，因而跳过这一步。然后以上过程开始循环，<strong>我们再将状态跳回到初始状态</strong>，遵循树策略，找到下一个新的叶节点。由于初始状态还是没有扩展完毕，因此这一次执行下一个未被执行过的状态：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/18.png" alt="第二轮随机选择"></p><p>再采用默认策略对其进行评估，假设我们得到了以下结果：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/19.png" alt="初始状态"></p><p>由于根节点与新的叶节点之间的路径并没有其他节点，因而更新步骤略过。再次重复以上过程，将状态跳回到初始状态，执行树策略找到一个新的叶节点。首先根据树策略，初始状态已经被完全扩展开了（即所有可能的动作均已经执行过），这个时候我们根据树策略中的公式计算每一条路径的一个<strong>分数</strong>。从分数计算公式可以看出，这个分数是同时考虑动作的回报以及动作的执行次数，更加倾向于执行被执行次数少的回报高的动作。在这里，由于两个动作被执行次数均为1，因而我们选择回报更高的第二个动作执行，然后再根据树策略（<strong>在没有找到新的叶节点之前，循环执行树策略</strong>），第二层的状态没有被完全扩展，因而随机选择一个动作执行：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/20.png" alt="再次找到新的叶节点"></p><p>依据默认策略进行评估：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/21.png" alt="采用默认策略评估"></p><p><strong>注意，到了这一步，根节点到新的叶节点之间的路径存在其他节点了，我们就要用最新的叶节点的评估值以及访问次数加到这些中间节点的评估值以及访问次数上：</strong></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/22.png" alt="更新中间节点"></p><p>再次重复上述过程，将状态跳回到初始状态，调用树策略，这时候根据分数计算公式，在假设一些超参数的情况下，我们假定这个时候更加侧重于执行被执行次数更小的动作并评估：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/23.png" alt="侧重被访问次数更少的动作"></p><p>然后再更新再跳回……</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/24.png" alt="循环"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/25.png" alt="循环"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/26.png" alt="循环"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/27.png" alt="循环"></p><p>如果想详细了解蒙特卡洛树搜索算法的扩展以及应用，可以参考下面这篇综述：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/30.png" alt="综述"></p><p>这里讲一个比较有意思的案例：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/31.png" alt="利用蒙特卡洛树搜索算法进行模仿学习"></p><p>其思想其实是将DAgger算法与MCTS算法进行结合。由于DAgger算法需要人工的不断参与进行新数据的标注，以上案例将专家标注的过程用MCTS算法进行替代，学习一个MCTS的策略估计器：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/32.png" alt="DAgger"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/33.png" alt="DAgger with MCTS"></p><p>那么为什么不直接使用MCTS算法呢？其实是基于以下两点考虑的：</p><ul><li>实时性要求较高的任务中MCTS太慢了</li><li>采用类似神经网络的策略估计器具有更好的泛化性</li></ul><h2 id="路径优化算法"><a href="#路径优化算法" class="headerlink" title="路径优化算法"></a>路径优化算法</h2><p>让我们再次回顾以下优化问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/1.png" alt="优化目标"></p><p>直接丢弃掉以上优化问题中的特殊结构显然不是十分恰当的，接下来让我们回到一般解决以上优化问题的思路。我们一看到以上问题，就会首先想到能不能利用类似梯度下降的方法呢？为了与最优控制中路径优化算法的一般符号记法一致，我们将以上问题重写为以下形式：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/34.png" alt="路径优化问题的优化目标"></p><p>我们可以将约束部分放进优化函数中从而将以上问题转变为一个无约束问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/35.png" alt="无约束形式"></p><p>对于以上问题，只要我们知晓以下四项，即可根据链式法则得出其最优解：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/36.png" alt="需要知道的梯度"></p><h3 id="LQR算法"><a href="#LQR算法" class="headerlink" title="LQR算法"></a>LQR算法</h3><h4 id="确定性环境"><a href="#确定性环境" class="headerlink" title="确定性环境"></a>确定性环境</h4><p>为了解决以上优化问题，我们接下来将介绍一种路径优化算法<strong>LQR</strong>，此算法<strong>假设环境模型是线性的，并且代价函数是二次的</strong>：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/37.png" alt="LQR优化目标"></p><p>为了解决这种特殊形式的以上优化问题，我们采用<strong>动态规划</strong>的思想，<strong>先找出最优的最后一个时间步的动作</strong>。之所以这样做，是因为我们可以发现，以上连加项中只有最后一项是与最后一个时间步的动作相关的。如果我们首先解决第一个时间步的最优动作，那么连加项的所有项都与第一个时间步的动作相关。接下来，我们把最后一项中连续的函数求值简写为$x_{T}$，<strong>注意这个值是未知的</strong>。进行了以上的准备工作后，求解最后一个时间步的最优动作对应的优化目标如下，我们把其记为$Q(x_T,u_T)$：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/38.png" alt="Q值函数"></p><p>然后我们将线性项系数以及二次项系数展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/39.png" alt="系数展开"></p><p>然后，为了得出最优动作，我们令这个优化目标关于最后一个时间步动作的梯度等于0：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/40.png" alt="最小化Q值函数"></p><p>求解以上线性方程，可以得出最后一个时间步的最优动作为：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/41.png" alt="最后一个时间步的最优动作"></p><p>将其进行简单的转化，我们可以看出，<strong>最后一个时间步的最优动作是最后一个时间步状态（现在还是未知项）的线性函数（以上关系适用于所有时间步）</strong>：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/42.png" alt="最后一个时间步的动作是状态的线性函数"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/43.png" alt="系数的具体形式"></p><p>由于最后一步的最优动作完全可以用最后一步的状态表示，我们可以得出最后一个时间步的最优的Q值，这里我们将其记为V：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/44.png" alt="最后一个时间步的最优Q值"></p><p><strong>这里的Q值以及V值其实是和强化学习中的定义是一致的。</strong>接下来，我们将上式展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/45.png" alt="V值展开"></p><p>将上式合并同类项可得：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/46.png" alt="合并同类项"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/47.png" alt="系数具体形式"></p><p>因而我们可以得到另一个关系，<strong>最后一个时间步的V值（最优Q值）是最后一个时间步状态的二次函数（以上关系适用于所有时间步）。</strong>进行到这里，我们已经解出最后一个时间步的最优动作了。接下来，我们要在此基础上解出倒数第二个时间步的最优动作。首先我们注意到，倒数第二个时间步的Q值函数可以记为：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/49.png" alt="倒数第二个时间步的Q值函数"></p><p>将环境模型引入可将V值展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/48.png" alt="环境模型"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/50.png" alt="展开后的V值"></p><p>我们将展开后的V值代入倒数第二时间步的Q值函数中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/51.png" alt="带入展开后V值的倒数第二个时间步的Q值函数"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/52.png" alt="系数具体形式"></p><p>同样，为了求出倒数第二个时间步的最优动作，我们令相关梯度为零：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/53.png" alt="最小化Q值函数"></p><p>解得倒数第二个时间步的最优动作为：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/54.png" alt="倒数第二个时间步的最优动作"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/55.png" alt="系数具体形式"></p><p>让我们不断地重复以上过程，直到第一个时间步。<strong>值得注意的是，由于每一时间步的最优动作与那个时间步的状态有关，但是状态是未知的。</strong></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/56.png" alt="循环以上过程"></p><p>当整个过程回溯到初始时间步时，情况发生了变化，<strong>初始状态我们是已知的！</strong>因而，我们就可以算法初始时间步的最优动作。利用环境模型，我们就可以得知第二个时间步的状态，如此循环下去，我们就可以得知所有时间步的最优动作：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/57.png" alt="前向循环"></p><p>以上就是整个LQR算法的执行过程。</p><h4 id="非确定性环境-（未完成）"><a href="#非确定性环境-（未完成）" class="headerlink" title="非确定性环境 （未完成）"></a>非确定性环境 （未完成）</h4><p>对于非确定性环境，假设我们的环境模型如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/58.png" alt="随机环境模型"></p><p><strong>那么LQR算法依旧是完全可行的。</strong></p><h3 id="iLQR算法"><a href="#iLQR算法" class="headerlink" title="iLQR算法"></a>iLQR算法</h3><p>LQR算法由于假设环境模型以及代价函数是线性以及二次的，表达能力有限，对于更加复杂的任务显然不能很好的估计。因而，解决这个问题的iLQR算法应运而生。其基本思想很简单，既然线性以及二次函数不足以估计全局的真实函数，那么估计局部的总是足够的。因而我们可以<strong>对环境模型以及代价函数分别做一阶以及二阶的泰勒展开！</strong>：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/59.png" alt="泰勒展开"></p><p>那么我们的问题其实又转变回了原始的LQR设定：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/60.png" alt="原始设定"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/61.png" alt="参数具体形式"></p><p>iLQR算法的具体框架如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/62.png" alt="iLQR算法"></p><p><strong>该算法之所以采用迭代的形式，是因为其需要不断地用真实样本来去”矫正“其对于环境模型以及代价函数的估计。</strong>更严格来讲，该算法之所以能够达到很好的效果，是因为它和牛顿方法的本质是一样的（通过泰勒展示来估计一个复杂的非线性函数的局部特性）：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/63.png" alt="牛顿方法"></p><p>而如果我们对环境模型估计时也进行二阶泰勒展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/64.png" alt="参数具体形式"></p><p>那么我们的算法就变为微分动态规划算法（DDP）。但是在实际情况中，代价函数的形式一般比较简单，因而进行二阶泰勒展开代价不大。但是环境模型一般是十分复杂的，一阶展开还好，一旦进行二阶展开其复杂性将会大大增加。事实表明一阶展开其实是足够的。</p><p>但是以上算法还存在一个问题，考虑以下估计误差：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/65.png" alt="局部估计误差"></p><p>对于这种情况，其实我们只要简单的在原始iLQR算法中加一个line search过程即可：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/66.png" alt="Line Search"></p><p>最后我们看一个iLQR算法在实际情况应用的实例：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/67.png" alt="实例"></p><p>为了保证iLQR更加稳定，这个工作采用了如下形式的改进：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/68.png" alt="改进"></p><p><strong>即在每一步都进行一个完整的规划，但是考虑到iLQR的估计误差随着时间会产生累积，因而每次只执行规划的第一步。</strong></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/TD-VAE/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/03/20/TD-VAE/" itemprop="url">TD-VAE [ICLR 2019]</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T21:51:58+08:00">2019-03-20 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/03/20/TD-VAE/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/03/20/TD-VAE/" itemprop="commentsCount"></span> </a></span><span id="/2019/03/20/TD-VAE/" class="leancloud_visitors" data-flag-title="TD-VAE [ICLR 2019]"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>【笔记版】</p><p>今天要讲的是ICLR2019中DeepMind的一个工作，TD-VAE，一个<strong>序列生成模型</strong>。通过引入强化学习中<strong>时序差分</strong>以及<strong>变分自动编码器</strong>，来实现从当前时间步到未来时间步的预测。这里值得注意的是，TD-VAE并不是一个固定时间步的序列生成模型（当然如果训练时喂的训练数据是一个时间间隔固定的序列数据，那么训练出的模型就是固定时间步的序列生成模型），即其生成的数据时间间隔不是一个固定的时间步，而是随机的。如果想生成数据的时间间隔可控，那么可以在前向模型的建模中显式地将时间步作为变量即可。</p><p>这篇论文的作者认为，一个序列生成模型需要具备以下三点属性：</p><ul><li>这个模型应该学习一个数据的抽象<em>状态表示</em>并且在状态空间中进行预测，而不是在观察空间进行预测。</li><li>这个模型应该学习一个<em>置信状态</em>，这个状态需要包含目前为止智能体对于周围环境的所有感知信息。置信状态相当于状态表示的隐变量。</li><li>这个模型应该表现出<em>时序抽象</em>，既能够直接预测多个时间步之后的状态，也能够只通过两个独立的时间点进行训练而不需要中间所有时间点的信息。</li></ul><h1 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h1><p>TD-VAE的目标便是优化以下对数条件似然：<br>$$<br>\log p(x_t|x_{&lt;t})<br>$$<br>这里假设$x_t$可以通过该时间步以及上一个时间步的状态表示$z_t$和$z_{t-1}$推断得出，类似于VAE中损失函数的推导过程，这里同样引入ELBO，具体推导过程如下图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/2.jpg" alt="推导过程"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/3.jpg" alt="推导过程"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/4.jpg" alt="推导过程"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/5.jpg" alt="推导过程"></p><p>最后的损失函数包含以下几个部分：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/9.png" alt="损失函数1"></p><p>然后我们把两个连续时间步的状态表示换为两个任意时刻的状态表示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/10.png" alt="损失函数2"></p><p>这实质上是如下VAE的损失函数：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/8.jpg" alt="VAE"></p><p>其中$t2&gt;t1$。整个损失函数可以直观地解释为以下四个部分组成：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/15.png" alt="直观解释1"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/16.png" alt="直观解释2"></p><p>训练时的计算图如下所示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/11.png" alt="计算图"></p><p>最后在三个不同任务上的实验结果：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/12.png" alt="直观解释1"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/13.png" alt="直观解释1"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/14.png" alt="直观解释1"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/Survey-of-Sim2Real-Part-I/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/03/20/Survey-of-Sim2Real-Part-I/" itemprop="url">Survey of Sim2Real: Part I</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T21:50:53+08:00">2019-03-20 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/03/20/Survey-of-Sim2Real-Part-I/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/03/20/Survey-of-Sim2Real-Part-I/" itemprop="commentsCount"></span> </a></span><span id="/2019/03/20/Survey-of-Sim2Real-Part-I/" class="leancloud_visitors" data-flag-title="Survey of Sim2Real: Part I"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>最近survey了一下sim2real领域最近的相关工作，先整理个第一版（共有七篇论文）的总结。</p><p>整篇总结分为以下四个部分：</p><ul><li>问题的定义以及工作的出发点</li><li>方法的分类</li><li>具体算法</li><li>一个实例</li></ul><h1 id="问题的定义以及工作的出发点"><a href="#问题的定义以及工作的出发点" class="headerlink" title="问题的定义以及工作的出发点"></a>问题的定义以及工作的出发点</h1><p>sim2real的全称是simulation to reality，是强化学习的一个分支，同时也属于transfer learning的一种。主要解决的问题是机器人领域中，直接让机器人或者机械臂在现实环境中与环境进行交互、采样时，会出现以下两个比较严重的问题：</p><ul><li>采样效率太低（在用强化学习算法解决机器人相关问题时，所需要的样本量一般会达到上千万，在现实环境中采集如此数量级的样本要耗费几个月的时间）</li><li>安全问题 （由于强化学习需要通过智能体在环境中进行大范围的随机采样来进行试错，因而在某些时刻其做出的行为可能会损伤机器人自身，例如手臂转动角度过大或者避障任务中由于碰撞造成的不可逆损伤等等；也可能会损害周围的环境甚至生物）</li></ul><p>但是如果我们在模拟器中进行强化学习算法的训练，以上两个问题均可迎刃而解。但是，这里同样会存在一个问题，由于模拟器对于物理环境的建模都是存在误差的，因而在模拟环境中学习到的最优策略是否可以直接在现实环境中应用呢？答案往往是否定的，我们把这个问题称为 “reality gap”。而sim2real的工作就是去尝试解决这个问题。</p><p>这里值得注意的一点是，虽然这个方向叫做sim2real，其实其中的所有的算法都可以直接应用在sim2sim，real2real等的任务中。</p><h1 id="方法的分类"><a href="#方法的分类" class="headerlink" title="方法的分类"></a>方法的分类</h1><p>sim2real中的典型工作大致可以分为以下五类：</p><ul><li><strong>Domain Adaption</strong> 主要是通过学习一个模拟环境以及现实环境共同的状态到隐变量空间的映射，在模拟环境中，使用映射后的状态空间进行算法的训练；因而在迁移到现实环境中时，同样将状态映射到隐含空间后，就可以直接应用在模拟环境训练好的模型了。</li><li><strong>Progressive Network</strong> 利用一类特殊的Progressive Neural Network来进行sim2real。其主要思想类似于cumulative learning，从简单任务逐步过渡到复杂任务（这里可以认为模拟器中的任务总是要比现实任务简单的）。</li><li><strong>Inverse Dynamic Model</strong> 通过在现实环境中学习一个逆转移概率矩阵来直接在现实环境中应用模拟环境中训练好的模型。</li><li><strong>Domain Randomization</strong> 对模拟环境中的视觉信息或者物理参数进行随机化，例如对于避障任务，智能体在一个墙壁颜色、地板颜色等等或者摩擦力、大气压强会随机变化的模拟环境中进行学习。</li></ul><h1 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h1><p>这一部分将对以下六篇论文进行详细的说明：</p><ul><li><a href="https://pdfs.semanticscholar.org/a74a/420189a44c82a21f0ae79d0415bc9964116d.pdf?_ga=2.240723076.62241912.1552892977-1147771314.1552892977" target="_blank" rel="external">Towards Adapting Deep Visuomotor Representations from Simulated to Real Environments</a>[arXiv 2015] Eric Tzeng, Coline Devin, Judy Hoffman, Chelsea Finn, Xingchao Peng, Sergey Levine, Kate Saenko, Trevor Darrell</li><li><a href="https://arxiv.org/abs/1703.02949" target="_blank" rel="external">Learning Invariant Feature Spaces to Transfer Skills with Reinforcement Learning</a> [arXiv 2017] Abhishek Gupta, Coline Devin, YuXuan Liu, Pieter Abbeel, Sergey Levine</li><li><a href="https://arxiv.org/abs/1610.04286" target="_blank" rel="external">Sim-to-Real Robot Learning from Pixels with Progressive Nets</a> [arXiv 2016] Andrei A. Rusu Deepmind.</li><li><a href="https://arxiv.org/abs/1610.03518" target="_blank" rel="external">Transfer from Simulation to Real World through Learning Deep Inverse Dynamics Model</a>[arXiv 2016] Paul Christiano, Zain Shah, Igor Mordatch, Jonas Schneider, Trevor Blackwell, Joshua Tobin, Pieter Abbeel, and Wojciech Zaremba</li><li><a href="https://arxiv.org/abs/1710.06537" target="_blank" rel="external">Sim-to-Real Transfer of Robotic Control with Dynamics Randomization</a> [ICRA 2018] Xue Bin Peng, Marcin Andrychowicz, Wojciech Zaremba, and Pieter Abbeel</li><li><a href="https://arxiv.org/abs/1703.06907" target="_blank" rel="external">Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World</a> [IROS 2017] Josh Tobin, Rachel Fong, Alex Ray, Jonas Schneider, Wojciech Zaremba, Pieter Abbeel</li></ul><h2 id="Towards-Adapting-Deep-Visuomotor-Representations-from-Simulated-to-Real-Environments"><a href="#Towards-Adapting-Deep-Visuomotor-Representations-from-Simulated-to-Real-Environments" class="headerlink" title="Towards Adapting Deep Visuomotor Representations from Simulated to Real Environments"></a>Towards Adapting Deep Visuomotor Representations from Simulated to Real Environments</h2><p>该论文属于 Domain Adaption 类别。</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image32.png" alt="虚拟环境以及现实环境收集到的图像对比"></p><p>如上图，本文的基本思想是，无论是在模拟环境还是在现实环境智能体收集的图像中，对于任务比较重要的便是一些可控制物体或者目标的位置。因而希望学到的隐含表示能够保留这部分物体的位置信息。</p><p>以上是针对图像局部信息的约束。而对于整体图像来说，本文希望模拟环境以及现实环境在这个公共的隐含表示空间中的隐含表示无法被一个二分类器所分辨出来。另外，对于一对图片，例如上图，本文希望这一对图片的隐含表示的欧氏距离能够尽可能接近。</p><p>根据以上三个约束，可以得到以下三个损失函数：</p><p>Pose Estimation Loss:</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image33.png" alt="Pose Estimation Loss"></p><p>Domain Confusion Loss:</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image34.png" alt="Domain Confusion Loss"></p><p>其中</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image35.png" alt="q function"></p><p>Contrastive Loss:</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image36.png" alt="Contrastive Loss"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image37.png" alt="D"></p><p>而求解整个问题的最终优化目标即以上三个损失函数的加权求和：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image38.png" alt="Objective Function"></p><p>给出一个更加容易理解的框架图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image39.png" alt="Architecture"></p><p>但是这种方法存在一个问题，在计算contrastive loss时需要使用一对在模拟环境以及现实环境中能对应上的图片。这种对应关系如果需要人工完成工作量很大而且如何去分辨两张图是否是对应关系也没有一个绝对的标准。因而本文提出了一种无监督方法来自动从数据集中找出这种对应关系，具体来说分为以下五个步骤：</p><ol><li>只使用虚拟环境中收集的图片（进行位置标记）并只是用pose estimation loss训练一个表示学习网络。</li><li>使用上一步训练好的表示学习网络抽取数据集中所有图片（包括仿真环境以及真实环境）的第一个卷积特征图。</li><li>对以上特征图采用5x5的最大池化。</li><li>为每一个仿真-现实图片对计算相似度，即计算其拉直后的特征图的内积。</li><li>每一张真实环境中的图片对应的虚拟环境的图片为相似度最高的那一张。</li></ol><h2 id="Learning-Invariant-Feature-Spaces-to-Transfer-Skills-with-Reinforcement-Learning"><a href="#Learning-Invariant-Feature-Spaces-to-Transfer-Skills-with-Reinforcement-Learning" class="headerlink" title="Learning Invariant Feature Spaces to Transfer Skills with Reinforcement Learning"></a>Learning Invariant Feature Spaces to Transfer Skills with Reinforcement Learning</h2><p>这篇论文同样属于 Domain Adaption 领域，即学习一个虚拟环境以及真实环境的状态（state）的公共的隐含表示空间。其整个学习过程分为两步，第一步进行表示学习，第二步采用学习到的表示在现实环境中进行强化学习。</p><p>首先本文对需要解决的问题有如下假设：</p><blockquote><p>Assume that the reward functions share some structural similarity, in that the state distribution of an optimal policy in the source domain will resemble the state distribution of an optimal policy in the target domain when projected into some common feature space.</p></blockquote><p>即当仿真环境以及真实环境的状态同时映射到一个公共的隐含表示空间中，这两个环境所需要解决的问题的回报函数具有一定的相似性。举个例子，我们在仿真环境中构建一个拥有两个关节的机械臂希望它能够将一个冰球推到指定位置，回报函数设计为冰球与目标位置的距离的负值；然后在现实环境中，我们拥有一个有三个关节的机械臂去完成同样的任务。在这个例子中，虽然从智能体获得的图像表示完全不同（一个两关节一个三关节），但是回报函数其实是一样的，与关节数目没有关系。当然这是一个比较极端的例子，回报函数可以不完全一样。</p><p>所以本文的目标是学习两个映射函数，能够将两个环境中的状态映射到一个共同的隐含表示空间，这与上一篇论文只有一个公共的映射函数不同：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image40.png" alt="Common Feature Space"></p><p>而要能通过这个目标来求出两个映射函数，还需要做出以下假设:</p><ul><li>仿真环境以及真实环境的智能体需要学会完成同一个任务</li><li>动作空间一致，状态空间的维度一致</li></ul><p>第一个假设必须存在是由于需要从这个共同的任务中去学习这两个映射函数。这两个假设其实不算很强烈的假设，对于第一个假设来说，这个共同任务可以是一些比较简单的任务，使得训练成本较小；另外对于第二个假设，如果仿真环境以及现实环境中使用的是同一款机器人或者机械臂，动作空间一致以及状态空间的维度一致是一个非常自然的假设。</p><h3 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h3><p>要进行如上公式所示的表示学习，我们首先需要对两个环境中的状态（学会的共同任务中的状态）进行对齐（与上一篇论文里的对齐意义是一样的），这里存在两种方法进行对齐：</p><ul><li>Time-bases Alignment</li><li>Dynamic Time Wrapping</li></ul><p>第一种方法非常简单，对于两个环境中的智能体都学会解决的共同任务，如果智能体在仿真环境以及现实环境中动作执行的时钟是大致相同的，那么只要让两个环境中的智能体同时开始执行这个共同的任务，其分别产生的状态序列一定是对齐的；但是时钟相等的假设过于强烈了，因而第二种方法是一个可行性更高的方法。它是一个迭代的方法，它需要一个计算两个序列相似度的距离函数，根据这个距离函数来找出使得两个序列距离最近的对齐方式；对齐后，再根据新的对齐方式更新距离函数，如此不断迭代直至收敛或者到达停止条件。这个方法主要在于如何去选择这个距离函数，本文的做法是首先用time-bases alignment方法得到一个初始的对齐方式，再使用下面要讲到的表示学习的方法学习两个映射函数，将整个序列每一对对齐状态映射后隐含表示向量的欧氏距离的和作为dynamic time warpping方法中序列相似度的距离函数。</p><p>以上就是状态对齐步骤，下面就要进行正式的表示学习了。我们注意到，对于以上公式，其实有个非常简单的解，即这两个映射函数的是个输出永远为0的常数函数。这样一个解显然不是我们需要的，因为我们可以加上一个约束，即学习到的隐含表示能够尽可能多的保留原表示的信息，即学习到的隐含表示是一个auto encoder的隐向量。根据以上假设以及我们的优化目标，可以得到如下表示学习损失函数：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image41.png" alt="Common Feature Spaces Loss"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image42.png" alt="Auto Encoder Losses"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image43.png" alt="Objective Function"></p><p>同样给出一个更容易理解的框架图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image44.png" alt="Architecture"></p><h3 id="知识迁移"><a href="#知识迁移" class="headerlink" title="知识迁移"></a>知识迁移</h3><p>在进行了第一步的表示学习后，我们需要利用学习到的表示在现实环境中进行新任务的训练。但是注意，我们学习的表示是经过如下两个约束学到的，第一个约束可以认为是一个auto encoder的降维；第二个约束是能够与模拟环境最优策略产生的状态概率分布相同的一个隐含状态表示空间。因而我们不能单单只利用学习到隐含表示去在现实世界中训练，这样在模拟环境中训练好的策略没有办法对现实任务的训练造成任何影响，这个影响必须通过将现实任务的状态序列与模拟环境中最优策略产生的状态序列对齐后才能够实现。</p><p>本文通过对现实环境中智能体需要解决的任务的回报函数的基础上加上如下附加项来实现知识迁移：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image45.png" alt="Addition Reward Term"></p><p>这里的上标$t$表明，在进行现实环境中智能体的训练时，模拟环境必须同步运行。</p><h2 id="Sim-to-Real-Robot-Learning-from-Pixels-with-Progressive-Nets"><a href="#Sim-to-Real-Robot-Learning-from-Pixels-with-Progressive-Nets" class="headerlink" title="Sim-to-Real Robot Learning from Pixels with Progressive Nets"></a>Sim-to-Real Robot Learning from Pixels with Progressive Nets</h2><p>本方法属于 Progressive Network 类别方法，其使用的Progressive Nerual Network是迁移学习领域提出的一种网络结构，其具体形式如下图（左）所示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image46.png" alt="Progressive Neural Network"></p><p>左图中每一列（column）代表一个独立的任务，任务训练顺序从左到右。虽然任务训练顺序从简单到复杂从直觉上来看是比较合理的，但是PNN并不一定要满足这个规律， 其任务训练顺序可以是任意的。由于我们以第三列（第三个任务）为中心来考虑，因而有实线与虚线的差异。可以看到PNN的思想非常简单，在后面任务的每一层计算时，输入端并上之前任务前一层的输出即可。但是PNN扩展到强化学习中进行了如下三个改变：</p><ol><li>现实环境中使用的神经网络要比模拟环境中要小。原因主要是由于原PNN论文发现，当列数越多时每一列网络的参数都很稀疏，完全可以进行网络压缩或者剪枝。</li><li>输出层不再接受前置任务的输入。由于模拟环境与现实环境在动作空间上可能存在差异，因而在输出层借鉴前面任务的知识反而容易产生误导。</li><li>为了让智能体在现实环境中训练所需的样本量更小，因而输出层的参数直接复制之前任务的参数用来初始化，用以提升算法训练初期的探索度。</li></ol><p>值得注意的是，论文的结果还表明使用LSTM进行策略网络的建模要比使用MLP效果更好。其实还有很多其他工作也同样发现了这一点，主要还是因为大部分现实中的强化学习问题都是部分观察的，不满足马尔可夫性质。</p><h2 id="Transfer-from-Simulation-to-Real-World-through-Learning-Deep-Inverse-Dynamics-Model"><a href="#Transfer-from-Simulation-to-Real-World-through-Learning-Deep-Inverse-Dynamics-Model" class="headerlink" title="Transfer from Simulation to Real World through Learning Deep Inverse Dynamics Model"></a>Transfer from Simulation to Real World through Learning Deep Inverse Dynamics Model</h2><p>本文属于 Inverse Dynamic Model 类别。其主要基于的假设是即使虚拟环境无法对现实世界进行完全准确的建模，但是其状态的变化还是合理的。例如，对于一个将物体推到指定目标位置的任务来说，一个机械臂将冰球往前推那么下一个状态就是冰球往推动方向前进一些，但是不会往相反的方向移动。基于这个假设，首先在虚拟环境训练好一个策略，其输入是前n个时间步的状态（这里同样考虑到部分观察的问题），将输出的动作输入到虚拟环境模型中，就会转移到虚拟环境中的下一个状态。将这个状态与现实环境中的前n个时间步的状态输入到真实环境中学习到的逆动态模型中，就会得出能够输出这下一个状态所需要采取的动作。具体见下图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image49.png" alt="训练流程图"></p><p>以上过程唯一需要详细说明的便是如何在现实环境中学习一个逆动态模型，其实非常简单：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image51.png" alt="Inverse Dynamic Model"></p><p>但是这个模型的好坏取决于在现实环境中收集的样本的质量，即样本是否具有足够的多样性从而覆盖足够大的状态空间。一个简单但有效的做法是在探索时的动作上增加一定的噪声，但是加入噪声的频率等需要仔细考量否则就会使得收集到的数据质量下降，论文经过实际的实验得出以下两点经验：</p><ol><li>不需要每个时间步都加入噪声。</li><li>当现实环境中智能体执行动作发生状态转移时转移到一个与虚拟环境差别很大的状态时，就应当即时停止这一轮的采样。</li></ol><h2 id="Sim-to-Real-Transfer-of-Robotic-Control-with-Dynamics-Randomization"><a href="#Sim-to-Real-Transfer-of-Robotic-Control-with-Dynamics-Randomization" class="headerlink" title="Sim-to-Real Transfer of Robotic Control with Dynamics Randomization"></a>Sim-to-Real Transfer of Robotic Control with Dynamics Randomization</h2><p>本文属于 Domain Randomization 类别。本文出发点在于深度强化学习算法具有以下特性：</p><blockquote><p>DeepRL policies are prone to exploiting idiosyncrasies of the simulator to realize behaviours that are infeasible in the real world.</p></blockquote><p>即强化学习算法在一个特定环境中进行学习时，会尝试去挖掘某些专属于这个环境的特性从而使得算法的泛化能力很差。为此，本文将强化学习的优化目标更改如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image52.png" alt="Dynamic Randomization Problem"></p><p>这里的$\mu$代表决定环境的物理参数。如果智能体优化的是在大量不同物理参数确定的虚拟环境中累积回报的期望值的话，训练出的策略就会更加鲁棒。对于一个特定的环境，本文采用HER+RDPG算法进行最优策略的训练：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image53.png" alt="Dynamic Randomization RL Algorithm"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image54.png" alt="54"></p><p>其中的策略网络以及值函数网络采用如下方式进行建模：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image55.png" alt="Netowrk Archtectures"></p><h2 id="Domain-Randomization-for-Transferring-Deep-Neural-Networks-from-Simulation-to-the-Real-World"><a href="#Domain-Randomization-for-Transferring-Deep-Neural-Networks-from-Simulation-to-the-Real-World" class="headerlink" title="Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World"></a>Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World</h2><p>本文同样属于 Domain Randomization 类别，只不过不同于上一篇论文是随机化物理参数，本文是随机化环境的视觉表示。具体来说，本文是想学习一个定位器，通过输入一张图片来定位其中所有目标物体的三维坐标：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image59.png" alt="Domain Randomization"></p><p>具体需要随机化的视觉信息包括：</p><ul><li>桌子上所有目标物体的位置以及纹理</li><li>桌子、地板、背景以及机械臂的纹理</li><li>摄像机的位置、朝向以及可视范围</li><li>场景中光源的数量</li><li>场景中光源的位置、朝向以及光谱特征</li><li>加入到图像中噪声的类型以及数量</li></ul><h1 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h1><p>在这一部分我将介绍一下OpenAI在sim2real领域做出的一个工作，其地位类似于多智能体强化学习领域的OpenAI Five。</p><h2 id="Learning-Dexterous-In-Hand-Manipulation"><a href="#Learning-Dexterous-In-Hand-Manipulation" class="headerlink" title="Learning Dexterous In-Hand Manipulation"></a>Learning Dexterous In-Hand Manipulation</h2><p>这个例子主要用到的技术包括以下几点：虚拟环境的随机化、大规模分布式采样以及精确的虚拟环境搭建。其所需要完成的任务是：使用一个具有20个自由度的机械手，将其手掌中的立方体从初始朝向利用手指翻转到目标朝向：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image68.png" alt="Task"></p><p>为了建立一个足够精细（但是依旧存在无法建模的物理量）的虚拟环境，OpenAI以机械手为球心半径为80厘米的球面上均匀分布了16个精度为20微米的追踪器，能够定位机械手任意位置的微小位移。之所以采用如此高精度的追踪器是为了尽可能准确地对机械手的相关物理参数，例如手指关节处的阻尼等等，这样的物理参数有将近500个。我认为这个工作之所以能够直接将虚拟环境中学习到的最优策略直接应用到现实环境中，这个高精度的虚拟环境功不可没：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image69.png" alt="真实环境 vs 虚拟环境"></p><p>整个系统的训练步骤大致可分为以下三个部分（最后是训练完毕的执行部分）：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image70.png" alt="系统流程图"></p><p>下面将详细对每一个部分进行说明。首先是第一个部分，包括模拟环境中数据的并行采样以及整个强化学习的参数更新框架：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image72.png" alt="分布式数据采集以及参数更新"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image71.png" alt="分布式架构"></p><p>上图中采用的分布式数据收集以及模型训练框架同样也是OpenAI Five所采用的。从左下方开始，多个并行采样的worker会将自己根据当前策略采集的样本发送给与自己相关联的Redis服务器上，模型更新模块中的Puller将会定期异步地从Redis服务器中拉取一个batch的数据并放到RAM中，之后Stager从RAM中拉取一个mini-batch放到GPU上，与其他采用MPI协议联系的GPU一起对参数进行更新。更新后的参数将每个Optimizer都保存一份。之后Optimizer沿着之前相反的路径将更新后的参数存储到Redis服务器上，workers将定期异步地从Redis服务器上拉取最新的策略参数进行采样。整个训练过程就是以上过程的迭代。下图表示了不同规模的并行对于最终算法性能的影响：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image73.png" alt="不同并行度对于最终算法性能的影响"></p><p>第二部分，具体的强化算法选用的是PPO算法，其策略网络以及值函数网络建模如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image75.png" alt="强化学习算法架构"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image74.png" alt="策略网络以及值函数网络结构"></p><p>其中输入部分左边代表机械手的状态，右边代表物体的朝向，具体的维度如下所示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image76.png" alt="状态空间"></p><p>由于PPO算法的值函数网络只会在训练时使用到，因而采用完整信息对其进行训练。在训练时算法采用了如下三种随机注入方法：</p><ul><li>Dynamic Randomization</li><li>Domain Randomization</li><li>Unmodeled Effects Randomization</li></ul><p>具体见下面三张图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image77.png" alt="Dynamic Randomization"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image79.png" alt="Domain Randomization"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image78.png" alt="Unmodeled Effects Randomization"></p><p>最后一部分，由于机械手的任务不应该局限于转动方块，还应该包括操纵其他物体。而且由第二部分可知策略网络以及值函数网络的输入可知需要立方体的朝向以及位置信息，目前是通过16个高精度追踪器确定的。OpenAI为了提高整个系统的通用性，因而在方块的周围相隔一定高度120度角均匀放置了三个摄像头，尝试学习一个模型，输入是三张不同角度的图片，输出是立方体的位置以及朝向。这样就可以把立方体换为任意的物体。其具体的网络结构如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image81.png" alt="Object Pose Prediction"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image80.png" alt="Pose Prediction Network Architecture"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Ewan Li"><p class="site-author-name" itemprop="name">Ewan Li</p><p class="site-description motion-element" itemprop="description">Ewan's IT Blog</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">131</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">64</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ewanlee" target="_blank" title="Github"><i class="fa fa-fw fa-globe"></i> Github </a></span><span class="links-of-author-item"><a href="https://twitter.com/tomaxent" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Ewan Li</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">Theme - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user">本站访客数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次</span> <span class="site-pv"><i class="fa fa-eye">本站总访问量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">_hcwp=window._hcwp||[],_hcwp.push({widget:"Bloggerstream",widget_id:89825,selector:".hc-comment-count",label:"{%COUNT%}"}),function(){if(!("HC_LOAD_INIT"in window)){HC_LOAD_INIT=!0;var t=(navigator.language||navigator.systemLanguage||navigator.userLanguage||"en").substr(0,2).toLowerCase(),e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src=("https:"==document.location.protocol?"https":"http")+"://w.hypercomments.com/widget/hc/89825/"+t+"/widget.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n.nextSibling)}}()</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),n=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,n=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=n&&a.forEach(function(e,t){i=n.indexOf(e),l=s.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+n+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),n.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("e27VKX5tTklQLCtF7iNMmhcA-gzGzoHsz","nnQn2znNgXXEdK7W2bVJ3bfK")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html>