<!doctype html><html class="theme-next mist use-motion" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/atom.xml" title="Abracadabra" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="Ewan&apos;s IT Blog"><meta property="og:type" content="website"><meta property="og:title" content="Abracadabra"><meta property="og:url" content="http://yoursite.com/index.html"><meta property="og:site_name" content="Abracadabra"><meta property="og:description" content="Ewan&apos;s IT Blog"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Abracadabra"><meta name="twitter:description" content="Ewan&apos;s IT Blog"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/"><title>Abracadabra</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?dc405a79ad500922134d14cdf288f646";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Abracadabra</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Do it yourself</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div><span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/" itemprop="url">How to make an optimal decision in the case of knowing the environment model(CS294 lecture notes) ?</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-25T01:31:40+08:00">2019-03-25 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/" itemprop="commentsCount"></span> </a></span><span id="/2019/03/25/How-to-make-an-optimal-decision-in-the-case-of-knowing-the-environment-model-CS294-lecture-notes/" class="leancloud_visitors" data-flag-title="How to make an optimal decision in the case of knowing the environment model(CS294 lecture notes) ?"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>首先我们假设环境是确定性的，即在某个状态执行某个动作之后，转移到的下一个状态是确定的，不存在任何随机性。而在这种情况下，我们想做的是在环境给了我们一个初始状态的条件下，根据我们需要完成的任务以及环境模型，直接得出从初始状态到任务完成状态中间最优的动作序列。因为环境是确定的，而我们又已知环境模型，因而以上想法是自然且可行的。下图展示了我们想做的事情：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/2.png" alt="目标任务"></p><p>现在我们将以上问题抽象成一个正式的优化问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/1.png" alt="优化目标"></p><p>其中$f$就代表环境模型。但是一旦环境不再是确定的，即正在某个状态执行某个动作之后，转移到的下一个状态是从一个状态分布中随机采样的。对于这种情况，上述的优化问题就会转变为最大化如下形式的期望值：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/3.png" alt="期望优化目标"></p><p>但是在随机环境下，解决与确定环境的类似的如上优化问题并不能得到与确定环境一样的最优解。原因在于我们只接受环境反馈回来的初始状态，接着便凭借着我们掌握的环境模型在脑海中进行规划。这种方法在确定环境下没有任何问题，但在随机环境下，智能体实际会转移到的状态可能并不符合我们的预期，因为它是从一个条件状态分布中随机采样的。而一旦从某一个状态开始与我们的预期产生偏差，那么后续的所有状态都会产生偏差，而我们设想的最优动作序列便不是最优了。从优化函数的角度来看，我们优化的只是一个期望值，而不是某一次随机采样的值。</p><p>我们把上述解决问题的方法叫做开环方法，与之对应的叫做闭环方法。那么这个“环”具体是指什么呢？具体示意图如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/4.png" alt="环"></p><p>开环方法是只在最开始时接收环境反馈的初始状态，然后开始规划从开始到任务完成的过程中所经历的所有状态对应的最优动作，并不需要一个基于状态产生动作的<strong>策略</strong>；反之，闭环方法在每一个时间步都会接收环境反馈的状态，然后利用一个根据状态输出动作的<strong>策略</strong>来产生一个动作。我们可以看出，对于一个随机环境，闭环方法显然比开环方法更具优势，因为其可以根据所处的状态随时调整自己的动作。</p><p>但接下来我们还是首先假定一个确定性的环境，因而采用开环方法来解决上述问题。下面将介绍三种优化方法：随机优化方法、蒙特卡洛树搜索法以及轨迹优化方法。</p><h2 id="随机优化方法"><a href="#随机优化方法" class="headerlink" title="随机优化方法"></a>随机优化方法</h2><p>对于随机优化方法来讲，上述优化问题可以简化为如下等价优化问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/5.png" alt="随机优化目标"></p><p>随机优化方法完全不关系优化目标的特殊结构等信息，而是把任何优化问题都当作上图右半边这样的一般优化问题。</p><h3 id="随即发射方法"><a href="#随即发射方法" class="headerlink" title="随即发射方法"></a>随即发射方法</h3><p>最简单的随机优化方法就是随机瞎猜，即随机选择一个动作序列，然后评估其累积的代价。如上过程不断进行，最后选择一个累积代价最小的动作序列作为上述优化问题的最优解，因而这类方法也叫做“随机发射方法”：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/6.png" alt="随机发射方法"></p><h3 id="CMA算法"><a href="#CMA算法" class="headerlink" title="CMA算法"></a>CMA算法</h3><p>但是这种方法在相对高维的情况下效率会很低，因为搜索空间太大但是目标区域比较小。回顾一下上述方法，我们可以在采样分布上做些文章。假设第一次从一个均匀分布采样一些动作序列之后，得到的累积代价分别为如下情况：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/7.png" alt="随机采样"></p><p>那么下一次我们可以不再继续从一个均匀分布中采样了，我们可以聚焦于累积代价较小（累积回报较大）的区域，然后估计那个区域的分布，在这里我们假设分布是一个高斯分布：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/8.png" alt="估计分布"></p><p>接下来的采样我们就从这个新的分布中进行采样：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/9.png" alt="新的采样结果"></p><p>然后在下一次采样之前，我们再次聚焦于性能更好的区域然后估计其分布：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/10.png" alt="再次估计分布"></p><p>就这样不断迭代，直到满足停止条件。以上方法就是Cross-Entropy Method(CEM)算法，其伪代码如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/11.png" alt="CEM算法"></p><p>该方法还有个进阶版的算法叫做CMA-ES算法，后者可以看作是CMA算法带动量的版本。CMA算法会直接舍弃之前采样的数据点，但是CMA-ES算法会保留部分之前采样的数据点的相关信息，用来指导后续的采样。可以类比一下梯度下降法以及带动量的梯度下降法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>随机优化方法具有以下优点：</p><ul><li>并行化后效率极高</li><li>实现起来十分简单</li></ul><p>但是也存在如下不可避免地缺点：</p><ul><li>极易受到维度灾难的影响</li><li>只适用于开环情形</li></ul><p>随即优化方法虽然可以同时适用于连续变量以及离散变量的情况，但不是专门为离散情况设计的。下面我们将介绍一种专门为离散动作空间设计的强大的优化方法（严格来讲叫做启发式搜索算法）：蒙特卡洛树搜索MCTS方法。</p><h2 id="蒙特卡洛树搜索算法"><a href="#蒙特卡洛树搜索算法" class="headerlink" title="蒙特卡洛树搜索算法"></a>蒙特卡洛树搜索算法</h2><p>MCTS方法本质是一个搜索算法：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/12.png" alt="搜索算法"></p><p>假设我们想要训练一个智能体能够自动去玩上面这个游戏（击沉敌方潜水艇将会获得分数，但是潜水艇自身的氧气储存量是逐渐减少的，需要不时地去浮出水面补充氧气。被敌方潜水艇撞上会损失生命值，游戏目标就是获得尽可能多的分数）。一个简单的暴力搜索算法可能会包含上图右边的过程，假设一段最优动作序列仅仅包含十个时间步，每个状态下仅仅包含两个可能动作，那么最后一个时间步就包含1024个可能性。但对于大多数问题来说，十个时间步远远不足以完成目标，因而暴力搜索算法是不可行的。</p><p>那么蒙特卡洛算法是如何在不穷举所有可能性直到到达终点的情况下对一个动作序列进行评估的呢？考虑潜水艇游戏，在潜水艇做出攻击指令后，由于炮弹的运行需要时间，因而几个时间步之后敌方潜水艇才会被击沉从而受到奖励，在潜水艇做出攻击指令那个时间步是没有任何奖励的，因而智能体可能认为这个动作并不是一个优秀的动作。对于以上情况，其实我们只需要在做出攻击指令后，如果要评估这个动作的优劣，“等待”几个时间步 即可。蒙特卡洛树搜索算法正是采用这种思想，同样用上图右边的过程举例，当动作执行到第三层时，如何评估这四个动作序列的性能好坏呢？算法进行了某种“等待”，即从第三层开始，不再把树进行完全的扩展了，而是采用一个随机策略随机执行动作直到游戏结束或者到达某个设定的时间步。这就类似于在潜水艇游戏中，潜水艇在发出炮弹后，随机执行一些动作，直到炮弹击中敌方潜水艇。</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/13.png" alt="评估过程"></p><p>而蒙特卡洛算法正是通过这种评估方法来避免暴力搜索，具体来说，蒙特卡洛树搜索算法会根据评估结果的好坏以及访问次数来决定下一步应该搜索哪一条路径：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/14.png" alt="搜索策略"></p><p>可能以上描述有点难以理解，那么下面我们过一遍蒙特卡洛树搜索方法的搜索过程。我们首先给出算法的执行步骤：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/28.png" alt="蒙特卡洛树搜索算法框架"></p><p>首先我们处于一个初始状态：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/15.png" alt="初始状态"></p><p>然后我们进行算法第一步，根据一个“树策略”找到一个叶子节点，注意这里找到一个叶节点的意思是找到一个<em>*新的</em>叶节点。树策略的具体形式如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/29.png" alt="树策略"></p><p>根据以上策略，由于初始状态没有被完全扩展，因而随机选择一个动作，并执行第二步使用<strong>默认策略</strong>来评估执行这个动作的好坏，这里默认策略使用的是随机采样策略：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/16.png" alt="随机选择"></p><p>假设评估结果如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/17.png" alt="评估结果"></p><p>这里Q代表环境定义的回报，N代表访问这个状态的次数。<strong>这里值得注意的是，N记录的并不是某个具体的状态的访问次数，而是执行某个动作的次数，执行这个动作后在随机环境下可能转移到很多个不同的状态，但在树中均显示为一个节点。</strong>评估完之后，我们需要更新根节点到这个新加入的叶节点之间所有节点的Q值以及N值。由于这里两者之间并没有其他的节点，因而跳过这一步。然后以上过程开始循环，<strong>我们再将状态跳回到初始状态</strong>，遵循树策略，找到下一个新的叶节点。由于初始状态还是没有扩展完毕，因此这一次执行下一个未被执行过的状态：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/18.png" alt="第二轮随机选择"></p><p>再采用默认策略对其进行评估，假设我们得到了以下结果：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/19.png" alt="初始状态"></p><p>由于根节点与新的叶节点之间的路径并没有其他节点，因而更新步骤略过。再次重复以上过程，将状态跳回到初始状态，执行树策略找到一个新的叶节点。首先根据树策略，初始状态已经被完全扩展开了（即所有可能的动作均已经执行过），这个时候我们根据树策略中的公式计算每一条路径的一个<strong>分数</strong>。从分数计算公式可以看出，这个分数是同时考虑动作的回报以及动作的执行次数，更加倾向于执行被执行次数少的回报高的动作。在这里，由于两个动作被执行次数均为1，因而我们选择回报更高的第二个动作执行，然后再根据树策略（<strong>在没有找到新的叶节点之前，循环执行树策略</strong>），第二层的状态没有被完全扩展，因而随机选择一个动作执行：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/20.png" alt="再次找到新的叶节点"></p><p>依据默认策略进行评估：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/21.png" alt="采用默认策略评估"></p><p><strong>注意，到了这一步，根节点到新的叶节点之间的路径存在其他节点了，我们就要用最新的叶节点的评估值以及访问次数加到这些中间节点的评估值以及访问次数上：</strong></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/22.png" alt="更新中间节点"></p><p>再次重复上述过程，将状态跳回到初始状态，调用树策略，这时候根据分数计算公式，在假设一些超参数的情况下，我们假定这个时候更加侧重于执行被执行次数更小的动作并评估：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/23.png" alt="侧重被访问次数更少的动作"></p><p>然后再更新再跳回……</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/24.png" alt="循环"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/25.png" alt="循环"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/26.png" alt="循环"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/27.png" alt="循环"></p><p>如果想详细了解蒙特卡洛树搜索算法的扩展以及应用，可以参考下面这篇综述：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/30.png" alt="综述"></p><p>这里讲一个比较有意思的案例：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/31.png" alt="利用蒙特卡洛树搜索算法进行模仿学习"></p><p>其思想其实是将DAgger算法与MCTS算法进行结合。由于DAgger算法需要人工的不断参与进行新数据的标注，以上案例将专家标注的过程用MCTS算法进行替代，学习一个MCTS的策略估计器：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/32.png" alt="DAgger"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/33.png" alt="DAgger with MCTS"></p><p>那么为什么不直接使用MCTS算法呢？其实是基于以下两点考虑的：</p><ul><li>实时性要求较高的任务中MCTS太慢了</li><li>采用类似神经网络的策略估计器具有更好的泛化性</li></ul><h2 id="路径优化算法"><a href="#路径优化算法" class="headerlink" title="路径优化算法"></a>路径优化算法</h2><p>让我们再次回顾以下优化问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/1.png" alt="优化目标"></p><p>直接丢弃掉以上优化问题中的特殊结构显然不是十分恰当的，接下来让我们回到一般解决以上优化问题的思路。我们一看到以上问题，就会首先想到能不能利用类似梯度下降的方法呢？为了与最优控制中路径优化算法的一般符号记法一致，我们将以上问题重写为以下形式：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/34.png" alt="路径优化问题的优化目标"></p><p>我们可以将约束部分放进优化函数中从而将以上问题转变为一个无约束问题：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/35.png" alt="无约束形式"></p><p>对于以上问题，只要我们知晓以下四项，即可根据链式法则得出其最优解：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/36.png" alt="需要知道的梯度"></p><h3 id="LQR算法"><a href="#LQR算法" class="headerlink" title="LQR算法"></a>LQR算法</h3><h4 id="确定性环境"><a href="#确定性环境" class="headerlink" title="确定性环境"></a>确定性环境</h4><p>为了解决以上优化问题，我们接下来将介绍一种路径优化算法<strong>LQR</strong>，此算法<strong>假设环境模型是线性的，并且代价函数是二次的</strong>：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/37.png" alt="LQR优化目标"></p><p>为了解决这种特殊形式的以上优化问题，我们采用<strong>动态规划</strong>的思想，<strong>先找出最优的最后一个时间步的动作</strong>。之所以这样做，是因为我们可以发现，以上连加项中只有最后一项是与最后一个时间步的动作相关的。如果我们首先解决第一个时间步的最优动作，那么连加项的所有项都与第一个时间步的动作相关。接下来，我们把最后一项中连续的函数求值简写为$x_{T}$，<strong>注意这个值是未知的</strong>。进行了以上的准备工作后，求解最后一个时间步的最优动作对应的优化目标如下，我们把其记为$Q(x_T,u_T)$：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/38.png" alt="Q值函数"></p><p>然后我们将线性项系数以及二次项系数展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/39.png" alt="系数展开"></p><p>然后，为了得出最优动作，我们令这个优化目标关于最后一个时间步动作的梯度等于0：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/40.png" alt="最小化Q值函数"></p><p>求解以上线性方程，可以得出最后一个时间步的最优动作为：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/41.png" alt="最后一个时间步的最优动作"></p><p>将其进行简单的转化，我们可以看出，<strong>最后一个时间步的最优动作是最后一个时间步状态（现在还是未知项）的线性函数（以上关系适用于所有时间步）</strong>：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/42.png" alt="最后一个时间步的动作是状态的线性函数"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/43.png" alt="系数的具体形式"></p><p>由于最后一步的最优动作完全可以用最后一步的状态表示，我们可以得出最后一个时间步的最优的Q值，这里我们将其记为V：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/44.png" alt="最后一个时间步的最优Q值"></p><p><strong>这里的Q值以及V值其实是和强化学习中的定义是一致的。</strong>接下来，我们将上式展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/45.png" alt="V值展开"></p><p>将上式合并同类项可得：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/46.png" alt="合并同类项"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/47.png" alt="系数具体形式"></p><p>因而我们可以得到另一个关系，<strong>最后一个时间步的V值（最优Q值）是最后一个时间步状态的二次函数（以上关系适用于所有时间步）。</strong>进行到这里，我们已经解出最后一个时间步的最优动作了。接下来，我们要在此基础上解出倒数第二个时间步的最优动作。首先我们注意到，倒数第二个时间步的Q值函数可以记为：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/49.png" alt="倒数第二个时间步的Q值函数"></p><p>将环境模型引入可将V值展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/48.png" alt="环境模型"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/50.png" alt="展开后的V值"></p><p>我们将展开后的V值代入倒数第二时间步的Q值函数中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/51.png" alt="带入展开后V值的倒数第二个时间步的Q值函数"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/52.png" alt="系数具体形式"></p><p>同样，为了求出倒数第二个时间步的最优动作，我们令相关梯度为零：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/53.png" alt="最小化Q值函数"></p><p>解得倒数第二个时间步的最优动作为：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/54.png" alt="倒数第二个时间步的最优动作"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/55.png" alt="系数具体形式"></p><p>让我们不断地重复以上过程，直到第一个时间步。<strong>值得注意的是，由于每一时间步的最优动作与那个时间步的状态有关，但是状态是未知的。</strong></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/56.png" alt="循环以上过程"></p><p>当整个过程回溯到初始时间步时，情况发生了变化，<strong>初始状态我们是已知的！</strong>因而，我们就可以算法初始时间步的最优动作。利用环境模型，我们就可以得知第二个时间步的状态，如此循环下去，我们就可以得知所有时间步的最优动作：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/57.png" alt="前向循环"></p><p>以上就是整个LQR算法的执行过程。</p><h4 id="非确定性环境-（未完成）"><a href="#非确定性环境-（未完成）" class="headerlink" title="非确定性环境 （未完成）"></a>非确定性环境 （未完成）</h4><p>对于非确定性环境，假设我们的环境模型如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/58.png" alt="随机环境模型"></p><p><strong>那么LQR算法依旧是完全可行的。</strong></p><h3 id="iLQR算法"><a href="#iLQR算法" class="headerlink" title="iLQR算法"></a>iLQR算法</h3><p>LQR算法由于假设环境模型以及代价函数是线性以及二次的，表达能力有限，对于更加复杂的任务显然不能很好的估计。因而，解决这个问题的iLQR算法应运而生。其基本思想很简单，既然线性以及二次函数不足以估计全局的真实函数，那么估计局部的总是足够的。因而我们可以<strong>对环境模型以及代价函数分别做一阶以及二阶的泰勒展开！</strong>：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/59.png" alt="泰勒展开"></p><p>那么我们的问题其实又转变回了原始的LQR设定：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/60.png" alt="原始设定"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/61.png" alt="参数具体形式"></p><p>iLQR算法的具体框架如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/62.png" alt="iLQR算法"></p><p><strong>该算法之所以采用迭代的形式，是因为其需要不断地用真实样本来去”矫正“其对于环境模型以及代价函数的估计。</strong>更严格来讲，该算法之所以能够达到很好的效果，是因为它和牛顿方法的本质是一样的（通过泰勒展示来估计一个复杂的非线性函数的局部特性）：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/63.png" alt="牛顿方法"></p><p>而如果我们对环境模型估计时也进行二阶泰勒展开：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/64.png" alt="参数具体形式"></p><p>那么我们的算法就变为微分动态规划算法（DDP）。但是在实际情况中，代价函数的形式一般比较简单，因而进行二阶泰勒展开代价不大。但是环境模型一般是十分复杂的，一阶展开还好，一旦进行二阶展开其复杂性将会大大增加。事实表明一阶展开其实是足够的。</p><p>但是以上算法还存在一个问题，考虑以下估计误差：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/65.png" alt="局部估计误差"></p><p>对于这种情况，其实我们只要简单的在原始iLQR算法中加一个line search过程即可：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/66.png" alt="Line Search"></p><p>最后我们看一个iLQR算法在实际情况应用的实例：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/67.png" alt="实例"></p><p>为了保证iLQR更加稳定，这个工作采用了如下形式的改进：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/CS294-112-Fa19-9-26-18/68.png" alt="改进"></p><p><strong>即在每一步都进行一个完整的规划，但是考虑到iLQR的估计误差随着时间会产生累积，因而每次只执行规划的第一步。</strong></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/TD-VAE/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/03/20/TD-VAE/" itemprop="url">TD-VAE [ICLR 2019]</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T21:51:58+08:00">2019-03-20 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/03/20/TD-VAE/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/03/20/TD-VAE/" itemprop="commentsCount"></span> </a></span><span id="/2019/03/20/TD-VAE/" class="leancloud_visitors" data-flag-title="TD-VAE [ICLR 2019]"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>【笔记版】</p><p>今天要讲的是ICLR2019中DeepMind的一个工作，TD-VAE，一个<strong>序列生成模型</strong>。通过引入强化学习中<strong>时序差分</strong>以及<strong>变分自动编码器</strong>，来实现从当前时间步到未来时间步的预测。这里值得注意的是，TD-VAE并不是一个固定时间步的序列生成模型（当然如果训练时喂的训练数据是一个时间间隔固定的序列数据，那么训练出的模型就是固定时间步的序列生成模型），即其生成的数据时间间隔不是一个固定的时间步，而是随机的。如果想生成数据的时间间隔可控，那么可以在前向模型的建模中显式地将时间步作为变量即可。</p><p>这篇论文的作者认为，一个序列生成模型需要具备以下三点属性：</p><ul><li>这个模型应该学习一个数据的抽象<em>状态表示</em>并且在状态空间中进行预测，而不是在观察空间进行预测。</li><li>这个模型应该学习一个<em>置信状态</em>，这个状态需要包含目前为止智能体对于周围环境的所有感知信息。置信状态相当于状态表示的隐变量。</li><li>这个模型应该表现出<em>时序抽象</em>，既能够直接预测多个时间步之后的状态，也能够只通过两个独立的时间点进行训练而不需要中间所有时间点的信息。</li></ul><h1 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h1><p>TD-VAE的目标便是优化以下对数条件似然：<br>$$<br>\log p(x_t|x_{&lt;t})<br>$$<br>这里假设$x_t$可以通过该时间步以及上一个时间步的状态表示$z_t$和$z_{t-1}$推断得出，类似于VAE中损失函数的推导过程，这里同样引入ELBO，具体推导过程如下图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/2.jpg" alt="推导过程"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/3.jpg" alt="推导过程"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/4.jpg" alt="推导过程"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/5.jpg" alt="推导过程"></p><p>最后的损失函数包含以下几个部分：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/9.png" alt="损失函数1"></p><p>然后我们把两个连续时间步的状态表示换为两个任意时刻的状态表示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/10.png" alt="损失函数2"></p><p>这实质上是如下VAE的损失函数：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/8.jpg" alt="VAE"></p><p>其中$t2&gt;t1$。整个损失函数可以直观地解释为以下四个部分组成：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/15.png" alt="直观解释1"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/16.png" alt="直观解释2"></p><p>训练时的计算图如下所示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/11.png" alt="计算图"></p><p>最后在三个不同任务上的实验结果：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/12.png" alt="直观解释1"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/13.png" alt="直观解释1"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/TD-VAE/14.png" alt="直观解释1"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/Survey-of-Sim2Real-Part-I/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/03/20/Survey-of-Sim2Real-Part-I/" itemprop="url">Survey of Sim2Real: Part I</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T21:50:53+08:00">2019-03-20 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/03/20/Survey-of-Sim2Real-Part-I/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/03/20/Survey-of-Sim2Real-Part-I/" itemprop="commentsCount"></span> </a></span><span id="/2019/03/20/Survey-of-Sim2Real-Part-I/" class="leancloud_visitors" data-flag-title="Survey of Sim2Real: Part I"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>最近survey了一下sim2real领域最近的相关工作，先整理个第一版（共有七篇论文）的总结。</p><p>整篇总结分为以下四个部分：</p><ul><li>问题的定义以及工作的出发点</li><li>方法的分类</li><li>具体算法</li><li>一个实例</li></ul><h1 id="问题的定义以及工作的出发点"><a href="#问题的定义以及工作的出发点" class="headerlink" title="问题的定义以及工作的出发点"></a>问题的定义以及工作的出发点</h1><p>sim2real的全称是simulation to reality，是强化学习的一个分支，同时也属于transfer learning的一种。主要解决的问题是机器人领域中，直接让机器人或者机械臂在现实环境中与环境进行交互、采样时，会出现以下两个比较严重的问题：</p><ul><li>采样效率太低（在用强化学习算法解决机器人相关问题时，所需要的样本量一般会达到上千万，在现实环境中采集如此数量级的样本要耗费几个月的时间）</li><li>安全问题 （由于强化学习需要通过智能体在环境中进行大范围的随机采样来进行试错，因而在某些时刻其做出的行为可能会损伤机器人自身，例如手臂转动角度过大或者避障任务中由于碰撞造成的不可逆损伤等等；也可能会损害周围的环境甚至生物）</li></ul><p>但是如果我们在模拟器中进行强化学习算法的训练，以上两个问题均可迎刃而解。但是，这里同样会存在一个问题，由于模拟器对于物理环境的建模都是存在误差的，因而在模拟环境中学习到的最优策略是否可以直接在现实环境中应用呢？答案往往是否定的，我们把这个问题称为 “reality gap”。而sim2real的工作就是去尝试解决这个问题。</p><p>这里值得注意的一点是，虽然这个方向叫做sim2real，其实其中的所有的算法都可以直接应用在sim2sim，real2real等的任务中。</p><h1 id="方法的分类"><a href="#方法的分类" class="headerlink" title="方法的分类"></a>方法的分类</h1><p>sim2real中的典型工作大致可以分为以下五类：</p><ul><li><strong>Domain Adaption</strong> 主要是通过学习一个模拟环境以及现实环境共同的状态到隐变量空间的映射，在模拟环境中，使用映射后的状态空间进行算法的训练；因而在迁移到现实环境中时，同样将状态映射到隐含空间后，就可以直接应用在模拟环境训练好的模型了。</li><li><strong>Progressive Network</strong> 利用一类特殊的Progressive Neural Network来进行sim2real。其主要思想类似于cumulative learning，从简单任务逐步过渡到复杂任务（这里可以认为模拟器中的任务总是要比现实任务简单的）。</li><li><strong>Inverse Dynamic Model</strong> 通过在现实环境中学习一个逆转移概率矩阵来直接在现实环境中应用模拟环境中训练好的模型。</li><li><strong>Domain Randomization</strong> 对模拟环境中的视觉信息或者物理参数进行随机化，例如对于避障任务，智能体在一个墙壁颜色、地板颜色等等或者摩擦力、大气压强会随机变化的模拟环境中进行学习。</li></ul><h1 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h1><p>这一部分将对以下六篇论文进行详细的说明：</p><ul><li><a href="https://pdfs.semanticscholar.org/a74a/420189a44c82a21f0ae79d0415bc9964116d.pdf?_ga=2.240723076.62241912.1552892977-1147771314.1552892977" target="_blank" rel="external">Towards Adapting Deep Visuomotor Representations from Simulated to Real Environments</a>[arXiv 2015] Eric Tzeng, Coline Devin, Judy Hoffman, Chelsea Finn, Xingchao Peng, Sergey Levine, Kate Saenko, Trevor Darrell</li><li><a href="https://arxiv.org/abs/1703.02949" target="_blank" rel="external">Learning Invariant Feature Spaces to Transfer Skills with Reinforcement Learning</a> [arXiv 2017] Abhishek Gupta, Coline Devin, YuXuan Liu, Pieter Abbeel, Sergey Levine</li><li><a href="https://arxiv.org/abs/1610.04286" target="_blank" rel="external">Sim-to-Real Robot Learning from Pixels with Progressive Nets</a> [arXiv 2016] Andrei A. Rusu Deepmind.</li><li><a href="https://arxiv.org/abs/1610.03518" target="_blank" rel="external">Transfer from Simulation to Real World through Learning Deep Inverse Dynamics Model</a>[arXiv 2016] Paul Christiano, Zain Shah, Igor Mordatch, Jonas Schneider, Trevor Blackwell, Joshua Tobin, Pieter Abbeel, and Wojciech Zaremba</li><li><a href="https://arxiv.org/abs/1710.06537" target="_blank" rel="external">Sim-to-Real Transfer of Robotic Control with Dynamics Randomization</a> [ICRA 2018] Xue Bin Peng, Marcin Andrychowicz, Wojciech Zaremba, and Pieter Abbeel</li><li><a href="https://arxiv.org/abs/1703.06907" target="_blank" rel="external">Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World</a> [IROS 2017] Josh Tobin, Rachel Fong, Alex Ray, Jonas Schneider, Wojciech Zaremba, Pieter Abbeel</li></ul><h2 id="Towards-Adapting-Deep-Visuomotor-Representations-from-Simulated-to-Real-Environments"><a href="#Towards-Adapting-Deep-Visuomotor-Representations-from-Simulated-to-Real-Environments" class="headerlink" title="Towards Adapting Deep Visuomotor Representations from Simulated to Real Environments"></a>Towards Adapting Deep Visuomotor Representations from Simulated to Real Environments</h2><p>该论文属于 Domain Adaption 类别。</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image32.png" alt="虚拟环境以及现实环境收集到的图像对比"></p><p>如上图，本文的基本思想是，无论是在模拟环境还是在现实环境智能体收集的图像中，对于任务比较重要的便是一些可控制物体或者目标的位置。因而希望学到的隐含表示能够保留这部分物体的位置信息。</p><p>以上是针对图像局部信息的约束。而对于整体图像来说，本文希望模拟环境以及现实环境在这个公共的隐含表示空间中的隐含表示无法被一个二分类器所分辨出来。另外，对于一对图片，例如上图，本文希望这一对图片的隐含表示的欧氏距离能够尽可能接近。</p><p>根据以上三个约束，可以得到以下三个损失函数：</p><p>Pose Estimation Loss:</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image33.png" alt="Pose Estimation Loss"></p><p>Domain Confusion Loss:</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image34.png" alt="Domain Confusion Loss"></p><p>其中</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image35.png" alt="q function"></p><p>Contrastive Loss:</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image36.png" alt="Contrastive Loss"></p><p>其中：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image37.png" alt="D"></p><p>而求解整个问题的最终优化目标即以上三个损失函数的加权求和：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image38.png" alt="Objective Function"></p><p>给出一个更加容易理解的框架图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image39.png" alt="Architecture"></p><p>但是这种方法存在一个问题，在计算contrastive loss时需要使用一对在模拟环境以及现实环境中能对应上的图片。这种对应关系如果需要人工完成工作量很大而且如何去分辨两张图是否是对应关系也没有一个绝对的标准。因而本文提出了一种无监督方法来自动从数据集中找出这种对应关系，具体来说分为以下五个步骤：</p><ol><li>只使用虚拟环境中收集的图片（进行位置标记）并只是用pose estimation loss训练一个表示学习网络。</li><li>使用上一步训练好的表示学习网络抽取数据集中所有图片（包括仿真环境以及真实环境）的第一个卷积特征图。</li><li>对以上特征图采用5x5的最大池化。</li><li>为每一个仿真-现实图片对计算相似度，即计算其拉直后的特征图的内积。</li><li>每一张真实环境中的图片对应的虚拟环境的图片为相似度最高的那一张。</li></ol><h2 id="Learning-Invariant-Feature-Spaces-to-Transfer-Skills-with-Reinforcement-Learning"><a href="#Learning-Invariant-Feature-Spaces-to-Transfer-Skills-with-Reinforcement-Learning" class="headerlink" title="Learning Invariant Feature Spaces to Transfer Skills with Reinforcement Learning"></a>Learning Invariant Feature Spaces to Transfer Skills with Reinforcement Learning</h2><p>这篇论文同样属于 Domain Adaption 领域，即学习一个虚拟环境以及真实环境的状态（state）的公共的隐含表示空间。其整个学习过程分为两步，第一步进行表示学习，第二步采用学习到的表示在现实环境中进行强化学习。</p><p>首先本文对需要解决的问题有如下假设：</p><blockquote><p>Assume that the reward functions share some structural similarity, in that the state distribution of an optimal policy in the source domain will resemble the state distribution of an optimal policy in the target domain when projected into some common feature space.</p></blockquote><p>即当仿真环境以及真实环境的状态同时映射到一个公共的隐含表示空间中，这两个环境所需要解决的问题的回报函数具有一定的相似性。举个例子，我们在仿真环境中构建一个拥有两个关节的机械臂希望它能够将一个冰球推到指定位置，回报函数设计为冰球与目标位置的距离的负值；然后在现实环境中，我们拥有一个有三个关节的机械臂去完成同样的任务。在这个例子中，虽然从智能体获得的图像表示完全不同（一个两关节一个三关节），但是回报函数其实是一样的，与关节数目没有关系。当然这是一个比较极端的例子，回报函数可以不完全一样。</p><p>所以本文的目标是学习两个映射函数，能够将两个环境中的状态映射到一个共同的隐含表示空间，这与上一篇论文只有一个公共的映射函数不同：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image40.png" alt="Common Feature Space"></p><p>而要能通过这个目标来求出两个映射函数，还需要做出以下假设:</p><ul><li>仿真环境以及真实环境的智能体需要学会完成同一个任务</li><li>动作空间一致，状态空间的维度一致</li></ul><p>第一个假设必须存在是由于需要从这个共同的任务中去学习这两个映射函数。这两个假设其实不算很强烈的假设，对于第一个假设来说，这个共同任务可以是一些比较简单的任务，使得训练成本较小；另外对于第二个假设，如果仿真环境以及现实环境中使用的是同一款机器人或者机械臂，动作空间一致以及状态空间的维度一致是一个非常自然的假设。</p><h3 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h3><p>要进行如上公式所示的表示学习，我们首先需要对两个环境中的状态（学会的共同任务中的状态）进行对齐（与上一篇论文里的对齐意义是一样的），这里存在两种方法进行对齐：</p><ul><li>Time-bases Alignment</li><li>Dynamic Time Wrapping</li></ul><p>第一种方法非常简单，对于两个环境中的智能体都学会解决的共同任务，如果智能体在仿真环境以及现实环境中动作执行的时钟是大致相同的，那么只要让两个环境中的智能体同时开始执行这个共同的任务，其分别产生的状态序列一定是对齐的；但是时钟相等的假设过于强烈了，因而第二种方法是一个可行性更高的方法。它是一个迭代的方法，它需要一个计算两个序列相似度的距离函数，根据这个距离函数来找出使得两个序列距离最近的对齐方式；对齐后，再根据新的对齐方式更新距离函数，如此不断迭代直至收敛或者到达停止条件。这个方法主要在于如何去选择这个距离函数，本文的做法是首先用time-bases alignment方法得到一个初始的对齐方式，再使用下面要讲到的表示学习的方法学习两个映射函数，将整个序列每一对对齐状态映射后隐含表示向量的欧氏距离的和作为dynamic time warpping方法中序列相似度的距离函数。</p><p>以上就是状态对齐步骤，下面就要进行正式的表示学习了。我们注意到，对于以上公式，其实有个非常简单的解，即这两个映射函数的是个输出永远为0的常数函数。这样一个解显然不是我们需要的，因为我们可以加上一个约束，即学习到的隐含表示能够尽可能多的保留原表示的信息，即学习到的隐含表示是一个auto encoder的隐向量。根据以上假设以及我们的优化目标，可以得到如下表示学习损失函数：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image41.png" alt="Common Feature Spaces Loss"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image42.png" alt="Auto Encoder Losses"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image43.png" alt="Objective Function"></p><p>同样给出一个更容易理解的框架图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image44.png" alt="Architecture"></p><h3 id="知识迁移"><a href="#知识迁移" class="headerlink" title="知识迁移"></a>知识迁移</h3><p>在进行了第一步的表示学习后，我们需要利用学习到的表示在现实环境中进行新任务的训练。但是注意，我们学习的表示是经过如下两个约束学到的，第一个约束可以认为是一个auto encoder的降维；第二个约束是能够与模拟环境最优策略产生的状态概率分布相同的一个隐含状态表示空间。因而我们不能单单只利用学习到隐含表示去在现实世界中训练，这样在模拟环境中训练好的策略没有办法对现实任务的训练造成任何影响，这个影响必须通过将现实任务的状态序列与模拟环境中最优策略产生的状态序列对齐后才能够实现。</p><p>本文通过对现实环境中智能体需要解决的任务的回报函数的基础上加上如下附加项来实现知识迁移：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image45.png" alt="Addition Reward Term"></p><p>这里的上标$t$表明，在进行现实环境中智能体的训练时，模拟环境必须同步运行。</p><h2 id="Sim-to-Real-Robot-Learning-from-Pixels-with-Progressive-Nets"><a href="#Sim-to-Real-Robot-Learning-from-Pixels-with-Progressive-Nets" class="headerlink" title="Sim-to-Real Robot Learning from Pixels with Progressive Nets"></a>Sim-to-Real Robot Learning from Pixels with Progressive Nets</h2><p>本方法属于 Progressive Network 类别方法，其使用的Progressive Nerual Network是迁移学习领域提出的一种网络结构，其具体形式如下图（左）所示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image46.png" alt="Progressive Neural Network"></p><p>左图中每一列（column）代表一个独立的任务，任务训练顺序从左到右。虽然任务训练顺序从简单到复杂从直觉上来看是比较合理的，但是PNN并不一定要满足这个规律， 其任务训练顺序可以是任意的。由于我们以第三列（第三个任务）为中心来考虑，因而有实线与虚线的差异。可以看到PNN的思想非常简单，在后面任务的每一层计算时，输入端并上之前任务前一层的输出即可。但是PNN扩展到强化学习中进行了如下三个改变：</p><ol><li>现实环境中使用的神经网络要比模拟环境中要小。原因主要是由于原PNN论文发现，当列数越多时每一列网络的参数都很稀疏，完全可以进行网络压缩或者剪枝。</li><li>输出层不再接受前置任务的输入。由于模拟环境与现实环境在动作空间上可能存在差异，因而在输出层借鉴前面任务的知识反而容易产生误导。</li><li>为了让智能体在现实环境中训练所需的样本量更小，因而输出层的参数直接复制之前任务的参数用来初始化，用以提升算法训练初期的探索度。</li></ol><p>值得注意的是，论文的结果还表明使用LSTM进行策略网络的建模要比使用MLP效果更好。其实还有很多其他工作也同样发现了这一点，主要还是因为大部分现实中的强化学习问题都是部分观察的，不满足马尔可夫性质。</p><h2 id="Transfer-from-Simulation-to-Real-World-through-Learning-Deep-Inverse-Dynamics-Model"><a href="#Transfer-from-Simulation-to-Real-World-through-Learning-Deep-Inverse-Dynamics-Model" class="headerlink" title="Transfer from Simulation to Real World through Learning Deep Inverse Dynamics Model"></a>Transfer from Simulation to Real World through Learning Deep Inverse Dynamics Model</h2><p>本文属于 Inverse Dynamic Model 类别。其主要基于的假设是即使虚拟环境无法对现实世界进行完全准确的建模，但是其状态的变化还是合理的。例如，对于一个将物体推到指定目标位置的任务来说，一个机械臂将冰球往前推那么下一个状态就是冰球往推动方向前进一些，但是不会往相反的方向移动。基于这个假设，首先在虚拟环境训练好一个策略，其输入是前n个时间步的状态（这里同样考虑到部分观察的问题），将输出的动作输入到虚拟环境模型中，就会转移到虚拟环境中的下一个状态。将这个状态与现实环境中的前n个时间步的状态输入到真实环境中学习到的逆动态模型中，就会得出能够输出这下一个状态所需要采取的动作。具体见下图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image49.png" alt="训练流程图"></p><p>以上过程唯一需要详细说明的便是如何在现实环境中学习一个逆动态模型，其实非常简单：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image51.png" alt="Inverse Dynamic Model"></p><p>但是这个模型的好坏取决于在现实环境中收集的样本的质量，即样本是否具有足够的多样性从而覆盖足够大的状态空间。一个简单但有效的做法是在探索时的动作上增加一定的噪声，但是加入噪声的频率等需要仔细考量否则就会使得收集到的数据质量下降，论文经过实际的实验得出以下两点经验：</p><ol><li>不需要每个时间步都加入噪声。</li><li>当现实环境中智能体执行动作发生状态转移时转移到一个与虚拟环境差别很大的状态时，就应当即时停止这一轮的采样。</li></ol><h2 id="Sim-to-Real-Transfer-of-Robotic-Control-with-Dynamics-Randomization"><a href="#Sim-to-Real-Transfer-of-Robotic-Control-with-Dynamics-Randomization" class="headerlink" title="Sim-to-Real Transfer of Robotic Control with Dynamics Randomization"></a>Sim-to-Real Transfer of Robotic Control with Dynamics Randomization</h2><p>本文属于 Domain Randomization 类别。本文出发点在于深度强化学习算法具有以下特性：</p><blockquote><p>DeepRL policies are prone to exploiting idiosyncrasies of the simulator to realize behaviours that are infeasible in the real world.</p></blockquote><p>即强化学习算法在一个特定环境中进行学习时，会尝试去挖掘某些专属于这个环境的特性从而使得算法的泛化能力很差。为此，本文将强化学习的优化目标更改如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image52.png" alt="Dynamic Randomization Problem"></p><p>这里的$\mu$代表决定环境的物理参数。如果智能体优化的是在大量不同物理参数确定的虚拟环境中累积回报的期望值的话，训练出的策略就会更加鲁棒。对于一个特定的环境，本文采用HER+RDPG算法进行最优策略的训练：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image53.png" alt="Dynamic Randomization RL Algorithm"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image54.png" alt="54"></p><p>其中的策略网络以及值函数网络采用如下方式进行建模：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image55.png" alt="Netowrk Archtectures"></p><h2 id="Domain-Randomization-for-Transferring-Deep-Neural-Networks-from-Simulation-to-the-Real-World"><a href="#Domain-Randomization-for-Transferring-Deep-Neural-Networks-from-Simulation-to-the-Real-World" class="headerlink" title="Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World"></a>Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World</h2><p>本文同样属于 Domain Randomization 类别，只不过不同于上一篇论文是随机化物理参数，本文是随机化环境的视觉表示。具体来说，本文是想学习一个定位器，通过输入一张图片来定位其中所有目标物体的三维坐标：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image59.png" alt="Domain Randomization"></p><p>具体需要随机化的视觉信息包括：</p><ul><li>桌子上所有目标物体的位置以及纹理</li><li>桌子、地板、背景以及机械臂的纹理</li><li>摄像机的位置、朝向以及可视范围</li><li>场景中光源的数量</li><li>场景中光源的位置、朝向以及光谱特征</li><li>加入到图像中噪声的类型以及数量</li></ul><h1 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h1><p>在这一部分我将介绍一下OpenAI在sim2real领域做出的一个工作，其地位类似于多智能体强化学习领域的OpenAI Five。</p><h2 id="Learning-Dexterous-In-Hand-Manipulation"><a href="#Learning-Dexterous-In-Hand-Manipulation" class="headerlink" title="Learning Dexterous In-Hand Manipulation"></a>Learning Dexterous In-Hand Manipulation</h2><p>这个例子主要用到的技术包括以下几点：虚拟环境的随机化、大规模分布式采样以及精确的虚拟环境搭建。其所需要完成的任务是：使用一个具有20个自由度的机械手，将其手掌中的立方体从初始朝向利用手指翻转到目标朝向：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image68.png" alt="Task"></p><p>为了建立一个足够精细（但是依旧存在无法建模的物理量）的虚拟环境，OpenAI以机械手为球心半径为80厘米的球面上均匀分布了16个精度为20微米的追踪器，能够定位机械手任意位置的微小位移。之所以采用如此高精度的追踪器是为了尽可能准确地对机械手的相关物理参数，例如手指关节处的阻尼等等，这样的物理参数有将近500个。我认为这个工作之所以能够直接将虚拟环境中学习到的最优策略直接应用到现实环境中，这个高精度的虚拟环境功不可没：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image69.png" alt="真实环境 vs 虚拟环境"></p><p>整个系统的训练步骤大致可分为以下三个部分（最后是训练完毕的执行部分）：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image70.png" alt="系统流程图"></p><p>下面将详细对每一个部分进行说明。首先是第一个部分，包括模拟环境中数据的并行采样以及整个强化学习的参数更新框架：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image72.png" alt="分布式数据采集以及参数更新"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image71.png" alt="分布式架构"></p><p>上图中采用的分布式数据收集以及模型训练框架同样也是OpenAI Five所采用的。从左下方开始，多个并行采样的worker会将自己根据当前策略采集的样本发送给与自己相关联的Redis服务器上，模型更新模块中的Puller将会定期异步地从Redis服务器中拉取一个batch的数据并放到RAM中，之后Stager从RAM中拉取一个mini-batch放到GPU上，与其他采用MPI协议联系的GPU一起对参数进行更新。更新后的参数将每个Optimizer都保存一份。之后Optimizer沿着之前相反的路径将更新后的参数存储到Redis服务器上，workers将定期异步地从Redis服务器上拉取最新的策略参数进行采样。整个训练过程就是以上过程的迭代。下图表示了不同规模的并行对于最终算法性能的影响：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image73.png" alt="不同并行度对于最终算法性能的影响"></p><p>第二部分，具体的强化算法选用的是PPO算法，其策略网络以及值函数网络建模如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image75.png" alt="强化学习算法架构"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image74.png" alt="策略网络以及值函数网络结构"></p><p>其中输入部分左边代表机械手的状态，右边代表物体的朝向，具体的维度如下所示：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image76.png" alt="状态空间"></p><p>由于PPO算法的值函数网络只会在训练时使用到，因而采用完整信息对其进行训练。在训练时算法采用了如下三种随机注入方法：</p><ul><li>Dynamic Randomization</li><li>Domain Randomization</li><li>Unmodeled Effects Randomization</li></ul><p>具体见下面三张图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image77.png" alt="Dynamic Randomization"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image79.png" alt="Domain Randomization"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image78.png" alt="Unmodeled Effects Randomization"></p><p>最后一部分，由于机械手的任务不应该局限于转动方块，还应该包括操纵其他物体。而且由第二部分可知策略网络以及值函数网络的输入可知需要立方体的朝向以及位置信息，目前是通过16个高精度追踪器确定的。OpenAI为了提高整个系统的通用性，因而在方块的周围相隔一定高度120度角均匀放置了三个摄像头，尝试学习一个模型，输入是三张不同角度的图片，输出是立方体的位置以及朝向。这样就可以把立方体换为任意的物体。其具体的网络结构如下：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image81.png" alt="Object Pose Prediction"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/sim2real/v1/image80.png" alt="Pose Prediction Network Architecture"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/Variational-Discreminator-Bottlenect/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2019/03/20/Variational-Discreminator-Bottlenect/" itemprop="url">Variational Discreminator Bottlenect [ICLR 2019 Peng et al.]</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T21:47:32+08:00">2019-03-20 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/03/20/Variational-Discreminator-Bottlenect/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2019/03/20/Variational-Discreminator-Bottlenect/" itemprop="commentsCount"></span> </a></span><span id="/2019/03/20/Variational-Discreminator-Bottlenect/" class="leancloud_visitors" data-flag-title="Variational Discreminator Bottlenect [ICLR 2019 Peng et al.]"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对抗学习方法今年来被广泛应用于各领域中，但其训练过程极不稳定。由于判别器过于准确将会使得其产生的梯度包含的信息过少从而不能有效地对生成器进行训练，因而有效地平衡判别器以及生成器的性能至关重要。在这篇文章中，作者提出了一个简单但通用的方式来对判别器接收到的信息流采用信息瓶颈进行约束。通过<strong>对判别器的内部状态以及输入的原始数据之间的互信息施加约束</strong>可以有效地控制判别器的准确度从而使得其产生的梯度能够包含对生成器训练更加具有指导意义的信息。作者提出的变分判别器瓶颈能够显著提升<strong>模仿学习</strong>以及<strong>逆强化学习</strong>算法的特性，当然由于其通用性，任何对抗生成模型均可从中受益。</p><h1 id="变分信息瓶颈"><a href="#变分信息瓶颈" class="headerlink" title="变分信息瓶颈"></a>变分信息瓶颈</h1><p>我们从监督学习中的变分信息瓶颈出发。对于监督学习中一个分类任务，存在以下优化目标：<br>$$<br>\min_q \mathbb{E}_{x,y\sim p(x,y)}\left[ -\log q(y|x) \right].<br>$$<br>然而，优化上述目标容易使得训练出的模型过拟合。引入信息瓶颈可以使得模型只关注于输入数据中更加具有判别性的特征。首先我们一如一个编码器$\mathbb{E}(z|x)$将输入数据$x$映射到一个隐含分布中，然后对于编码后的数据以及原数据之间的互信息$I(X,Z)$的上界施加约束，即可得到下面的优化目标：<br>$$<br>\begin{align}<br>J(q,E)=&amp;\min_{q,E} \;\;\mathbb{E}_{x,y \sim p(x,y)} \left[ \mathbb{E}_{z \sim E(z|x)} \left[ -\log q(y|z) \right] \right] \nonumber \\<br>&amp;\text{s.t.}\;\;\;\;I(X,Z) \leq I_c.<br>\end{align}<br>$$<br>我们可以通过变分方法引入互信息的上界，从而推导出上述优化目标的上界，最后通过拉格朗日乘子法将上述带约束的优化问题转变为一个无约束的优化问题，具体推导过程见下图：</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/VDB/1.jpg" alt="推导过程"></p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/VDB/2.jpg" alt="推导过程"></p><h1 id="变分判别器瓶颈"><a href="#变分判别器瓶颈" class="headerlink" title="变分判别器瓶颈"></a>变分判别器瓶颈</h1><p>接着我们将上述变分信息瓶颈引入到一个标准的生成对抗网络的判别器损失函数上:</p><p><img src="https://raw.githubusercontent.com/ewanlee/blog-image-hosting/master/VDB/3.jpg" alt="变分判别器瓶颈"></p><p>由于一些生成对抗模仿学习以及对抗逆强化学习算法均采用以上的生成对抗框架，因而可以引入以上变分判别器瓶颈来增强性能。</p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>为何引入变分判别器瓶颈可以提高生成对抗模型的性能呢？在生成对抗学习中，如果真实数据分布与生成数据分布具有不相交的支撑集时，一个最优的判别器能够完美分辨两个分布并且其梯度几乎处处为零。因而，当判别器收敛到最优性能时，用以训练生成器的梯度会因此消失。目前一种解决此问题的方法是对判别器的输入数据增加一些连续的噪声，因而使得两个分布在任何地方都拥有连续的支撑集。但是实际上，如果两个分布的距离很大时，增加噪声几乎没有影响。而引入变分判别器瓶颈时，首先编码器将输入映射到一个嵌入空间中并对嵌入表示施加信息瓶颈约束，使得两个分布不仅具有共享的支撑集而且分布之间存在明显的重合（距离不大），同时由于引入信息瓶颈与引入噪声部分等同，使得上述问题得以解决。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/26/Accelerate-your-pandas-workflows-by-changing-one-line-of-code/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/10/26/Accelerate-your-pandas-workflows-by-changing-one-line-of-code/" itemprop="url">Accelerate your pandas workflows by changing one line of code</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-26T23:38:34+08:00">2018-10-26 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/10/26/Accelerate-your-pandas-workflows-by-changing-one-line-of-code/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2018/10/26/Accelerate-your-pandas-workflows-by-changing-one-line-of-code/" itemprop="commentsCount"></span> </a></span><span id="/2018/10/26/Accelerate-your-pandas-workflows-by-changing-one-line-of-code/" class="leancloud_visitors" data-flag-title="Accelerate your pandas workflows by changing one line of code"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><script src="https://gist.github.com/devin-petersohn/2384d06e536df1f14519e18b3ce46ecd.js"></script></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Ewan Li"><p class="site-author-name" itemprop="name">Ewan Li</p><p class="site-description motion-element" itemprop="description">Ewan's IT Blog</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">129</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">64</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ewanlee" target="_blank" title="Github"><i class="fa fa-fw fa-globe"></i> Github </a></span><span class="links-of-author-item"><a href="https://twitter.com/tomaxent" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Ewan Li</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">Theme - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user">本站访客数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次</span> <span class="site-pv"><i class="fa fa-eye">本站总访问量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">_hcwp=window._hcwp||[],_hcwp.push({widget:"Bloggerstream",widget_id:89825,selector:".hc-comment-count",label:"{%COUNT%}"}),function(){if(!("HC_LOAD_INIT"in window)){HC_LOAD_INIT=!0;var t=(navigator.language||navigator.systemLanguage||navigator.userLanguage||"en").substr(0,2).toLowerCase(),e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src=("https:"==document.location.protocol?"https":"http")+"://w.hypercomments.com/widget/hc/89825/"+t+"/widget.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n.nextSibling)}}()</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),n=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,n=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=n&&a.forEach(function(e,t){i=n.indexOf(e),l=s.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+n+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),n.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("e27VKX5tTklQLCtF7iNMmhcA-gzGzoHsz","nnQn2znNgXXEdK7W2bVJ3bfK")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html>