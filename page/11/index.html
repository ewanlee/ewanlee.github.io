<!doctype html><html class="theme-next mist use-motion" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/atom.xml" title="Abracadabra" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="Ewan&apos;s IT Blog"><meta property="og:type" content="website"><meta property="og:title" content="Abracadabra"><meta property="og:url" content="http://yoursite.com/page/11/index.html"><meta property="og:site_name" content="Abracadabra"><meta property="og:description" content="Ewan&apos;s IT Blog"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Abracadabra"><meta name="twitter:description" content="Ewan&apos;s IT Blog"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/page/11/"><title>Abracadabra</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?dc405a79ad500922134d14cdf288f646";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Abracadabra</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Do it yourself</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div><span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/WGAN-GP/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/07/18/WGAN-GP/" itemprop="url">WGAN-GP [Repost]</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-18T11:16:24+08:00">2017-07-18 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/07/18/WGAN-GP/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2017/07/18/WGAN-GP/" itemprop="commentsCount"></span> </a></span><span id="/2017/07/18/WGAN-GP/" class="leancloud_visitors" data-flag-title="WGAN-GP [Repost]"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p><a href="https://ewanlee.github.io/2017/04/29/The-awesome-Wasserstein-GAN/" target="_blank" rel="external">WGAN</a>存在着训练困难、收敛速度慢等问题。<a href="https://link.zhihu.com/?target=https%3A//www.reddit.com/r/MachineLearning/comments/5zd4c0/d_survey_whats_the_most_stable_regiment_for/dexfhxu/%3Futm_content%3Dpermalink%26utm_medium%3Dfront%26utm_source%3Dreddit%26utm_name%3DMachineLearning" target="_blank" rel="external">WGAN的作者Martin Arjovsky不久后就在reddit上表示他也意识到了这个问题</a>，认为关键在于原设计中Lipschitz限制的施加方式不对：</p><blockquote><p>I am now pretty convinced that the problems that happen sometimes in WGANs is due to the specific way of how weight clipping works. It’s just a terrible way of enforcing a Lipschitz constraint, and better ways are out there. I feel like apologizing for being too lazy and sticking to what could be done in one line of torch code.</p><p>A simple alternative (less than 5 lines of code) has been found by Montréal students. It works on quite a few settings (inc 100 layer resnets) with default hyperparameters. Arxiv coming this or next week, stay tuned.</p></blockquote><p>并在新论文中提出了相应的改进方案：</p><ul><li>论文：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1704.00028" target="_blank" rel="external">[1704.00028] Improved Training of Wasserstein GANs</a></li><li>Tensorflow实现：<ul><li><a href="https://github.com/brianherman/improved_wgan_training" target="_blank" rel="external">brianherman/improved_wgan_training</a> (Python 3)</li><li><a href="https://github.com/igul222/improved_wgan_training" target="_blank" rel="external">igul222/improved_wgan_training</a> (Python 2)</li></ul></li></ul><p><strong>首先回顾一下WGAN的关键部分——Lipschitz限制是什么。</strong>WGAN中，判别器D和生成器G的loss函数分别是<br>$$<br>\begin{align}<br>L(D) &amp;= - \mathbb{E}_{x \sim P_r} [D(x)] + \mathbb{E}_{x \sim P_g} [D(x)] \\<br>L(G) &amp;= - \mathbb{E}_{x \sim P_r} [D(x)]<br>\end{align}<br>$$<br>公式1表示判别器希望尽可能拉高真样本的分数，拉低假样本的分数，公式2表示生成器希望尽可能拉高假样本的分数。</p><p>Lipschitz限制则体现为，在整个样本空间$\mathcal{X}$上，要求判别器函数$D(x)$梯度的$L_p$ norm大于一个有限的常数K：<br>$$<br>| \nabla_x D(x) |_p \leq K, \forall x \in \mathcal{X}<br>$$<br>直观上解释，就是当输入的样本稍微变化后，判别器给出的分数不能发生太过剧烈的变化。在原来的论文中，这个限制具体是通过weight clipping的方式实现的：每当更新完一次判别器的参数之后，就检查判别器的所有参数的绝对值有没有超过一个阈值，比如0.01，有的话就把这些参数clip回 [-0.01, 0.01] 范围内。通过在训练过程中保证判别器的所有参数有界，就保证了判别器不能对两个略微不同的样本给出天差地别的分数值，从而间接实现了Lipschitz限制。</p><p><strong>然而weight clipping的实现方式存在两个严重问题：</strong></p><p>第一，如公式1所言，判别器loss希望尽可能拉大真假样本的分数差，然而weight clipping独立地限制每一个网络参数的取值范围，在这种情况下我们可以想象，最优的策略就是尽可能让所有参数走极端，要么取最大值（如0.01）要么取最小值（如-0.01）！为了验证这一点，作者统计了经过充分训练的判别器中所有网络参数的数值分布，发现真的集中在最大和最小两个极端上：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/wgan-gp/wgan-gp-weight-clip.png" alt="weight-clipping"></p><p>这样带来的结果就是，判别器会非常倾向于学习一个简单的映射函数（想想看，几乎所有参数都是正负0.01，都已经可以直接视为一个<a href="https://link.zhihu.com/?target=http%3A//synchuman.baijia.baidu.com/article/385441" target="_blank" rel="external">二值神经网络**</a>了，太简单了）。而作为一个深层神经网络来说，这实在是对自身强大拟合能力的巨大浪费！判别器没能充分利用自身的模型能力，经过它回传给生成器的梯度也会跟着变差。</p><p>在正式介绍gradient penalty之前，我们可以先看看在它的指导下，同样充分训练判别器之后，参数的数值分布就合理得多了，判别器也能够充分利用自身模型的拟合能力：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/wgan-gp/wgan-gp-weight-gp.png" alt="weight-gp"></p><p>第二个问题，weight clipping会导致很容易一不小心就梯度消失或者梯度爆炸。原因是判别器是一个多层网络，如果我们把clipping threshold设得稍微小了一点，每经过一层网络，梯度就变小一点点，多层之后就会指数衰减；反之，如果设得稍微大了一点，每经过一层网络，梯度变大一点点，多层之后就会指数爆炸。只有设得不大不小，才能让生成器获得恰到好处的回传梯度，然而在实际应用中这个平衡区域可能很狭窄，就会给调参工作带来麻烦。相比之下，gradient penalty就可以让梯度在后向传播的过程中保持平稳。论文通过下图体现了这一点，其中横轴代表判别器从低到高第几层，纵轴代表梯度回传到这一层之后的尺度大小（注意纵轴是对数刻度），c是clipping threshold：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/wgan-gp/wgan-gp-gradient-norm.png" alt="gradient-norm"></p><p><strong>说了这么多，gradient penalty到底是什么？</strong></p><p>前面提到，Lipschitz限制是要求判别器的梯度不超过K，那我们何不直接设置一个额外的loss项来体现这一点呢？比如说：<br>$$<br>ReLU[| \nabla_x D(x) |_p - K]<br>$$<br>不过，既然判别器希望尽可能拉大真假样本的分数差距，那自然是希望梯度越大越好，变化幅度越大越好，所以判别器在充分训练之后，其梯度norm其实就会是在K附近。知道了这一点，我们可以把上面的loss改成要求梯度norm离K越近越好，效果是类似的：<br>$$<br>[| \nabla_x D(x) |_p - K]^2<br>$$<br>究竟是公式4好还是公式5好，我看不出来，可能需要实验验证，反正论文作者选的是公式5。接着我们简单地把K定为1，再跟WGAN原来的判别器loss加权合并，就得到新的判别器loss：<br>$$<br>L(D) = - \mathbb{E}_{x \sim P_r} [D(x)] + \mathbb{E}_{x \sim P_g} [D(x)] + \lambda \mathbb{E}_{x \sim \mathcal{X}} [| \nabla_x D(x) |_p - 1]^2<br>$$<br>这就是所谓的gradient penalty了吗？还没完。公式6有两个问题，首先是loss函数中存在梯度项，那么优化这个loss岂不是要算梯度的梯度？一些读者可能对此存在疑惑，不过这属于实现上的问题，放到后面说。</p><p>其次，3个loss项都是期望的形式，落到实现上肯定得变成采样的形式。前面两个期望的采样我们都熟悉，第一个期望是从真样本集里面采，第二个期望是从生成器的噪声输入分布采样后，再由生成器映射到样本空间。可是第三个分布要求我们在整个样本空间$\mathcal{X}$上采样，这完全不科学！由于所谓的维度灾难问题，如果要通过采样的方式在图片或自然语言这样的高维样本空间中估计期望值，所需样本量是指数级的，实际上没法做到。</p><p>所以，论文作者就非常机智地提出，我们其实没必要在整个样本空间上施加Lipschitz限制，只要重点抓住生成样本集中区域、真实样本集中区域以及夹在它们中间的区域就行了。具体来说，我们先随机采一对真假样本，还有一个0-1的随机数：<br>$$<br>x_r \sim P_r, x_g \sim P_g, \epsilon \sim Uniform[0, 1]<br>$$<br>然后在$x_r$和$x_g$的连线上随机插值采样：<br>$$<br>\hat{x} = \epsilon x_r + (1 - \epsilon) x_g<br>$$<br>把按照上述流程采样得到的$\hat{x}$所满足的分布记为$P_{\hat{x}}$, 就得到最终版本的判别器loss：<br>$$<br>L(D) = - \mathbb{E}_{x \sim P_r} [D(x)] + \mathbb{E}_{x \sim P_g} [D(x)] + \lambda \mathbb{E}_{x \sim \hat{x}} [| \nabla_x D(x) |_p - 1]^2<br>$$<br><strong>这就是新论文所采用的gradient penalty方法，相应的新WGAN模型简称为WGAN-GP。</strong>我们可以做一个对比：</p><ul><li>weight clipping是对样本空间全局生效，但因为是间接限制判别器的梯度norm，会导致一不小心就梯度消失或者梯度爆炸；</li><li>gradient penalty只对真假样本集中区域、及其中间的过渡地带生效，但因为是直接把判别器的梯度norm限制在1附近，所以梯度可控性非常强，容易调整到合适的尺度大小。</li></ul><p>论文还讲了一些使用gradient penalty时需要注意的配套事项，这里只提一点：由于我们是对每个样本独立地施加梯度惩罚，所以判别器的模型架构中不能使用Batch Normalization，因为它会引入同个batch中不同样本的相互依赖关系。如果需要的话，可以选择其他normalization方法，如Layer Normalization、Weight Normalization和Instance Normalization，这些方法就不会引入样本之间的依赖。论文推荐的是Layer Normalization。</p><p>实验表明，gradient penalty能够显著提高训练速度，解决了原始WGAN收敛缓慢的问题：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/wgan-gp/wgan-gp-exper.png" alt="exper"></p><p>虽然还是比不过DCGAN，但是因为WGAN不存在平衡判别器与生成器的问题，所以会比DCGAN更稳定，还是很有优势的。不过，作者凭什么能这么说？因为下面的实验体现出，在各种不同的网络架构下，其他GAN变种能不能训练好，可以说是一件相当看人品的事情，但是WGAN-GP全都能够训练好，尤其是最下面一行所对应的101层残差神经网络：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/wgan-gp/wgan-gp-image-gen.png" alt="image-gen"></p><p><strong>剩下的实验结果中，比较厉害的是第一次成功做到了“纯粹的”的文本GAN训练！</strong>我们知道在图像上训练GAN是不需要额外的有监督信息的，但是之前就没有人能够像训练图像GAN一样训练好一个文本GAN，要么依赖于预训练一个语言模型，要么就是利用已有的有监督ground truth提供指导信息。而现在WGAN-GP终于在无需任何有监督信息的情况下，生成出下图所示的英文字符序列：</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/wgan-gp/wgan-gp-text-gen.png" alt="text-gen"></p><p>它是怎么做到的呢？我认为关键之处是对样本形式的更改。<strong>以前我们一般会把文本这样的离散序列样本表示为sequence of index，但是它把文本表示成sequence of probability vector。</strong>对于生成样本来说，我们可以取网络softmax层输出的词典概率分布向量，作为序列中每一个位置的内容；而对于真实样本来说，每个probability vector实际上就蜕化为我们熟悉的onehot vector。</p><p>但是如果按照传统GAN的思路来分析，这不是作死吗？一边是hard onehot vector，另一边是soft probability vector，判别器一下子就能够区分它们，生成器还怎么学习？没关系，对于WGAN来说，真假样本好不好区分并不是问题，WGAN只是拉近两个分布之间的Wasserstein距离，就算是一边是hard onehot另一边是soft probability也可以拉近，在训练过程中，概率向量中的有些项可能会慢慢变成0.8、0.9到接近1，整个向量也会接近onehot，最后我们要真正输出sequence of index形式的样本时，只需要对这些概率向量取argmax得到最大概率的index就行了。</p><p>新的样本表示形式+WGAN的分布拉近能力是一个“黄金组合”，但除此之外，还有其他因素帮助论文作者跑出上图的效果，包括：</p><ul><li>文本粒度为英文字符，而非英文单词，所以字典大小才二三十，大大减小了搜索空间</li><li>文本长度也才32</li><li>生成器用的不是常见的LSTM架构，而是多层反卷积网络，输入一个高斯噪声向量，直接一次性转换出所有32个字符</li></ul><p><strong>最后说回gradient penalty的实现问题。</strong>loss中本身包含梯度，优化loss就需要求梯度的梯度，这个功能并不是现在所有深度学习框架的标配功能，不过好在Tensorflow就有提供这个接口—<code>tf.gradients</code>。开头链接的GitHub源码中就是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># interpolates就是随机插值采样得到的图像，gradients就是loss中的梯度惩罚项</div><div class="line">gradients = tf.gradients(Discriminator(interpolates), [interpolates])[0]</div></pre></td></tr></table></figure><p>完整的loss是这样实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">gen_cost = -tf.reduce_mean(disc_fake)</div><div class="line">disc_cost = tf.reduce_mean(disc_fake) - tf.reduce_mean(disc_real)</div><div class="line"></div><div class="line">alpha = tf.random_uniform(</div><div class="line">	shape=[BATCH_SIZE,<span class="number">1</span>], </div><div class="line">	minval=<span class="number">0.</span>,</div><div class="line">	maxval=<span class="number">1.</span></div><div class="line">)</div><div class="line">differences = fake_data - real_data</div><div class="line">interpolates = real_data + (alpha*differences)</div><div class="line">gradients = tf.gradients(Discriminator(interpolates), [interpolates])[<span class="number">0</span>]</div><div class="line">slopes = tf.sqrt(tf.reduce_sum(tf.square(gradients), reduction_indices=[<span class="number">1</span>]))</div><div class="line">gradient_penalty = tf.reduce_mean((slopes<span class="number">-1.</span>)**<span class="number">2</span>)</div><div class="line">disc_cost += LAMBDA*gradient_penalty</div><div class="line"></div><div class="line">gen_train_op = tf.train.AdamOptimizer(</div><div class="line">	learning_rate=<span class="number">1e-4</span>, </div><div class="line">	beta1=<span class="number">0.5</span>,</div><div class="line">	beta2=<span class="number">0.9</span></div><div class="line">).minimize(gen_cost, var_list=gen_params)</div><div class="line">disc_train_op = tf.train.AdamOptimizer(</div><div class="line">	learning_rate=<span class="number">1e-4</span>, </div><div class="line">	beta1=<span class="number">0.5</span>, </div><div class="line">	beta2=<span class="number">0.9</span></div><div class="line">).minimize(disc_cost, var_list=disc_params)</div></pre></td></tr></table></figure><p>对于我这样的PyTorch党就非常不幸了，高阶梯度的功能还在开发，感兴趣的PyTorch党可以订阅这个GitHub的pull request：<a href="https://link.zhihu.com/?target=https%3A//github.com/pytorch/pytorch/pull/1016" target="_blank" rel="external">Autograd refactor</a>，如果它被merged了话就可以在最新版中使用高阶梯度的功能实现gradient penalty了。</p><p>但是除了等待我们就没有别的办法了吗？<strong>其实可能是有的，我想到了一种近似方法来实现gradient penalty，只需要把微分换成差分：</strong><br>$$<br>L(D) = - \mathbb{E}_{x \sim P_r} [D(x)] + \mathbb{E}_{x \sim P_g} [D(x)] + \lambda \mathbb{E}_{x_1 \sim \hat{x}, x_2 \sim \hat{x}} [ \frac{|D(x_1) - D(x_2)|}{| x_1 - x_2 |_p} - 1]^2<br>$$<br>也就是说，我们仍然是在分布 $P_{\hat{x}}$ 上随机采样，但是一次采两个，然后要求它们的连线斜率要接近1，这样理论上也可以起到跟公式9一样的效果，我自己在MNIST+MLP上简单验证过有作用，PyTorch党甚至Tensorflow党都可以尝试用一下。</p><hr><p><strong>作者：郑华滨链接：<a href="https://www.zhihu.com/question/52602529/answer/158727900" target="_blank" rel="external">https://www.zhihu.com/question/52602529/answer/158727900</a></strong></p><p><strong>来源：知乎</strong></p><p><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/10/Policy-Gradient-Methods/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/07/10/Policy-Gradient-Methods/" itemprop="url">Policy Gradient Methods</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-10T17:23:16+08:00">2017-07-10 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/07/10/Policy-Gradient-Methods/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2017/07/10/Policy-Gradient-Methods/" itemprop="commentsCount"></span> </a></span><span id="/2017/07/10/Policy-Gradient-Methods/" class="leancloud_visitors" data-flag-title="Policy Gradient Methods"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Until now almost all the methods have learned the values of actions and then selected actions based on their estimated action values; their policies would not even exist without the action-value estimates. In this post we consider methods that instead learn a <em>parameterized policy</em> that can select actions without consulting a value function. A value function may still be used to <em>learn</em> the policy parameter, but is not required for action selection. We use the notation $\boldsymbol{\theta} \in \mathbb{R}^d$ for the policy’s parameter vector. Thus we write $\pi(a|s, \boldsymbol{\theta}) = \text{Pr}(A_t=a | S_t=s, \boldsymbol{\theta}_t=\boldsymbol{\theta})$ for the probability that action $a$ is taken at time $t$ given that the agent is in state $s$ at time $t$ with parameter $\boldsymbol{\theta}$. If a method uses a learned value function as well, then the value function’s weight vector is denoted $\mathbf{w} \in \mathbb{R}^m$, as in $\hat{v}(s, \mathbf{w})$.</p><p>In this chapter we consider methods for learning the policy parameter based on the gradient of some performance measure $J(\boldsymbol{\theta})$ with respect to the policy parameter. These methods seek to maximize performance, so their updates approximate gradient ascent in $J$ :<br>$$<br>\boldsymbol{\theta}_{t+1} = \boldsymbol{\theta}_t + \alpha \widehat{\nabla J(\boldsymbol{\theta}_t)}.<br>$$<br>All methods that follow this general schema we call <strong>policy gradient methods</strong>, whether or not they also learn an approximate value function. Methods that learn approximations to both policy and value functions are often called actor–critic methods, where ‘actor’ is a reference to the learned policy, and ‘critic’ refers to the learned value function, usually a state-value function.</p><h3 id="Policy-Approximation"><a href="#Policy-Approximation" class="headerlink" title="Policy Approximation"></a>Policy Approximation</h3><p>The most preferred actions in each state are given the highest probability of being selected, for example, according to an exponential softmax distribution:<br>$$<br>\pi(a|s, \boldsymbol{\theta}) = \frac{\exp(h(s, a, \boldsymbol{\theta}))}{\sum_b \exp(h(s, b, \boldsymbol{\theta}))}.<br>$$<br>For example, they might be computed by a deep neural network, where $\boldsymbol{\theta}$ is the vector of all the connection weights of the network. Or the preferences could simply be linear in features,<br>$$<br>h(s, a, \boldsymbol{\theta}) = \boldsymbol{\theta}^{\top} \mathbf{x}(s, a).<br>$$</p><h3 id="The-Policy-Gradient-Theorem"><a href="#The-Policy-Gradient-Theorem" class="headerlink" title="The Policy Gradient Theorem"></a>The Policy Gradient Theorem</h3><p>We deﬁne the performance measure as the value of the start state of the episode. We can simplify the notation without losing any meaningful generality by assuming that every episode starts in some particular (non-random) state s0. Then, in the episodic case we deﬁne performance as<br>$$<br>J(\boldsymbol{\theta}) \doteq v_{\pi_{\boldsymbol{\theta}}}(s_0),<br>$$<br>where $ v_{\pi_{\boldsymbol{\theta}}}$ is the true value function for $\pi_{\boldsymbol{\theta}}$, the policy determined by $\boldsymbol{\theta}$.</p><p>The policy gradient theorem is that<br>$$<br>\nabla J(\boldsymbol{\theta}) = \sum_s \mu_{\pi}(s) \sum_a q_{\pi}(s, a) \nabla_{\boldsymbol{\theta}} \pi(a | s, \boldsymbol{\theta}),<br>$$<br>where $\mu_{\pi}(s)$ we mentioned in <a href="https://ewanlee.github.io/2017/07/05/On-policy-Prediction-with-Approximation/" target="_blank" rel="external">earlier</a>.</p><h3 id="REINFORCE-Monte-Carlo-Policy-Gradient"><a href="#REINFORCE-Monte-Carlo-Policy-Gradient" class="headerlink" title="REINFORCE: Monte Carlo Policy Gradient"></a>REINFORCE: Monte Carlo Policy Gradient</h3><p>$$<br>\begin{align}<br>\nabla J(\boldsymbol{\theta}) &amp;= \sum_s \mu_{\pi}(s) \sum_a q_{\pi}(s, a) \nabla_{\boldsymbol{\theta}} \pi(a | s, \boldsymbol{\theta}) \\<br>&amp;= \mathbb{E}_{\pi} \Bigg[ \gamma^t \sum_a q_{\pi}(S_t, a) \nabla_{\boldsymbol{\theta}} \pi(a | S_t, \boldsymbol{\theta}) \Bigg] \\<br>&amp;= \mathbb{E}_{\pi} \Bigg[ \gamma^t \sum_a \pi(a|S_t, \boldsymbol{\theta}) q_{\pi}(S_t, a) \frac{\nabla_{\boldsymbol{\theta}} \pi(a|S_t, \boldsymbol{\theta})}{\pi(a|S_t, \boldsymbol{\theta})} \Bigg] \\<br>&amp;= \mathbb{E}_{\pi} \Bigg[ \gamma^t q_{\pi}(S_t, A_t) \frac{\nabla_{\boldsymbol{\theta}} \pi(A_t|S_t, \boldsymbol{\theta})}{\pi(A_t|S_t, \boldsymbol{\theta})} \Bigg] \;\;\; \text{(replacing a by the sample } A_t \sim \pi \;) \\<br>&amp;= \mathbb{E}_{\pi} \Bigg[ \gamma^t G_t \frac{\nabla_{\boldsymbol{\theta}} \pi(A_t|S_t, \boldsymbol{\theta})}{\pi(A_t|S_t, \boldsymbol{\theta})} \Bigg] \;\;\; \;\;\; \;\;\; \;\;\; \;\; (\text{because } \mathbb{E}_{\pi}[G_t|S_t,A_t]=q_{\pi}(S_t,A_t)).<br>\end{align}<br>$$</p><p>So we get<br>$$<br>\boldsymbol{\theta}_{t+1} \doteq \boldsymbol{\theta}_{t} + \alpha \gamma^t G_t \frac{\nabla_{\boldsymbol{\theta}} \pi(a|S_t, \boldsymbol{\theta})}{\pi(a|S_t, \boldsymbol{\theta})}.<br>$$<br>This is shown explicitly in the boxed pseudocode below.</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/rl/pgm/reinforce.png" alt="reinforce"></p><p>Notice that $\nabla \log x = \frac{\nabla x}{x}$.</p><h3 id="REINFORCE-with-Baseline"><a href="#REINFORCE-with-Baseline" class="headerlink" title="REINFORCE with Baseline"></a>REINFORCE with Baseline</h3><p>The policy gradient theorem can be generalized to include a comparison of the action value to an arbitrary <strong>baseline</strong> $b(s)$:</p><p>$$<br>\nabla J(\boldsymbol{\theta}) = \sum_s \mu_{\pi}(s) \sum_a \big(q_{\pi}(s, a) - b(s)\big) \nabla_{\boldsymbol{\theta}} \pi(a | s, \boldsymbol{\theta}).<br>$$<br>The baseline can be any function, even a random variable, as long as it does not vary with $a$; the equation remains true, because the subtracted quantity is zero:<br>$$<br>\sum_a b(s) \nabla_{\boldsymbol{\theta}} \pi(a|s, \boldsymbol{\theta}) = b(s) \nabla_{\boldsymbol{\theta}} \sum_a \pi(a|s, \boldsymbol{\theta}) = b(s) \nabla_{\boldsymbol{\theta}} 1 = 0 \;\;\;\; \forall s \in \mathcal{S}.<br>$$<br>The update rule that we end up with is a new version of REINFORCE that includes a general baseline:<br>$$<br>\boldsymbol{\theta}_{t+1} \doteq \boldsymbol{\theta}_{t} + \alpha \gamma^t \big(G_t-b(S_t) \big) \frac{\nabla_{\boldsymbol{\theta}} \pi(a|S_t, \boldsymbol{\theta})}{\pi(a|S_t, \boldsymbol{\theta})}.<br>$$<br>One natural choice for the baseline is an estimate of the state value, $\hat{v}(S_t, \mathbf{w})$, where $\mathbf{w} \in \mathbb{R}^m$ is a weight vector learned by one of the methods presented in previous posts. A complete pseudocode algorithm for REINFROCE with baseline is given in the box (use Monte Carlo method for learning the policy parameter and state-value weights).</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/rl/pgm/reinforce_baseline.png" alt="reinforce_baseline"></p><h3 id="Actor-Critic-Methods"><a href="#Actor-Critic-Methods" class="headerlink" title="Actor-Critic Methods"></a>Actor-Critic Methods</h3><p>Although the REINFORCE-with-baseline method learns both a policy and a state-value function, we do not consider it to be an actor-critic method because its state-value function is used only as a baseline, not as a critic. That is, it is not used for bootstrapping (updating a state from the estimated values of subsequent states), but only as a baseline for the state being updated. In<br>order to gain these advantages in the case of policy gradient methods we use actor-critic methods with a true bootstrapping critic.</p><p>One-step actor-critic methods replace the full return of REINFORCE with the one-step return (and use a learned state-value function as the baseline) as follow:<br>$$<br>\begin{align}<br>\boldsymbol{\theta}_{t+1} &amp;\doteq \boldsymbol{\theta}_{t} + \alpha \gamma^t \Big( G_{t:t+1} - \hat{v}(S_t, \mathbf{w})\Big) \frac{\nabla_{\boldsymbol{\theta}} \pi(A_t|S_t, \boldsymbol{\theta})}{\pi(A_t|S_t, \boldsymbol{\theta})} \\<br>&amp;= \boldsymbol{\theta}_{t} + \alpha \gamma^t \Big( R_{t+1} + \gamma \hat{v}(S_{t+1}, \mathbf{w}) - \hat{v}(S_t, \mathbf{w})\Big) \frac{\nabla_{\boldsymbol{\theta}} \pi(A_t|S_t, \boldsymbol{\theta})}{\pi(A_t|S_t, \boldsymbol{\theta})} \\<br>&amp;= \boldsymbol{\theta}_{t} + \alpha \gamma^t \delta_t \frac{\nabla_{\boldsymbol{\theta}} \pi(A_t|S_t, \boldsymbol{\theta})}{\pi(A_t|S_t, \boldsymbol{\theta})}.<br>\end{align}<br>$$<br>The natural state-value-function learning method to pair with this is semi-gradient TD(0). Pseudocode for the complete algorithm is given in the box below. Note that it is now a fully online, incremental algorithm, with states, actions, and rewards processed as they occur and then never revisited.</p><p><img src="http://o7ie0tcjk.bkt.clouddn.com/rl/pgm/one-step-ac.png" alt="one-step-ac"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/09/Using-Tensorflow-and-Deep-Q-Network-Double-DQN-to-Play-Breakout/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/07/09/Using-Tensorflow-and-Deep-Q-Network-Double-DQN-to-Play-Breakout/" itemprop="url">Using Tensorflow and Deep Q-Network/Double DQN to Play Breakout</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-09T11:34:18+08:00">2017-07-09 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/07/09/Using-Tensorflow-and-Deep-Q-Network-Double-DQN-to-Play-Breakout/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2017/07/09/Using-Tensorflow-and-Deep-Q-Network-Double-DQN-to-Play-Breakout/" itemprop="commentsCount"></span> </a></span><span id="/2017/07/09/Using-Tensorflow-and-Deep-Q-Network-Double-DQN-to-Play-Breakout/" class="leancloud_visitors" data-flag-title="Using Tensorflow and Deep Q-Network/Double DQN to Play Breakout"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>In previous <a href="https://ewanlee.github.io/2017/07/07/Using-Keras-and-Deep-Q-Network-to-Play-FlappyBird-Repost/" target="_blank" rel="external">blog</a>, we use the Keras to play the FlappyBird. Similarity, we will use another deep learning toolkit Tensorflow to develop the DQN and Double DQN and to play the another game Breakout (Atari 3600).</p><p>Here, we will use the OpenAI gym toolkit to construct out environment. Detail implementation is as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">env = gym.envs.make(<span class="string">"Breakout-v0"</span>)</div></pre></td></tr></table></figure><p>And then we look some demos:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"Action space size: &#123;&#125;"</span>.format(env.action_space.n))</div><div class="line"><span class="comment"># print(env.get_action_meanings())</span></div><div class="line"></div><div class="line">observation = env.reset()</div><div class="line">print(<span class="string">"Observation space shape: &#123;&#125;"</span>.format(observation.shape))</div><div class="line"></div><div class="line">plt.figure()</div><div class="line">plt.imshow(env.render(mode=<span class="string">'rgb_array'</span>))</div><div class="line"></div><div class="line">[env.step(<span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>)]</div><div class="line">plt.figure()</div><div class="line">plt.imshow(env.render(mode=<span class="string">'rgb_array'</span>))</div><div class="line"></div><div class="line">env.render(close=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/rl/games/breakout-env.png" alt="breakout-env"></p><p>For deep learning purpose, we need to crop the image to a square image:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Check out what a cropped image looks like</span></div><div class="line">plt.imshow(observation[<span class="number">34</span>:<span class="number">-16</span>,:,:])</div></pre></td></tr></table></figure><p><img src="http://o7ie0tcjk.bkt.clouddn.com/rl/games/croped-breakout-image.png" alt="croped-breakout-image"></p><p>Not bad !</p><p>Ok, now let us to use the Tensorflow to develop the DQN algorithm first.</p><p>First of all, we need to reference some packages and initialize the environment.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div><div class="line"></div><div class="line"><span class="keyword">import</span> gym</div><div class="line"><span class="keyword">from</span> gym.wrappers <span class="keyword">import</span> Monitor</div><div class="line"><span class="keyword">import</span> itertools</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">"../"</span> <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</div><div class="line">  sys.path.append(<span class="string">"../"</span>)</div><div class="line"></div><div class="line"><span class="keyword">from</span> lib <span class="keyword">import</span> plotting</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, namedtuple</div><div class="line"></div><div class="line">env = gym.envs.make(<span class="string">"Breakout-v0"</span>)</div><div class="line"><span class="comment"># Atari Actions: 0 (noop), 1 (fire), 2 (left) and 3 (right) are valid actions</span></div><div class="line">VALID_ACTIONS = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure><p>As mentioned above, we need to crop the image and preprocess the input before feed the raw image into the algorithm. So we define a <strong>StateProcessor</strong> class to do this.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateProcessor</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Processes a raw Atari images. Resizes it and converts it to grayscale.</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Build the Tensorflow graph</span></div><div class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">"state_processor"</span>):</div><div class="line">            self.input_state = tf.placeholder(shape=[<span class="number">210</span>, <span class="number">160</span>, <span class="number">3</span>], dtype=tf.uint8)</div><div class="line">            self.output = tf.image.rgb_to_grayscale(self.input_state)</div><div class="line">            self.output = tf.image.crop_to_bounding_box(self.output, <span class="number">34</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">160</span>)</div><div class="line">            self.output = tf.image.resize_images(</div><div class="line">                self.output, [<span class="number">84</span>, <span class="number">84</span>], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)</div><div class="line">            self.output = tf.squeeze(self.output)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, sess, state)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Args:</div><div class="line">            sess: A Tensorflow session object</div><div class="line">            state: A [210, 160, 3] Atari RGB State</div><div class="line"></div><div class="line">        Returns:</div><div class="line">            A processed [84, 84, 1] state representing grayscale values.</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> sess.run(self.output, &#123; self.input_state: state &#125;)</div></pre></td></tr></table></figure><p>We first convert the image to gray image and then resize it to 84 by 84 (the size DQN paper used). Then, we construct the neural network to estimate the value function. The structure of the network as the same as the DQN paper.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Estimator</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""Q-Value Estimator neural network.</span></div><div class="line"></div><div class="line">    This network is used for both the Q-Network and the Target Network.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, scope=<span class="string">"estimator"</span>, summaries_dir=None)</span>:</span></div><div class="line">        self.scope = scope</div><div class="line">        <span class="comment"># Writes Tensorboard summaries to disk</span></div><div class="line">        self.summary_writer = <span class="keyword">None</span></div><div class="line">        <span class="keyword">with</span> tf.variable_scope(scope):</div><div class="line">            <span class="comment"># Build the graph</span></div><div class="line">            self._build_model()</div><div class="line">            <span class="keyword">if</span> summaries_dir:</div><div class="line">                summary_dir = os.path.join(summaries_dir, <span class="string">"summaries_&#123;&#125;"</span>.format(scope))</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(summary_dir):</div><div class="line">                    os.makedirs(summary_dir)</div><div class="line">                self.summary_writer = tf.summary.FileWriter(summary_dir)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_model</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Builds the Tensorflow graph.</div><div class="line">        """</div><div class="line"></div><div class="line">        <span class="comment"># Placeholders for our input</span></div><div class="line">        <span class="comment"># Our input are 4 RGB frames of shape 160, 160 each</span></div><div class="line">        self.X_pl = tf.placeholder(shape=[<span class="keyword">None</span>, <span class="number">84</span>, <span class="number">84</span>, <span class="number">4</span>], dtype=tf.uint8, name=<span class="string">"X"</span>)</div><div class="line">        <span class="comment"># The TD target value</span></div><div class="line">        self.y_pl = tf.placeholder(shape=[<span class="keyword">None</span>], dtype=tf.float32, name=<span class="string">"y"</span>)</div><div class="line">        <span class="comment"># Integer id of which action was selected</span></div><div class="line">        self.actions_pl = tf.placeholder(shape=[<span class="keyword">None</span>], dtype=tf.int32, name=<span class="string">"actions"</span>)</div><div class="line"></div><div class="line">        X = tf.to_float(self.X_pl) / <span class="number">255.0</span></div><div class="line">        batch_size = tf.shape(self.X_pl)[<span class="number">0</span>]</div><div class="line"></div><div class="line">        <span class="comment"># Three convolutional layers</span></div><div class="line">        conv1 = tf.contrib.layers.conv2d(</div><div class="line">            X, <span class="number">32</span>, <span class="number">8</span>, <span class="number">4</span>, activation_fn=tf.nn.relu)</div><div class="line">        conv2 = tf.contrib.layers.conv2d(</div><div class="line">            conv1, <span class="number">64</span>, <span class="number">4</span>, <span class="number">2</span>, activation_fn=tf.nn.relu)</div><div class="line">        conv3 = tf.contrib.layers.conv2d(</div><div class="line">            conv2, <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>, activation_fn=tf.nn.relu)</div><div class="line"></div><div class="line">        <span class="comment"># Fully connected layers</span></div><div class="line">        flattened = tf.contrib.layers.flatten(conv3)</div><div class="line">        fc1 = tf.contrib.layers.fully_connected(flattened, <span class="number">512</span>)</div><div class="line">        self.predictions = tf.contrib.layers.fully_connected(fc1, len(VALID_ACTIONS))</div><div class="line"></div><div class="line">        <span class="comment"># Get the predictions for the chosen actions only</span></div><div class="line">        gather_indices = tf.range(batch_size) * tf.shape(self.predictions)[<span class="number">1</span>] + self.actions_pl</div><div class="line">        self.action_predictions = tf.gather(tf.reshape(self.predictions, [<span class="number">-1</span>]), gather_indices)</div><div class="line"></div><div class="line">        <span class="comment"># Calcualte the loss</span></div><div class="line">        self.losses = tf.squared_difference(self.y_pl, self.action_predictions)</div><div class="line">        self.loss = tf.reduce_mean(self.losses)</div><div class="line"></div><div class="line">        <span class="comment"># Optimizer Parameters from original paper</span></div><div class="line">        self.optimizer = tf.train.RMSPropOptimizer(<span class="number">0.00025</span>, <span class="number">0.99</span>, <span class="number">0.0</span>, <span class="number">1e-6</span>)</div><div class="line">        self.train_op = self.optimizer.minimize(self.loss, global_step=tf.contrib.framework.get_global_step())</div><div class="line"></div><div class="line">        <span class="comment"># Summaries for Tensorboard</span></div><div class="line">        self.summaries = tf.summary.merge([</div><div class="line">            tf.summary.scalar(<span class="string">"loss"</span>, self.loss),</div><div class="line">            tf.summary.histogram(<span class="string">"loss_hist"</span>, self.losses),</div><div class="line">            tf.summary.histogram(<span class="string">"q_values_hist"</span>, self.predictions),</div><div class="line">            tf.summary.scalar(<span class="string">"max_q_value"</span>, tf.reduce_max(self.predictions))</div><div class="line">        ])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, sess, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Predicts action values.</div><div class="line"></div><div class="line">        Args:</div><div class="line">          sess: Tensorflow session</div><div class="line">          s: State input of shape [batch_size, 4, 160, 160, 3]</div><div class="line"></div><div class="line">        Returns:</div><div class="line">          Tensor of shape [batch_size, NUM_VALID_ACTIONS] containing the estimated </div><div class="line">          action values.</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> sess.run(self.predictions, &#123; self.X_pl: s &#125;)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, sess, s, a, y)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Updates the estimator towards the given targets.</div><div class="line"></div><div class="line">        Args:</div><div class="line">          sess: Tensorflow session object</div><div class="line">          s: State input of shape [batch_size, 4, 160, 160, 3]</div><div class="line">          a: Chosen actions of shape [batch_size]</div><div class="line">          y: Targets of shape [batch_size]</div><div class="line"></div><div class="line">        Returns:</div><div class="line">          The calculated loss on the batch.</div><div class="line">        """</div><div class="line">        feed_dict = &#123; self.X_pl: s, self.y_pl: y, self.actions_pl: a &#125;</div><div class="line">        summaries, global_step, _, loss = sess.run(</div><div class="line">            [self.summaries, tf.contrib.framework.get_global_step(), self.train_op, self.loss],</div><div class="line">            feed_dict)</div><div class="line">        <span class="keyword">if</span> self.summary_writer:</div><div class="line">            self.summary_writer.add_summary(summaries, global_step)</div><div class="line">        <span class="keyword">return</span> loss</div></pre></td></tr></table></figure><p>As mentioned in DQN paper, there are two network that share the same parameters in DQN algorithm. We need to copy the parameters to the target network on each $t$ steps.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_model_parameters</span><span class="params">(sess, estimator1, estimator2)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Copies the model parameters of one estimator to another.</div><div class="line"></div><div class="line">    Args:</div><div class="line">      sess: Tensorflow session instance</div><div class="line">      estimator1: Estimator to copy the paramters from</div><div class="line">      estimator2: Estimator to copy the parameters to</div><div class="line">    """</div><div class="line">    e1_params = [t <span class="keyword">for</span> t <span class="keyword">in</span> tf.trainable_variables() <span class="keyword">if</span> t.name.startswith(estimator1.scope)]</div><div class="line">    e1_params = sorted(e1_params, key=<span class="keyword">lambda</span> v: v.name)</div><div class="line">    e2_params = [t <span class="keyword">for</span> t <span class="keyword">in</span> tf.trainable_variables() <span class="keyword">if</span> t.name.startswith(estimator2.scope)]</div><div class="line">    e2_params = sorted(e2_params, key=<span class="keyword">lambda</span> v: v.name)</div><div class="line"></div><div class="line">    update_ops = []</div><div class="line">    <span class="keyword">for</span> e1_v, e2_v <span class="keyword">in</span> zip(e1_params, e2_params):</div><div class="line">        op = e2_v.assign(e1_v)</div><div class="line">        update_ops.append(op)</div><div class="line"></div><div class="line">    sess.run(update_ops)</div></pre></td></tr></table></figure><p>We also need a policy to take an action.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_epsilon_greedy_policy</span><span class="params">(estimator, nA)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Creates an epsilon-greedy policy based on a given Q-function approximator and epsilon.</div><div class="line"></div><div class="line">    Args:</div><div class="line">        estimator: An estimator that returns q values for a given state</div><div class="line">        nA: Number of actions in the environment.</div><div class="line"></div><div class="line">    Returns:</div><div class="line">        A function that takes the (sess, observation, epsilon) as an argument and returns</div><div class="line">        the probabilities for each action in the form of a numpy array of length nA.</div><div class="line"></div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">policy_fn</span><span class="params">(sess, observation, epsilon)</span>:</span></div><div class="line">        A = np.ones(nA, dtype=float) * epsilon / nA</div><div class="line">        q_values = estimator.predict(sess, np.expand_dims(observation, <span class="number">0</span>))[<span class="number">0</span>]</div><div class="line">        best_action = np.argmax(q_values)</div><div class="line">        A[best_action] += (<span class="number">1.0</span> - epsilon)</div><div class="line">        <span class="keyword">return</span> A</div><div class="line">    <span class="keyword">return</span> policy_fn</div></pre></td></tr></table></figure><p>Now let us to develop the DQN algorithm (we skip the details here because we explained it earlier).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep_q_learning</span><span class="params">(sess,</span></span></div><div class="line">                    env,</div><div class="line">                    q_estimator,</div><div class="line">                    target_estimator,</div><div class="line">                    state_processor,</div><div class="line">                    num_episodes,</div><div class="line">                    experiment_dir,</div><div class="line">                    replay_memory_size=<span class="number">500000</span>,</div><div class="line">                    replay_memory_init_size=<span class="number">50000</span>,</div><div class="line">                    update_target_estimator_every=<span class="number">10000</span>,</div><div class="line">                    discount_factor=<span class="number">0.99</span>,</div><div class="line">                    epsilon_start=<span class="number">1.0</span>,</div><div class="line">                    epsilon_end=<span class="number">0.1</span>,</div><div class="line">                    epsilon_decay_steps=<span class="number">500000</span>,</div><div class="line">                    batch_size=<span class="number">32</span>,</div><div class="line">                    record_video_every=<span class="number">50</span>):</div><div class="line">    <span class="string">"""</span></div><div class="line">    Q-Learning algorithm for fff-policy TD control using Function Approximation.</div><div class="line">    Finds the optimal greedy policy while following an epsilon-greedy policy.</div><div class="line"></div><div class="line">    Args:</div><div class="line">        sess: Tensorflow Session object</div><div class="line">        env: OpenAI environment</div><div class="line">        q_estimator: Estimator object used for the q values</div><div class="line">        target_estimator: Estimator object used for the targets</div><div class="line">        state_processor: A StateProcessor object</div><div class="line">        num_episodes: Number of episodes to run for</div><div class="line">        experiment_dir: Directory to save Tensorflow summaries in</div><div class="line">        replay_memory_size: Size of the replay memory</div><div class="line">        replay_memory_init_size: Number of random experiences to sampel when initializing </div><div class="line">          the reply memory.</div><div class="line">        update_target_estimator_every: Copy parameters from the Q estimator to the </div><div class="line">          target estimator every N steps</div><div class="line">        discount_factor: Lambda time discount factor</div><div class="line">        epsilon_start: Chance to sample a random action when taking an action.</div><div class="line">          Epsilon is decayed over time and this is the start value</div><div class="line">        epsilon_end: The final minimum value of epsilon after decaying is done</div><div class="line">        epsilon_decay_steps: Number of steps to decay epsilon over</div><div class="line">        batch_size: Size of batches to sample from the replay memory</div><div class="line">        record_video_every: Record a video every N episodes</div><div class="line"></div><div class="line">    Returns:</div><div class="line">        An EpisodeStats object with two numpy arrays for episode_lengths and episode_rewards.</div><div class="line">    """</div><div class="line"></div><div class="line">    Transition = namedtuple(<span class="string">"Transition"</span>, [<span class="string">"state"</span>, <span class="string">"action"</span>, <span class="string">"reward"</span>, <span class="string">"next_state"</span>, <span class="string">"done"</span>])</div><div class="line"></div><div class="line">    <span class="comment"># The replay memory</span></div><div class="line">    replay_memory = []</div><div class="line"></div><div class="line">    <span class="comment"># Keeps track of useful statistics</span></div><div class="line">    stats = plotting.EpisodeStats(</div><div class="line">        episode_lengths=np.zeros(num_episodes),</div><div class="line">        episode_rewards=np.zeros(num_episodes))</div><div class="line"></div><div class="line">    <span class="comment"># Create directories for checkpoints and summaries</span></div><div class="line">    checkpoint_dir = os.path.join(experiment_dir, <span class="string">"checkpoints"</span>)</div><div class="line">    checkpoint_path = os.path.join(checkpoint_dir, <span class="string">"model"</span>)</div><div class="line">    monitor_path = os.path.join(experiment_dir, <span class="string">"monitor"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(checkpoint_dir):</div><div class="line">        os.makedirs(checkpoint_dir)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(monitor_path):</div><div class="line">        os.makedirs(monitor_path)</div><div class="line"></div><div class="line">    saver = tf.train.Saver()</div><div class="line">    <span class="comment"># Load a previous checkpoint if we find one</span></div><div class="line">    latest_checkpoint = tf.train.latest_checkpoint(checkpoint_dir)</div><div class="line">    <span class="keyword">if</span> latest_checkpoint:</div><div class="line">        print(<span class="string">"Loading model checkpoint &#123;&#125;...\n"</span>.format(latest_checkpoint))</div><div class="line">        saver.restore(sess, latest_checkpoint)</div><div class="line">    </div><div class="line">    <span class="comment"># Get the current time step</span></div><div class="line">    total_t = sess.run(tf.contrib.framework.get_global_step())</div><div class="line"></div><div class="line">    <span class="comment"># The epsilon decay schedule</span></div><div class="line">    epsilons = np.linspace(epsilon_start, epsilon_end, epsilon_decay_steps)</div><div class="line"></div><div class="line">    <span class="comment"># The policy we're following</span></div><div class="line">    policy = make_epsilon_greedy_policy(</div><div class="line">        q_estimator,</div><div class="line">        len(VALID_ACTIONS))</div><div class="line"></div><div class="line">    <span class="comment"># Populate the replay memory with initial experience</span></div><div class="line">    print(<span class="string">"Populating replay memory..."</span>)</div><div class="line">    state = env.reset()</div><div class="line">    state = state_processor.process(sess, state)</div><div class="line">    state = np.stack([state] * <span class="number">4</span>, axis=<span class="number">2</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(replay_memory_init_size):</div><div class="line">        action_probs = policy(sess, state, epsilons[min(total_t, epsilon_decay_steps<span class="number">-1</span>)])</div><div class="line">        action = np.random.choice(np.arange(len(action_probs)), p=action_probs)</div><div class="line">        next_state, reward, done, _ = env.step(VALID_ACTIONS[action])</div><div class="line">        next_state = state_processor.process(sess, next_state)</div><div class="line">        next_state = np.append(state[:,:,<span class="number">1</span>:], np.expand_dims(next_state, <span class="number">2</span>), axis=<span class="number">2</span>)</div><div class="line">        replay_memory.append(Transition(state, action, reward, next_state, done))</div><div class="line">        <span class="keyword">if</span> done:</div><div class="line">            state = env.reset()</div><div class="line">            state = state_processor.process(sess, state)</div><div class="line">            state = np.stack([state] * <span class="number">4</span>, axis=<span class="number">2</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            state = next_state</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Record videos</span></div><div class="line">    <span class="comment"># Add env Monitor wrapper</span></div><div class="line">    env = Monitor(env, directory=monitor_path, video_callable=<span class="keyword">lambda</span> count: count % record_video_every == <span class="number">0</span>, resume=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i_episode <span class="keyword">in</span> range(num_episodes):</div><div class="line"></div><div class="line">        <span class="comment"># Save the current checkpoint</span></div><div class="line">        saver.save(tf.get_default_session(), checkpoint_path)</div><div class="line"></div><div class="line">        <span class="comment"># Reset the environment</span></div><div class="line">        state = env.reset()</div><div class="line">        state = state_processor.process(sess, state)</div><div class="line">        state = np.stack([state] * <span class="number">4</span>, axis=<span class="number">2</span>)</div><div class="line">        loss = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="comment"># One step in the environment</span></div><div class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> itertools.count():</div><div class="line"></div><div class="line">            <span class="comment"># Epsilon for this time step</span></div><div class="line">            epsilon = epsilons[min(total_t, epsilon_decay_steps<span class="number">-1</span>)]</div><div class="line"></div><div class="line">            <span class="comment"># Add epsilon to Tensorboard</span></div><div class="line">            episode_summary = tf.Summary()</div><div class="line">            episode_summary.value.add(simple_value=epsilon, tag=<span class="string">"epsilon"</span>)</div><div class="line">            q_estimator.summary_writer.add_summary(episode_summary, total_t)</div><div class="line"></div><div class="line">            <span class="comment"># Maybe update the target estimator</span></div><div class="line">            <span class="keyword">if</span> total_t % update_target_estimator_every == <span class="number">0</span>:</div><div class="line">                copy_model_parameters(sess, q_estimator, target_estimator)</div><div class="line">                print(<span class="string">"\nCopied model parameters to target network."</span>)</div><div class="line"></div><div class="line">            <span class="comment"># Print out which step we're on, useful for debugging.</span></div><div class="line">            print(<span class="string">"\rStep &#123;&#125; (&#123;&#125;) @ Episode &#123;&#125;/&#123;&#125;, loss: &#123;&#125;"</span>.format(</div><div class="line">                    t, total_t, i_episode + <span class="number">1</span>, num_episodes, loss), end=<span class="string">""</span>)</div><div class="line">            sys.stdout.flush()</div><div class="line"></div><div class="line">            <span class="comment"># Take a step</span></div><div class="line">            action_probs = policy(sess, state, epsilon)</div><div class="line">            action = np.random.choice(np.arange(len(action_probs)), p=action_probs)</div><div class="line">            next_state, reward, done, _ = env.step(VALID_ACTIONS[action])</div><div class="line">            next_state = state_processor.process(sess, next_state)</div><div class="line">            next_state = np.append(state[:,:,<span class="number">1</span>:], np.expand_dims(next_state, <span class="number">2</span>), axis=<span class="number">2</span>)</div><div class="line"></div><div class="line">            <span class="comment"># If our replay memory is full, pop the first element</span></div><div class="line">            <span class="keyword">if</span> len(replay_memory) == replay_memory_size:</div><div class="line">                replay_memory.pop(<span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="comment"># Save transition to replay memory</span></div><div class="line">            replay_memory.append(Transition(state, action, reward, next_state, done))   </div><div class="line"></div><div class="line">            <span class="comment"># Update statistics</span></div><div class="line">            stats.episode_rewards[i_episode] += reward</div><div class="line">            stats.episode_lengths[i_episode] = t</div><div class="line"></div><div class="line">            <span class="comment"># Sample a minibatch from the replay memory</span></div><div class="line">            samples = random.sample(replay_memory, batch_size)</div><div class="line">            states_batch, action_batch, reward_batch, next_states_batch, done_batch = map(np.array, zip(*samples))</div><div class="line"></div><div class="line">            <span class="comment"># Calculate q values and targets</span></div><div class="line">            q_values_next = target_estimator.predict(sess, next_states_batch)</div><div class="line">            targets_batch = reward_batch + np.invert(done_batch).astype(np.float32) * discount_factor * np.amax(q_values_next, axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">            <span class="comment"># Perform gradient descent update</span></div><div class="line">            states_batch = np.array(states_batch)</div><div class="line">            loss = q_estimator.update(sess, states_batch, action_batch, targets_batch)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> done:</div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">            state = next_state</div><div class="line">            total_t += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="comment"># Add summaries to tensorboard</span></div><div class="line">        episode_summary = tf.Summary()</div><div class="line">        episode_summary.value.add(simple_value=stats.episode_rewards[i_episode], node_name=<span class="string">"episode_reward"</span>, tag=<span class="string">"episode_reward"</span>)</div><div class="line">        episode_summary.value.add(simple_value=stats.episode_lengths[i_episode], node_name=<span class="string">"episode_length"</span>, tag=<span class="string">"episode_length"</span>)</div><div class="line">        q_estimator.summary_writer.add_summary(episode_summary, total_t)</div><div class="line">        q_estimator.summary_writer.flush()</div><div class="line"></div><div class="line">        <span class="keyword">yield</span> total_t, plotting.EpisodeStats(</div><div class="line">            episode_lengths=stats.episode_lengths[:i_episode+<span class="number">1</span>],</div><div class="line">            episode_rewards=stats.episode_rewards[:i_episode+<span class="number">1</span>])</div><div class="line"></div><div class="line">    <span class="keyword">return</span> stats</div></pre></td></tr></table></figure><p>Finally, run it.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">tf.reset_default_graph()</div><div class="line"></div><div class="line"><span class="comment"># Where we save our checkpoints and graphs</span></div><div class="line">experiment_dir = os.path.abspath(<span class="string">"./experiments/&#123;&#125;"</span>.format(env.spec.id))</div><div class="line"></div><div class="line"><span class="comment"># Create a glboal step variable</span></div><div class="line">global_step = tf.Variable(<span class="number">0</span>, name=<span class="string">'global_step'</span>, trainable=<span class="keyword">False</span>)</div><div class="line">    </div><div class="line"><span class="comment"># Create estimators</span></div><div class="line">q_estimator = Estimator(scope=<span class="string">"q"</span>, summaries_dir=experiment_dir)</div><div class="line">target_estimator = Estimator(scope=<span class="string">"target_q"</span>)</div><div class="line"></div><div class="line"><span class="comment"># State processor</span></div><div class="line">state_processor = StateProcessor()</div><div class="line"></div><div class="line"><span class="comment"># Run it!</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    <span class="keyword">for</span> t, stats <span class="keyword">in</span> deep_q_learning(sess,</div><div class="line">                                    env,</div><div class="line">                                    q_estimator=q_estimator,</div><div class="line">                                    target_estimator=target_estimator,</div><div class="line">                                    state_processor=state_processor,</div><div class="line">                                    experiment_dir=experiment_dir,</div><div class="line">                                    num_episodes=<span class="number">10000</span>,</div><div class="line">                                    replay_memory_size=<span class="number">500000</span>,</div><div class="line">                                    replay_memory_init_size=<span class="number">50000</span>,</div><div class="line">                                    update_target_estimator_every=<span class="number">10000</span>,</div><div class="line">                                    epsilon_start=<span class="number">1.0</span>,</div><div class="line">                                    epsilon_end=<span class="number">0.1</span>,</div><div class="line">                                    epsilon_decay_steps=<span class="number">500000</span>,</div><div class="line">                                    discount_factor=<span class="number">0.99</span>,</div><div class="line">                                    batch_size=<span class="number">32</span>):</div><div class="line"></div><div class="line">        print(<span class="string">"\nEpisode Reward: &#123;&#125;"</span>.format(stats.episode_rewards[<span class="number">-1</span>]))</div></pre></td></tr></table></figure><hr><p>Next, we will develop the Double-DQN algorithm. This algorithm only has a little changes.</p><p>In DQN <strong>q_learning</strong> method,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Calculate q values and targets</span></div><div class="line">q_values_next = target_estimator.predict(sess, next_states_batch)</div><div class="line">targets_batch = reward_batch + np.invert(done_batch).astype(np.float32) * discount_factor * np.amax(q_values_next, axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><p>we just change these codes to,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Calculate q values and targets</span></div><div class="line"><span class="comment"># This is where Double Q-Learning comes in!</span></div><div class="line">q_values_next = q_estimator.predict(sess, next_states_batch)</div><div class="line">best_actions = np.argmax(q_values_next, axis=<span class="number">1</span>)</div><div class="line">q_values_next_target = target_estimator.predict(sess, next_states_batch)</div><div class="line">targets_batch = reward_batch + np.invert(done_batch).astype(np.float32) * discount_factor * q_values_next_target[np.arange(batch_size), best_actions]</div></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/07/Using-Keras-and-Deep-Q-Network-to-Play-FlappyBird-Repost/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/07/07/Using-Keras-and-Deep-Q-Network-to-Play-FlappyBird-Repost/" itemprop="url">Using Keras and Deep Q-Network to Play FlappyBird (Repost)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-07T04:19:18+08:00">2017-07-07 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/07/07/Using-Keras-and-Deep-Q-Network-to-Play-FlappyBird-Repost/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2017/07/07/Using-Keras-and-Deep-Q-Network-to-Play-FlappyBird-Repost/" itemprop="commentsCount"></span> </a></span><span id="/2017/07/07/Using-Keras-and-Deep-Q-Network-to-Play-FlappyBird-Repost/" class="leancloud_visitors" data-flag-title="Using Keras and Deep Q-Network to Play FlappyBird (Repost)"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>200 lines of python code to demonstrate DQN with Keras</p><p><img src="https://yanpanlau.github.io/img/animation1.gif" alt="img"></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>This project demonstrates how to use the Deep-Q Learning algorithm with Keras together to play FlappyBird.</p><p>This article is intended to target newcomers who are interested in Reinforcement Learning.</p><h1 id="Installation-Dependencies"><a href="#Installation-Dependencies" class="headerlink" title="Installation Dependencies:"></a>Installation Dependencies:</h1><p>(Update : 13 March 2017, code and weight file has been updated to support latest version of tensorflow and keras)</p><ul><li>Python 2.7</li><li>Keras 1.0</li><li>pygame</li><li>scikit-image</li></ul><h1 id="How-to-Run"><a href="#How-to-Run" class="headerlink" title="How to Run?"></a>How to Run?</h1><p><strong>CPU only/TensorFlow</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/yanpanlau/Keras-FlappyBird.git</div><div class="line">cd Keras-FlappyBird</div><div class="line">python qlearn.py -m &quot;Run&quot;</div></pre></td></tr></table></figure><p><strong>GPU version (Theano)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/yanpanlau/Keras-FlappyBird.git</div><div class="line">cd Keras-FlappyBird</div><div class="line">THEANO_FLAGS=device=gpu,floatX=float32,lib.cnmem=0.2 python qlearn.py -m &quot;Run&quot;</div></pre></td></tr></table></figure><p><strong>lib.cnmem=0.2</strong> means you assign only 20% of the GPU’s memory to the program.</p><p><strong>If you want to train the network from beginning, delete “model.h5” and run qlearn.py -m “Train”</strong></p><h1 id="What-is-Deep-Q-Network"><a href="#What-is-Deep-Q-Network" class="headerlink" title="What is Deep Q-Network?"></a>What is Deep Q-Network?</h1><p>Deep Q-Network is a learning algorithm developed by Google DeepMind to play Atari games. They demonstrated how a computer learned to play Atari 2600 video games by observing just the screen pixels and receiving a reward when the game score increased. The result was remarkable because it demonstrates the algorithm is generic enough to play various games.</p><p>The following post is a must-read for those who are interested in deep reinforcement learning.</p><p><a href="https://www.nervanasys.com/demystifying-deep-reinforcement-learning/" target="_blank" rel="external">Demystifying Deep Reinforcement Learning</a></p><h1 id="Code-Explanation-in-details"><a href="#Code-Explanation-in-details" class="headerlink" title="Code Explanation (in details)"></a>Code Explanation (in details)</h1><p>Let’s go though the example in <strong>qlearn.py</strong>, line by line. If you familiar with Keras and DQN, you can skip this session</p><p>The code simply does the following:</p><ol><li>The code receives the Game Screen Input in the form of a pixel array</li><li>The code does some image pre-processing</li><li>The processed image will be fed into a neural network (Convolution Neural Network), and the network will then decide the best action to execute (Flap or Not Flap)</li><li>The network will be trained millions of times, via an algorithm called Q-learning, to maximize the future expected reward.</li></ol><h3 id="Game-Screen-Input"><a href="#Game-Screen-Input" class="headerlink" title="Game Screen Input"></a>Game Screen Input</h3><p>First of all, the FlappyBird is already written in Python via pygame, so here is the code snippet to access the FlappyBird API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import wrapped_flappy_bird as game</div><div class="line">x_t1_colored, r_t, terminal = game_state.frame_step(a_t)</div></pre></td></tr></table></figure><p>The idea is quite simple, the input is <strong>a_t</strong> (0 represent don’t flap, 1 represent flap), the API will give you the next frame <strong>x_t1_colored</strong>, the <strong>reward</strong> (0.1 if alive, +1 if pass the pipe, -1 if die) and <strong>terminal</strong> is a boolean flag indicates whether the game is FINISHED or NOT. We also followed DeepMind suggestion to clip the reward between [-1,+1] to improve the stability. I have not yet get a chance to test out different reward functions but it would be an interesting exercise to see how the performance is changed with different reward functions.</p><p>Interesting readers can modify the reward function in <strong>game/wrapped_flappy_bird.py”, under the function **def frame_step(self, input_actions)</strong></p><h3 id="Image-pre-processing"><a href="#Image-pre-processing" class="headerlink" title="Image pre-processing"></a>Image pre-processing</h3><p><img src="https://yanpanlau.github.io/img/bird.jpg" alt="img"></p><p>In order to make the code train faster, it is vital to do some image processing. Here are the key elements:</p><ol><li>I first convert the color image into grayscale</li><li>I crop down the image size into 80x80 pixel</li><li>I stack 4 frames together before I feed into neural network.</li></ol><p>Why do I need to stack 4 frames together? This is one way for the model to be able to infer the velocity information of the bird.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x_t1 = skimage.color.rgb2gray(x_t1_colored)</div><div class="line">x_t1 = skimage.transform.resize(x_t1,(<span class="number">80</span>,<span class="number">80</span>))</div><div class="line">x_t1 = skimage.exposure.rescale_intensity(x_t1, out_range=(<span class="number">0</span>, <span class="number">255</span>))</div><div class="line"></div><div class="line">x_t1 = x_t1.reshape(<span class="number">1</span>, <span class="number">1</span>, x_t1.shape[<span class="number">0</span>], x_t1.shape[<span class="number">1</span>])</div><div class="line">s_t1 = np.append(x_t1, s_t[:, :<span class="number">3</span>, :, :], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure><p><strong>x_t1</strong> is a single frame with shape (1x1x80x80) and <strong>s_t1</strong> is the stacked frame with shape (1x4x80x80). You might ask, why the input dimension is (1x4x80x80) but not (4x80x80)? Well, it is a requirement in Keras so let’s stick with it.</p><p>Note: Some readers may ask what is <strong>axis=1</strong>? It means that when I stack the frames, I want to stack on the “2nd” dimension. i.e. I am stacking under (1x<strong>4</strong>x80x80), the 2nd index.</p><h3 id="Convolution-Neural-Network"><a href="#Convolution-Neural-Network" class="headerlink" title="Convolution Neural Network"></a>Convolution Neural Network</h3><p>Now, we can input the pre-processed screen into the neural network, which is a convolution neural network:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildmodel</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Now we build the model"</span>)</div><div class="line">    model = Sequential()</div><div class="line">    model.add(Convolution2D(<span class="number">32</span>, <span class="number">8</span>, <span class="number">8</span>, subsample=(<span class="number">4</span>,<span class="number">4</span>),init=<span class="keyword">lambda</span> shape, name: normal(shape, scale=<span class="number">0.01</span>, name=name), border_mode=<span class="string">'same'</span>,input_shape=(img_channels,img_rows,img_cols)))</div><div class="line">    model.add(Activation(<span class="string">'relu'</span>))</div><div class="line">    model.add(Convolution2D(<span class="number">64</span>, <span class="number">4</span>, <span class="number">4</span>, subsample=(<span class="number">2</span>,<span class="number">2</span>),init=<span class="keyword">lambda</span> shape, name: normal(shape, scale=<span class="number">0.01</span>, name=name), border_mode=<span class="string">'same'</span>))</div><div class="line">    model.add(Activation(<span class="string">'relu'</span>))</div><div class="line">    model.add(Convolution2D(<span class="number">64</span>, <span class="number">3</span>, <span class="number">3</span>, subsample=(<span class="number">1</span>,<span class="number">1</span>),init=<span class="keyword">lambda</span> shape, name: normal(shape, scale=<span class="number">0.01</span>, name=name), border_mode=<span class="string">'same'</span>))</div><div class="line">    model.add(Activation(<span class="string">'relu'</span>))</div><div class="line">    model.add(Flatten())</div><div class="line">    model.add(Dense(<span class="number">512</span>, init=<span class="keyword">lambda</span> shape, name: normal(shape, scale=<span class="number">0.01</span>, name=name)))</div><div class="line">    model.add(Activation(<span class="string">'relu'</span>))</div><div class="line">    model.add(Dense(<span class="number">2</span>,init=<span class="keyword">lambda</span> shape, name: normal(shape, scale=<span class="number">0.01</span>, name=name)))</div><div class="line">   </div><div class="line">    adam = Adam(lr=<span class="number">1e-6</span>)</div><div class="line">    model.compile(loss=<span class="string">'mse'</span>,optimizer=adam)</div><div class="line">    print(<span class="string">"We finish building the model"</span>)</div><div class="line">    <span class="keyword">return</span> model</div></pre></td></tr></table></figure><p>The exact architecture is following : The input to the neural network consists of an 4x80x80 images. The first hidden layer convolves 32 filters of 8 x 8 with stride 4 and applies ReLU activation function. The 2nd layer convolves a 64 filters of 4 x 4 with stride 2 and applies ReLU activation function. The 3rd layer convolves a 64 filters of 3 x 3 with stride 1 and applies ReLU activation function. The final hidden layer is fully-connected consisted of 512 rectifier units. The output layer is a fully-connected linear layer with a single output for each valid action.</p><p>So wait, what is convolution? The easiest way to understand a convolution is by thinking of it as a sliding window function apply to a matrix. The following gif file should help to understand.</p><p><img src="https://yanpanlau.github.io/img/Convolution_schematic.gif" alt="Convolution with 3×3 Filter. Source: http://deeplearning.stanford.edu/wiki/index.php/Feature_extraction_using_convolution"></p><p>You might ask what’s the purpose the convolution? It actually help computer to learn higher features like edges and shapes. The example below shows how the edges are stand out after a convolution filter is applied</p><p><img src="https://yanpanlau.github.io/img/generic-taj-convmatrix-edge-detect.jpg" alt="Using Convolution to detect Edges"></p><p>For more details about Convolution in Neural Network, please read <a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="external">Understanding Convolution Neural Networks for NLP</a></p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Keras makes it very easy to build convolution neural network. However, there are few things I would like to highlight</p><p>A) It is important to choose a right initialization method. I choose normal distribution with $\sigma=0.01$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init=<span class="keyword">lambda</span> shape, name: normal(shape, scale=<span class="number">0.01</span>, name=name)</div></pre></td></tr></table></figure><p>B) The ordering of the dimension is important, the default setting is 4x80x80 (Theano setting), so if your input is 80x80x4 (Tensorflow setting) then you are in trouble because the dimension is wrong. <strong>Alert</strong>: If your input dimension is 80x80x4 (Tensorflow setting) you need to set <strong>dim_ordering = tf</strong> (tf means tensorflow, th means theano)</p><p>C) In Keras, <strong>subsample=(2,2)</strong> means you down sample the image size from (80x80) to (40x40). In ML literature it is often called “stride”</p><p>D) We have used an adaptive learning algorithm called ADAM to do the optimization. The learning rate is <strong>1-e6</strong>.</p><p>Interested readers who want to learn more various learning algoithms please read below</p><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="external">An overview of gradient descent optimization algorithms</a></p><h3 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h3><p>Finally, we can using the Q-learning algorithm to train the neural network.</p><p>So, what is Q-learning? In Q-learning the most important thing is the Q-function : Q(s, a) representing the maximum discounted future reward when we perform action <strong>a</strong> in state <strong>s</strong>. <strong>Q(s, a)</strong> gives you an estimation of how good to choose an action <strong>a</strong> in state <strong>s</strong>.</p><p>REPEAT : <strong>Q(s, a)</strong> representing the maximum discounted future reward when we perform action <strong>a</strong> in state <strong>s</strong></p><p>You might ask 1) Why Q-function is useful? 2) How can I get the Q-function?</p><p>Let me give you an analogy of the Q-function: Suppose you are playing a difficult RPG game and you don’t know how to play it well. If you have bought a strategy guide, which is an instruction book that contain hints or complete solutions to a specific video game, then playing that video game is easy. You just follow the guidiance from the strategy book. Here, Q-function is similar to a strategy guide. Suppose you are in state <strong>s</strong> and you need to decide whether you take action <strong>a</strong> or <strong>b</strong>. If you have this magical Q-function, the answers become really simple – pick the action with highest Q-value!</p><p>$$<br>{\pi(s) = {argmax}_{a} Q(s,a)}<br>$$<br>Here, $\pi$ represents the policy, which you will often see in the ML literature.</p><p>How do we get the Q-function? That’s where Q-learning is coming from. Let me quickly derive here:</p><p>Define total future reward from time <strong>t</strong> onward<br>$$<br>R_t = r_t + r_{t+1} + r_{t+2} … + r_n<br>$$<br>But because our environment is stochastic, we can never be sure, the more future we go, the more uncertain. Therefore, it is common to use <strong>discount future reward</strong> instead<br>$$<br>R_t = r_t + \gamma r_{t+1} + \gamma^{2} r_{t+2} … + \gamma^{n-t} r_n<br>$$<br>which, can be written as<br>$$<br>R_t = r_t + \gamma \ast R_{t+1}<br>$$<br>Recall the definition of Q-function (maximum discounted future reward if we choose action <strong>a</strong> in state <strong>s</strong>)<br>$$<br>Q(s_t, a_t) = max R_{t+1}<br>$$<br>therefore, we can rewrite the Q-function as below<br>$$<br>Q(s, a) = r + \gamma \ast max_{a^{‘}} Q(s^{\prime}, a^{\prime})<br>$$<br>In plain English, it means maximum future reward for this state and action (s,a) is the immediate reward r <strong>plus</strong> maximum future reward for the next state $s^{\prime}$ , action $a^{\prime}$</p><p>We could now use an iterative method to solve for the Q-function. Given a transition $(s, a, r, s^{\prime})$ , we are going to convert this episode into training set for the network. i.e. We want $r + \gamma max_a Q (s,a)$ to be equal to $Q(s,a)$. You can think of finding a Q-value is a regession task now, I have a estimator $r + \gamma max_a Q (s,a)$ and a predictor $Q(s,a)$, I can define the mean squared error (MSE), or the loss function, as below:</p><p>Define a loss function<br>$$<br>L = [r + \gamma max_{a^{\prime}} Q (s^{\prime},a^{\prime}) - Q(s,a)]^{2}<br>$$<br>Given a transition $(s, a, r, s^{\prime})$, how can I optimize my Q-function such that it returns the smallest mean squared error loss? If L getting smaller, we know the Q-function is getting converged into the optimal value, which is our “strategy book”.</p><p>Now, you might ask, where is the role of the neural network? This is where the <strong>DEEP Q-Learning</strong> comes in. You recall that $Q(s,a)$, is a stategy book, which contains millions or trillions of states and actions if you display as a table. The idea of the DQN is that I use the neural network to <strong>COMPRESS</strong> this Q-table, using some parameters \thetaθ <strong>(We called it weight in Neural Network)</strong>. So instead of handling a large table, I just need to worry the weights of the neural network. By smartly tuning the weight parameters, I can find the optimal Q-function via the various Neural Network training algorithm.<br>$$<br>Q(s,a) = f_{\theta}(s)<br>$$<br>where $f$ is our neural network with input $s$ and weight parameters $\theta$</p><p>Here is the code below to demonstrate how it works</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> t &gt; OBSERVE:</div><div class="line">    <span class="comment">#sample a minibatch to train on</span></div><div class="line">    minibatch = random.sample(D, BATCH)</div><div class="line"></div><div class="line">    inputs = np.zeros((BATCH, s_t.shape[<span class="number">1</span>], s_t.shape[<span class="number">2</span>], s_t.shape[<span class="number">3</span>]))   <span class="comment">#32, 80, 80, 4</span></div><div class="line">    targets = np.zeros((inputs.shape[<span class="number">0</span>], ACTIONS))                         <span class="comment">#32, 2</span></div><div class="line"></div><div class="line">    <span class="comment">#Now we do the experience replay</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(minibatch)):</div><div class="line">        state_t = minibatch[i][<span class="number">0</span>]</div><div class="line">        action_t = minibatch[i][<span class="number">1</span>]   <span class="comment">#This is action index</span></div><div class="line">        reward_t = minibatch[i][<span class="number">2</span>]</div><div class="line">        state_t1 = minibatch[i][<span class="number">3</span>]</div><div class="line">        terminal = minibatch[i][<span class="number">4</span>]</div><div class="line">        <span class="comment"># if terminated, only equals reward</span></div><div class="line"></div><div class="line">        inputs[i:i + <span class="number">1</span>] = state_t    <span class="comment">#I saved down s_t</span></div><div class="line"></div><div class="line">        targets[i] = model.predict(state_t)  <span class="comment"># Hitting each buttom probability</span></div><div class="line">        Q_sa = model.predict(state_t1)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> terminal:</div><div class="line">            targets[i, action_t] = reward_t</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            targets[i, action_t] = reward_t + GAMMA * np.max(Q_sa)</div><div class="line"></div><div class="line">        loss += model.train_on_batch(inputs, targets)</div><div class="line"></div><div class="line">    s_t = s_t1</div><div class="line">    t = t + <span class="number">1</span></div></pre></td></tr></table></figure><h3 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h3><p>If you examine the code above, there is a comment called “Experience Replay”. Let me explain what it does: It was found that approximation of Q-value using non-linear functions like neural network is not very stable. The most important trick to solve this problem is called <strong>experience replay</strong>. During the gameplay all the episode $(s, a, r, s^{‘})$ are stored in replay memory <strong>D</strong>. (I use Python function deque() to store it). When training the network, random mini-batches from the replay memory are used instead of most the recent transition, which will greatly improve the stability.</p><h3 id="Exploration-vs-Exploitation"><a href="#Exploration-vs-Exploitation" class="headerlink" title="Exploration vs. Exploitation"></a>Exploration vs. Exploitation</h3><p>There is another issue in the reinforcement learning algorithm which called Exploration vs. Exploitation. How much of an agent’s time should be spent exploiting its existing known-good policy, and how much time should be focused on exploring new, possibility better, actions? We often encounter similar situations in real life too. For example, we face on which restaurant to go to on Saturday night. We all have a set of restaurants that we prefer, based on our policy/strategy book $Q(s,a)$. If we stick to our normal preference, there is a strong probability that we’ll pick a good restaurant. However, sometimes, we occasionally like to try new restaurants to see if they are better. The RL agents face the same problem. In order to maximize future reward, they need to balance the amount of time that they follow their current policy (this is called being “greedy”), and the time they spend exploring new possibilities that might be better. A popular approach is called $\epsilon$ greedy approach. Under this approach, the policy tells the agent to try a random action some percentage of the time, as defined by the variable $\epsilon$ (epsilon), which is a number between 0 and 1. The strategy will help the RL agent to occasionally try something new and see if we can achieve ultimate strategy.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> random.random() &lt;= epsilon:</div><div class="line">    print(<span class="string">"----------Random Action----------"</span>)</div><div class="line">    action_index = random.randrange(ACTIONS)</div><div class="line">    a_t[action_index] = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">    q = model.predict(s_t)       <span class="comment">#input a stack of 4 images, get the prediction</span></div><div class="line">    max_Q = np.argmax(q)</div><div class="line">    action_index = max_Q</div><div class="line">    a_t[max_Q] = <span class="number">1</span></div></pre></td></tr></table></figure><p>I think that’s it. I hope this blog will help you to understand how DQN works.</p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h3 id="My-training-is-very-slow"><a href="#My-training-is-very-slow" class="headerlink" title="My training is very slow"></a>My training is very slow</h3><p>You might need a GPU to accelerate the calculation. I used a TITAN X and train for at least 1 million frames to make it work</p><h1 id="Future-works-and-thoughts"><a href="#Future-works-and-thoughts" class="headerlink" title="Future works and thoughts"></a>Future works and thoughts</h1><ol><li>Current DQN depends on large experience replay. Is it possible to replace it or even remove it?</li><li>How can one decide on the optimal Convolution Neural Network?</li><li>Training is very slow, how to speed it up/to make the model converge faster?</li><li>What does the Neural Network actually learn? Is the knowledge transferable?</li></ol><p>I believe the questions are still not resolved and it’s an active research area in Machine Learning.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Mnih Volodymyr, Koray Kavukcuoglu, David Silver, Andrei A. Rusu, Joel Veness, Marc G. Bellemare, Alex Graves, Martin Riedmiller, Andreas K. Fidjeland, Georg Ostrovski, Stig Petersen, Charles Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra, Shane Legg, and Demis Hassabis. <strong>Human-level Control through Deep Reinforcement Learning</strong>. Nature, 529-33, 2015.</p><h1 id="Disclaimer"><a href="#Disclaimer" class="headerlink" title="Disclaimer"></a>Disclaimer</h1><p>This work is highly based on the following repos:</p><p><a href="https://github.com/yenchenlin/DeepLearningFlappyBird" target="_blank" rel="external">https://github.com/yenchenlin/DeepLearningFlappyBird</a></p><p><a href="http://edersantana.github.io/articles/keras_rl/" target="_blank" rel="external">http://edersantana.github.io/articles/keras_rl/</a></p><h1 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h1><p>I must thank to <a href="https://twitter.com/hardmaru" target="_blank" rel="external">@hardmaru</a> to encourage me to write this blog. I also thank to <a href="https://twitter.com/fchollet" target="_blank" rel="external">@fchollet</a> to help me on the weight initialization in Keras and <a href="https://twitter.com/edersantana" target="_blank" rel="external">@edersantana</a> his post on Keras and reinforcement learning which really help me to understand it.</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/07/Demystifying-Deep-Reinforcement-Learning/"><span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ewan Li"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Abracadabra"><span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject"><img style="display:none" itemprop="url image" alt="Abracadabra" src=""></span></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/07/07/Demystifying-Deep-Reinforcement-Learning/" itemprop="url">Demystifying Deep Reinforcement Learning (Repost)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-07T01:36:44+08:00">2017-07-07 </time></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/07/07/Demystifying-Deep-Reinforcement-Learning/#comments" itemprop="discussionUrl"><span class="post-comments-count hc-comment-count" data-xid="2017/07/07/Demystifying-Deep-Reinforcement-Learning/" itemprop="commentsCount"></span> </a></span><span id="/2017/07/07/Demystifying-Deep-Reinforcement-Learning/" class="leancloud_visitors" data-flag-title="Demystifying Deep Reinforcement Learning (Repost)"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Visitors </span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Two years ago, a small company in London called DeepMind uploaded their pioneering paper “<a href="http://arxiv.org/abs/1312.5602" target="_blank" rel="external">Playing Atari with Deep Reinforcement Learning</a>” to Arxiv. In this paper they demonstrated how a computer learned to play Atari 2600 video games by observing just the screen pixels and receiving a reward when the game score increased. The result was remarkable, because the games and the goals in every game were very different and designed to be challenging for humans. The same model architecture, without any change, was used to learn seven different games, and in three of them the algorithm performed even better than a human!</p><p>It has been hailed since then as the first step towards <a href="https://en.wikipedia.org/wiki/Artificial_general_intelligence" target="_blank" rel="external">general artificial intelligence</a> – an AI that can survive in a variety of environments, instead of being confined to strict realms such as playing chess. No wonder <a href="http://techcrunch.com/2014/01/26/google-deepmind/" target="_blank" rel="external">DeepMind was immediately bought by Google</a> and has been on the forefront of deep learning research ever since. In February 2015 their paper “<a href="http://www.nature.com/articles/nature14236" target="_blank" rel="external">Human-level control through deep reinforcement learning</a>” was featured on the cover of Nature, one of the most prestigious journals in science. In this paper they applied the same model to 49 different games and achieved superhuman performance in half of them.</p><p>Still, while deep models for supervised and unsupervised learning have seen widespread adoption in the community, deep reinforcement learning has remained a bit of a mystery. In this blog post I will be trying to demystify this technique and understand the rationale behind it. The intended audience is someone who already has background in machine learning and possibly in neural networks, but hasn’t had time to delve into reinforcement learning yet.</p><p>The roadmap ahead:</p><ol><li><strong>What are the main challenges in reinforcement learning?</strong> We will cover the credit assignment problem and the exploration-exploitation dilemma here.</li><li><strong>How to formalize reinforcement learning in mathematical terms?</strong> We will define Markov Decision Process and use it for reasoning about reinforcement learning.</li><li><strong>How do we form long-term strategies?</strong> We define “discounted future reward”, that forms the main basis for the algorithms in the next sections.</li><li><strong>How can we estimate or approximate the future reward?</strong> Simple table-based Q-learning algorithm is defined and explained here.</li><li><strong>What if our state space is too big?</strong> Here we see how Q-table can be replaced with a (deep) neural network.</li><li><strong>What do we need to make it actually work?</strong> Experience replay technique will be discussed here, that stabilizes the learning with neural networks.</li><li><strong>Are we done yet?</strong> Finally we will consider some simple solutions to the exploration-exploitation problem.</li></ol><h1 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h1><p>Consider the game Breakout. In this game you control a paddle at the bottom of the screen and have to bounce the ball back to clear all the bricks in the upper half of the screen. Each time you hit a brick, it disappears and your score increases – you get a reward.</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.08.53-AM.png" alt="img">Figure 1: Atari Breakout game. Image credit: DeepMind.</p><p>Suppose you want to teach a neural network to play this game. Input to your network would be screen images, and output would be three actions: left, right or fire (to launch the ball). It would make sense to treat it as a classification problem – for each game screen you have to decide, whether you should move left, right or press fire. Sounds straightforward? Sure, but then you need training examples, and a lots of them. Of course you could go and record game sessions using expert players, but that’s not really how we learn. We don’t need somebody to tell us a million times which move to choose at each screen. We just need occasional feedback that we did the right thing and can then figure out everything else ourselves.</p><p>This is the task <strong>reinforcement learning </strong>tries to solve. Reinforcement learning lies somewhere in between supervised and unsupervised learning. Whereas in supervised learning one has a target label for each training example and in unsupervised learning one has no labels at all, in reinforcement learning one has sparse and time-delayed labels – the rewards. Based only on those rewards the agent has to learn to behave in the environment.</p><p>While the idea is quite intuitive, in practice there are numerous challenges. For example when you hit a brick and score a reward in the Breakout game, it often has nothing to do with the actions (paddle movements) you did just before getting the reward. All the hard work was already done, when you positioned the paddle correctly and bounced the ball back. This is called the <strong>credit assignment problem</strong> – i.e., which of the preceding actions was responsible for getting the reward and to what extent.</p><p>Once you have figured out a strategy to collect a certain number of rewards, should you stick with it or experiment with something that could result in even bigger rewards? In the above Breakout game a simple strategy is to move to the left edge and wait there. When launched, the ball tends to fly left more often than right and you will easily score about 10 points before you die. Will you be satisfied with this or do you want more? This is called the <strong>explore-exploit dilemma</strong> – should you exploit the known working strategy or explore other, possibly better strategies.</p><p>Reinforcement learning is an important model of how we (and all animals in general) learn. Praise from our parents, grades in school, salary at work – these are all examples of rewards. Credit assignment problems and exploration-exploitation dilemmas come up every day both in business and in relationships. That’s why it is important to study this problem, and games form a wonderful sandbox for trying out new approaches.</p><h1 id="Markov-Decision-Process"><a href="#Markov-Decision-Process" class="headerlink" title="Markov Decision Process"></a>Markov Decision Process</h1><p>Now the question is, how do you formalize a reinforcement learning problem, so that you can reason about it? The most common method is to represent it as a Markov decision process.</p><p>Suppose you are an <strong>agent</strong>, situated in an <strong>environment</strong> (e.g. Breakout game). The environment is in a certain <strong>state</strong>(e.g. location of the paddle, location and direction of the ball, existence of every brick and so on). The agent can perform certain <strong>actions</strong> in the environment (e.g. move the paddle to the left or to the right). These actions sometimes result in a <strong>reward</strong> (e.g. increase in score). Actions transform the environment and lead to a new state, where the agent can perform another action, and so on. The rules for how you choose those actions are called <strong>policy</strong>. The environment in general is stochastic, which means the next state may be somewhat random (e.g. when you lose a ball and launch a new one, it goes towards a random direction).</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-12.01.04-PM.png" alt="img">Figure 2: <em>Left: </em>reinforcement learning problem. <em>Right: </em>Markov decision process.</p><p>The set of states and actions, together with rules for transitioning from one state to another, make up a <strong>Markov decision process</strong>. One <strong>episode</strong> of this process (e.g. one game) forms a finite sequence of states, actions and rewards:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.09.19-AM.png" alt="Screen Shot 2015-12-21 at 11.09.19 AM"></p><p>Here si represents the state, ai is the action and ri+1 is the reward after performing the action. The episode ends with <strong>terminal</strong> state sn (e.g. “game over” screen). A Markov decision process relies on the Markov assumption, that the probability of the next state si+1 depends only on current state si and action ai, but not on preceding states or actions.</p><h1 id="Discounted-Future-Reward"><a href="#Discounted-Future-Reward" class="headerlink" title="Discounted Future Reward"></a>Discounted Future Reward</h1><p>To perform well in the long-term, we need to take into account not only the immediate rewards, but also the future rewards we are going to get. How should we go about that?</p><p>Given one run of the Markov decision process, we can easily calculate the <strong>total reward</strong> for one episode:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.09.26-AM.png" alt="Screen Shot 2015-12-21 at 11.09.26 AM"></p><p>Given that, the <strong>total future reward</strong> from time point <em>t</em> onward can be expressed as:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.09.32-AM.png" alt="Screen Shot 2015-12-21 at 11.09.32 AM"></p><p>But because our environment is stochastic, we can never be sure, if we will get the same rewards the next time we perform the same actions. The more into the future we go, the more it may diverge. For that reason it is common to use <strong>discounted future reward </strong>instead:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.09.36-AM.png" alt="Screen Shot 2015-12-21 at 11.09.36 AM"></p><p>Here <em>γ</em> is the discount factor between 0 and 1 – the more into the future the reward is, the less we take it into consideration. It is easy to see, that discounted future reward at time step <em>t</em> can be expressed in terms of the same thing at time step <em>t+1</em>:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.09.40-AM.png" alt="Screen Shot 2015-12-21 at 11.09.40 AM"></p><p>If we set the discount factor <em>γ</em>=0, then our strategy will be short-sighted and we rely only on the immediate rewards. If we want to balance between immediate and future rewards, we should set discount factor to something like <em>γ=</em>0.9. If our environment is deterministic and the same actions always result in same rewards, then we can set discount factor <em>γ</em>=1.</p><p>A good strategy for an agent would be to <strong>always choose an action that maximizes the (discounted) future reward</strong>.</p><h1 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h1><p>In Q-learning we define a function <em>Q(s, a)</em> representing <strong>the maximum discounted future reward when we perform action </strong>a<strong> in state </strong>s<strong>, and continue optimally from that point on.</strong></p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.09.47-AM.png" alt="Screen Shot 2015-12-21 at 11.09.47 AM"></p><p>The way to think about <em>Q(s, a)</em> is that it is “the best possible score at the end of the game after performing action a<strong>in state </strong>s<strong>“. It is called Q-function, because it represents the “quality” of a certain action in a given state.</strong></p><p>This may sound like quite a puzzling definition. How can we estimate the score at the end of game, if we know just the current state and action, and not the actions and rewards coming after that? We really can’t. But as a theoretical construct we can assume existence of such a function. Just close your eyes and repeat to yourself five times: “<em>Q(s, a) </em>exists, <em>Q(s, a) </em>exists, …”. Feel it?</p><p>If you’re still not convinced, then consider what the implications of having such a function would be. Suppose you are in state and pondering whether you should take action <em>a</em> or <em>b</em>. You want to select the action that results in the highest score at the end of game. Once you have the magical Q-function, the answer becomes really simple – pick the action with the highest Q-value!</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.09.56-AM.png" alt="Screen Shot 2015-12-21 at 11.09.56 AM"></p><p>Here π represents the policy, the rule how we choose an action in each state.</p><p>OK, how do we get that Q-function then? Let’s focus on just one transition &lt;<em>s, a, r, s’</em>&gt;. Just like with discounted future rewards in the previous section, we can express the Q-value of state <em>s</em> and action <em>a</em> in terms of the Q-value of the next state <em>s’</em>.</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.10.00-AM.png" alt="Screen Shot 2015-12-21 at 11.10.00 AM">This is called the <strong>Bellman equation</strong>. If you think about it, it is quite logical – maximum future reward for this state and action is the immediate reward plus maximum future reward for the next state.</p><p>The main idea in Q-learning is that <strong>we can iteratively approximate the Q-function using the Bellman equation</strong>. In the simplest case the Q-function is implemented as a table, with states as rows and actions as columns. The gist of the Q-learning algorithm is as simple as the following<a href="https://www.intelnervana.com/demystifying-deep-reinforcement-learning/#_ftn1" target="_blank" rel="external">[1]</a>:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.23.55-AM.png" alt="Screen Shot 2015-12-21 at 11.23.55 AM"></p><p><em>α</em> in the algorithm is a learning rate that controls how much of the difference between previous Q-value and newly proposed Q-value is taken into account. In particular, when <em>α</em>=1, then two <em>Q[s,a]</em> cancel and the update is exactly the same as the Bellman equation.</p><p>The max<em>a’</em> <em>Q</em>[<em>s’</em>,<em>a’</em>] that we use to update <em>Q</em>[<em>s</em>,<em>a</em>] is only an approximation and in early stages of learning it may be completely wrong. However the approximation get more and more accurate with every iteration and <a href="http://simplecore-dev.intel.com/nervana/wp-content/uploads/sites/55/2015/12/ProofQlearning.pdf" target="_blank" rel="external">it has been shown</a>, that if we perform this update enough times, then the Q-function will converge and represent the true Q-value.</p><h1 id="Deep-Q-Network"><a href="#Deep-Q-Network" class="headerlink" title="Deep Q Network"></a>Deep Q Network</h1><p>The state of the environment in the Breakout game can be defined by the location of the paddle, location and direction of the ball and the presence or absence of each individual brick. This intuitive representation however is game specific. Could we come up with something more universal, that would be suitable for all the games? The obvious choice is screen pixels – they implicitly contain all of the relevant information about the game situation, except for the speed and direction of the ball. Two consecutive screens would have these covered as well.</p><p>If we apply the same preprocessing to game screens as in the DeepMind paper – take the four last screen images, resize them to 84×84 and convert to grayscale with 256 gray levels – we would have 25684x84x4 ≈ 1067970 possible game states. This means 1067970 rows in our imaginary Q-table – more than the number of atoms in the known universe! One could argue that many pixel combinations (and therefore states) never occur – we could possibly represent it as a sparse table containing only visited states. Even so, most of the states are very rarely visited and it would take a lifetime of the universe for the Q-table to converge. Ideally, we would also like to have a good guess for Q-values for states we have never seen before.</p><p>This is the point where deep learning steps in. Neural networks are exceptionally good at coming up with good features for highly structured data. We could represent our Q-function with a neural network, that takes the state (four game screens) and action as input and outputs the corresponding Q-value. Alternatively we could take only game screens as input and output the Q-value for each possible action. This approach has the advantage, that if we want to perform a Q-value update or pick the action with the highest Q-value, we only have to do one forward pass through the network and have all Q-values for all actions available immediately.</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.27.12-AM.png" alt="img"></p><p>Figure 3: <em>Left: </em>Naive formulation of deep Q-network. <em>Right: </em>More optimized architecture of deep Q-network, used in DeepMind paper.</p><p>The network architecture that DeepMind used is as follows:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.23.28-AM.png" alt="Screen Shot 2015-12-21 at 11.23.28 AM"></p><p>This is a classical convolutional neural network with three convolutional layers, followed by two fully connected layers. People familiar with object recognition networks may notice that there are no pooling layers. But if you really think about it, pooling layers buy you translation invariance – the network becomes insensitive to the location of an object in the image. That makes perfectly sense for a classification task like ImageNet, but for games the location of the ball is crucial in determining the potential reward and we wouldn’t want to discard this information!</p><p>Input to the network are four 84×84 grayscale game screens. Outputs of the network are Q-values for each possible action (18 in Atari). Q-values can be any real values, which makes it a regression task, that can be optimized with simple squared error loss.</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/formula.png" alt="img"></p><p>Given a transition &lt;<em> s, a, r, s’</em> &gt;, the Q-table update rule in the previous algorithm must be replaced with the following:</p><ol><li>Do a feedforward pass for the current state <em>s</em> to get predicted Q-values for all actions.</li><li>Do a feedforward pass for the next state <em>s’ </em>and calculate maximum overall network outputs <em>max a’ Q(s’, a’).</em></li><li>Set Q-value target for action to <em>r + γmax a’ Q(s’, a’)</em> (use the max calculated in step 2). For all other actions, set the Q-value target to the same as originally returned from step 1, making the error 0 for those outputs.</li><li>Update the weights using backpropagation.</li></ol><h1 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h1><p>By now we have an idea how to estimate the future reward in each state using Q-learning and approximate the Q-function using a convolutional neural network. But it turns out that approximation of Q-values using non-linear functions is not very stable. There is a whole bag of tricks that you have to use to actually make it converge. And it takes a long time, almost a week on a single GPU.</p><p>The most important trick is <strong>experience replay</strong>. During gameplay all the experiences &lt;<em> s, a, r, s’</em> &gt; are stored in a replay memory. When training the network, random minibatches from the replay memory are used instead of the most recent transition. This breaks the similarity of subsequent training samples, which otherwise might drive the network into a local minimum. Also experience replay makes the training task more similar to usual supervised learning, which simplifies debugging and testing the algorithm. One could actually collect all those experiences from human gameplay and then train network on these.</p><h1 id="Exploration-Exploitation"><a href="#Exploration-Exploitation" class="headerlink" title="Exploration-Exploitation"></a>Exploration-Exploitation</h1><p>Q-learning attempts to solve the credit assignment problem – it propagates rewards back in time, until it reaches the crucial decision point which was the actual cause for the obtained reward. But we haven’t touched the exploration-exploitation dilemma yet…</p><p>Firstly observe, that when a Q-table or Q-network is initialized randomly, then its predictions are initially random as well. If we pick an action with the highest Q-value, the action will be random and the agent performs crude “exploration”. As a Q-function converges, it returns more consistent Q-values and the amount of exploration decreases. So one could say, that Q-learning incorporates the exploration as part of the algorithm. But this exploration is “greedy”, it settles with the first effective strategy it finds.</p><p>A simple and effective fix for the above problem is <strong>ε-greedy exploration</strong> – with probability <em>ε</em> choose a random action, otherwise go with the “greedy” action with the highest Q-value. In their system DeepMind actually decreases <em>ε</em> over time from 1 to 0.1 – in the beginning the system makes completely random moves to explore the state space maximally, and then it settles down to a fixed exploration rate.</p><h1 id="Deep-Q-learning-Algorithm"><a href="#Deep-Q-learning-Algorithm" class="headerlink" title="Deep Q-learning Algorithm"></a>Deep Q-learning Algorithm</h1><p>This gives us the final deep Q-learning algorithm with experience replay:</p><p><img src="https://www.intelnervana.com/wp-content/uploads/sites/53/2017/06/Screen-Shot-2015-12-21-at-11.23.43-AM-1.png" alt="Screen Shot 2015-12-21 at 11.23.43 AM"></p><p>There are many more tricks that DeepMind used to actually make it work – like target network, error clipping, reward clipping etc, but these are out of scope for this introduction.</p><p>The most amazing part of this algorithm is that it learns anything at all. Just think about it – because our Q-function is initialized randomly, it initially outputs complete garbage. And we are using this garbage (the maximum Q-value of the next state) as targets for the network, only occasionally folding in a tiny reward. That sounds insane, how could it learn anything meaningful at all? The fact is, that it does.</p><h1 id="Final-notes"><a href="#Final-notes" class="headerlink" title="Final notes"></a>Final notes</h1><p>Many improvements to deep Q-learning have been proposed since its first introduction – <a href="http://arxiv.org/abs/1509.06461" target="_blank" rel="external">Double Q-learning</a>, <a href="http://arxiv.org/abs/1511.05952" target="_blank" rel="external">Prioritized Experience Replay</a>, <a href="http://arxiv.org/abs/1511.06581" target="_blank" rel="external">Dueling Network Architecture</a> and <a href="http://arxiv.org/abs/1509.02971" target="_blank" rel="external">extension to continuous action space</a> to name a few. For latest advancements check out the <a href="http://rll.berkeley.edu/deeprlworkshop/" target="_blank" rel="external">NIPS 2015 deep reinforcement learning workshop</a> and <a href="https://cmt.research.microsoft.com/ICLR2016Conference/Protected/PublicComment.aspx" target="_blank" rel="external">ICLR 2016</a>(search for “reinforcement” in title). But beware, that <a href="http://www.google.com/patents/US20150100530" target="_blank" rel="external">deep Q-learning has been patented by Google</a>.</p><p>It is often said, that artificial intelligence is something we haven’t figured out yet. Once we know how it works, it doesn’t seem intelligent any more. But deep Q-networks still continue to amaze me. Watching them figure out a new game is like observing an animal in the wild – a rewarding experience by itself.</p><h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>Thanks to Ardi Tampuu, Tanel Pärnamaa, Jaan Aru, Ilya Kuzovkin, Arjun Bansal and Urs Köster for comments and suggestions on the drafts of this post.</p><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><ul><li><a href="http://videolectures.net/rldm2015_silver_reinforcement_learning/" target="_blank" rel="external">David Silver’s lecture about deep reinforcement learning</a></li><li><a href="https://www.youtube.com/watch?v=b1a53hE0yQs" target="_blank" rel="external">Slightly awkward but accessible illustration of Q-learning</a></li><li><a href="http://rll.berkeley.edu/deeprlcourse/" target="_blank" rel="external">UC Berkley’s course on deep reinforcement learning</a></li><li><a href="http://www0.cs.ucl.ac.uk/staff/D.Silver/web/Teaching.html" target="_blank" rel="external">David Silver’s reinforcement learning course</a></li><li><a href="https://www.cs.ox.ac.uk/people/nando.defreitas/machinelearning/" target="_blank" rel="external">Nando de Freitas’ course on machine learning</a> (two lectures about reinforcement learning in the end)</li><li><a href="http://cs231n.github.io/" target="_blank" rel="external">Andrej Karpathy’s course on convolutional neural networks</a></li></ul><p><a href="https://www.intelnervana.com/demystifying-deep-reinforcement-learning/#_ftnref1" target="_blank" rel="external">[1]</a> Algorithm adapted from <a href="http://artint.info/html/ArtInt_265.html" target="_blank" rel="external">http://artint.info/html/ArtInt_265.html</a><br>This blog was first published at: <a href="http://neuro.cs.ut.ee/demystifying-deep-reinforcement-learning/" target="_blank" rel="external">http://neuro.cs.ut.ee/demystifying-deep-reinforcement-learning/</a></p><h4 id="This-is-the-part-1-of-my-series-on-deep-reinforcement-learning-Tune-in-next-week-for-“Deep-Reinforcement-Learning-with-Neon”-for-an-actual-implementation-with-Neon-deep-learning-toolkit"><a href="#This-is-the-part-1-of-my-series-on-deep-reinforcement-learning-Tune-in-next-week-for-“Deep-Reinforcement-Learning-with-Neon”-for-an-actual-implementation-with-Neon-deep-learning-toolkit" class="headerlink" title="This is the part 1 of my series on deep reinforcement learning. Tune in next week for “Deep Reinforcement Learning with Neon” for an actual implementation with Neon deep learning toolkit."></a>This is the part 1 of my series on deep reinforcement learning. Tune in next week for <a href="https://www.intelnervana.com/deep-reinforcement-learning-with-neon/" target="_blank" rel="external">“Deep Reinforcement Learning with Neon”</a> for an actual implementation with <a href="https://github.com/NervanaSystems/neon" target="_blank" rel="external">Neon</a> deep learning toolkit.</h4></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Ewan Li"><p class="site-author-name" itemprop="name">Ewan Li</p><p class="site-description motion-element" itemprop="description">Ewan's IT Blog</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">130</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">64</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ewanlee" target="_blank" title="Github"><i class="fa fa-fw fa-globe"></i> Github </a></span><span class="links-of-author-item"><a href="https://twitter.com/tomaxent" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Ewan Li</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">Theme - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user">本站访客数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次</span> <span class="site-pv"><i class="fa fa-eye">本站总访问量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">_hcwp=window._hcwp||[],_hcwp.push({widget:"Bloggerstream",widget_id:89825,selector:".hc-comment-count",label:"{%COUNT%}"}),function(){if(!("HC_LOAD_INIT"in window)){HC_LOAD_INIT=!0;var t=(navigator.language||navigator.systemLanguage||navigator.userLanguage||"en").substr(0,2).toLowerCase(),e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src=("https:"==document.location.protocol?"https":"http")+"://w.hypercomments.com/widget/hc/89825/"+t+"/widget.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n.nextSibling)}}()</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),n=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,n=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),o=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=n&&a.forEach(function(e,t){i=n.indexOf(e),l=s.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+o+"' class='search-result-title'>"+n+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),n.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("e27VKX5tTklQLCtF7iNMmhcA-gzGzoHsz","nnQn2znNgXXEdK7W2bVJ3bfK")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html>